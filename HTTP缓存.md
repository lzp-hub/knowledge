## HTTP缓存

### 关于缓存

什么是缓存？ 浏览器缓存指的是浏览器将用户请求过的静态资源，储存到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。

为什么需要缓存？ 网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。

哪些资源可以被缓存？ 静态资源，比如 js css img。

### 浏览器缓存的优点

1. **降低服务器的压力**，提升网站性能。
2. 加快客户端**加载网页的速度**， 提升用户体验
3. 减少重复数据请求，**避免通过网络再次加载资源**，节省流量



### 强制缓存

不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 Expires、Cache-Control 和 Pragma 3 个 Header 属性共同来控制。

**优先级 Pragma > Cache-Control > Expires**

#### Expires

Expires 是 http 1.0 的规范的一个**响应**首部字段，值是一个**GMT 格式的时间点字符串**，比如 Expires:Mon,18 Oct 2066 23:59:59 GMT。它指定了一个日期/时间，在这个时间/日期之前，HTTP缓存被认为是有效的。无效的日期比如 0，表示这个资源已经过期了。**如果同时设置了`Cache-Control`响应首部字段的`max-age`，则`Expires`会被忽略**

> 由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。目前仅为HTTP/1.0的向后兼容而使用。

#### Cache-Control

Cache-Control 是 HTTP/1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：

> - **max-age**：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效；即**缓存最大过期时间**。
>
> - **no-cache**：不使用强缓存，即使用协商缓存
>
> - **no-store**：禁止使用缓存（即强缓存和协商缓存都禁止），每次都向服务器请求最新的资源
>
> - private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应
>
> - public：响应可以被中间代理、CDN 等缓存
>
> - must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证
>
>   ```js
>   const express = require('express');
>   const app = express();
>   var options = { 
>     etag: false, // 禁用etag协商缓存
>     lastModified: false, // 禁用lastModified协商缓存
>     setHeaders: (res, path, stat) => {
>       res.set('Cache-Control', 'max-age=10'); // 强缓存超时时间为10秒
>     },
>   };
>   app.use(express.static((__dirname + '/public'), options));
>   app.listen(3000);
>   ```
>
>   **只有响应报文首部设置`Cache-Control`为非0的`max-age`。同时响应报文首部中`Cache-Control`不存在`no-cache`、`no-store`，并且请求报文首部不存在`Pragma`字段，才会真正命中强缓存**

#### Pragma

`Pragma`只有一个属性值,就是 **no-cache** ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，而是进行协商缓存。仅作为于HTTP/1.0的向后兼容而使用



### 协商缓存

当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存。这时可由服务器来确定协商缓存资源是否可用。

主要涉及到两对成对出现的属性字段，即**第一次请求的响应头**带上某个字段, 如**Last-Modified 或者 Etag**，则后续请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 **304** 状态，加载浏览器缓存，并且请求响应头会设置 Last-Modified 或者 ETag 属性。

#### Last-Modified/If-Modified-Since

> Last-Modified：响应头，资源最后修改时间，由服务器告诉浏览器；
>
> If-Modified-Since：请求头，资源最后修改时间，由浏览器告诉服务器。

Last-Modified/If-Modified-Since 的值代表的都是文件的最后修改时间，第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。



#### Etag/If-None-Match

> Etag：响应头，资源标识，由服务器告诉浏览器。
>
> If-None-Match：请求头，缓存资源标识，由浏览器告诉服务器。

Etag/If-None-Match 的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash 码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。

ETag 又有强弱校验之分，如果 hash 码是以 "W/" 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 Etag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。

**很多网站的资源后面都加了版本号，这样做的目的是：每次升级了JS或CSS文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的JS或CSS文件，以保证用户能够及时获得网站的最新更新。**

```js
const express = require('express');
const app = express();
var options = { 
  etag: true, // 开启etag协商缓存
  lastModified: true, // 开启lastModified协商缓存
  setHeaders: (res, path, stat) => {
    res.set({
      'Cache-Control': 'max-age=00', // 浏览器不走强缓存
      'Pragma': 'no-cache', // 浏览器不走强缓存，走协商缓存
    });
  },
};
app.use(express.static((__dirname + '/public'), options));
app.listen(3001);
```

**Last-Modified 只能精确到秒级。如果资源更新的速度是秒以下单位，那么就会造成缓存命中不准确**

**Last-Modified与Etag属性同时出现的时候，Etag的优先级更高**

#### 协商缓存中，有了 Last-Modified，为什么还会出现 ETag？

Etag的出现，主要是为了解决 Last-Modified 无法解决的一些问题：

- 某些服务器**不能精确得到文件的最后修改时间**， 这样就无法通过最后修改时间来判断文件是否更新了。
- 某些文件的修改非常**频繁**，**在秒以下的时间内进行修改**，Last-Modified只能精确到秒，无法判断文件是否更新。
- 一些文件的**最后修改时间改变了，但是内容并未改变**， 使用ETag可以正确缓存。



### 强缓存和协商缓存区别

是否需要发请求给服务器；状态码不同。

1. 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。

2. 在 chrome 中强缓存（虽然没有发出真实的 http 请求）的请求状态码返回是 200 (from cache)；而协商缓存如果命中走缓存的话，请求的状态码是 304 (not modified)。



### 三种刷新操作对 http 缓存的影响

- 正常操作：地址栏输入 url，跳转链接，前进后退等。

  > 强制缓存有效，协商缓存有效，静态资源可以直接使用本地缓存的。

- 手动刷新：f5，点击刷新按钮，右键菜单刷新。（发送一个带上If-Modified-since的请求）

  > 强制缓存失效，协商缓存有效，走协商缓存去了。

- 强制刷新：windows： ctrl + f5；mac： shift+command+r。

  > 强制缓存失效，协商缓存失效.就是直接把缓存给忽略，重新请求去了。



### 缓存总结

在实际的缓存机制中，强缓存策略和协商缓存策略是在一起**合作使用**的。浏览器首先会根据请求的信息判定，强缓存是否命中，如果命中则直接使用本地资源，如果不命中则根据头信息向服务器发起请求，如果使用协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则服务器返回最新的资源给浏览器。



### cookie

- **HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息**）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。
- **cookie 存储在客户端：** cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
- **cookie 是不可跨域的：** 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，**一级域名和二级域名之间是允许共享使用的**（**靠的是 domain）**。

**cookie 重要的属性**

| 属性           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| **name=value** | 键值对，设置 Cookie 的名称及相对应的值，都必须是**字符串类型** - 如果值为 Unicode 字符，需要为字符编码。 - 如果值为二进制数据，则需要使用 BASE64 编码。 |
| **domain**     | 指定 cookie 所属域名，默认是当前域名                         |
| **path**       | **指定 cookie 在哪个路径（路由）下生效，默认是 '/'**。 如果设置为 `/abc`，则只有 `/abc` 下的路由可以访问到该 cookie，如：`/abc/read`。 |
| **maxAge**     | cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。 - **比 expires 好用**。 |
| **expires**    | 过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除 |
| **secure**     | 该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。 |
| **httpOnly**   | **如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全** |
| **SameSite**   | **限制第三方 Cookie**，从而减少安全风险。**Strict** 称为严格模式，当前网页的 URL 与请求目标一致，才会带上 Cookie，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。**Lax** 模式称为宽松模式。如果这个请求是个 GET 请求a标签，link标签，form method="GET" 当这个请求打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie；**None** 模式 Cookie将在所有上下文中发送，即允许跨域发送。不过，前提是必须同时设置**Secure**属性（Cookie 只能通过 HTTPS 协议发送），否则无效。设置了**Strict**或**Lax**以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。**Chrome 80之前SameSite的默认值是none，之后是Lax。不过在最新的 `Chrome91` 版本中这个`已经被移除`了，所以在 91之前的版本依然可以使用** |





### 状态码分类

- 1xx - 服务器收到请求。

- 2xx - 请求成功，如 200。

  > + 200 - 成功
  > + 201   创建成功

- 3xx - 重定向，如 304。

  > - 301 - 永久重定向（配合 location，浏览器自动处理）。
  > - 302 - 临时重定向（配合 location，浏览器自动处理）。
  > - 304 - 资源未被修改，协商缓存

- 4xx - 客户端错误，如 404。

  > - 401   无权限
  > - 402   需要付费导致的无权限
  > - 403 - 没权限，禁止访问。
  > - 404 - 资源未找到

- 5xx - 服务端错误，如 500。

  > - 500 - 服务器错误。
  > - 504 - 网关超时。