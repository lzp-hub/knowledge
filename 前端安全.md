# 前端安全

web 攻击（WebAttack）是针对用户上网行为或网站服务器等设备进行攻击的行为

如**植入恶意代码，修改网站权限，获取网站用户隐私信息**等等

## XSS

Cross Site Scripting 跨站脚本攻击，允许攻击者将**恶意代码植入**到提供给其它用户使用的**页面**中。目标是为了盗取存储在客户端的`cookie`或者其他网站用于识别客户端身份的敏感信息。一旦获取到合法用户的信息后，攻击者甚至可以假冒合法用户与网站进行交互

**恶意脚本都能做哪些事情**

1. 可以**窃取 Cookie 信息**。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。
2. 可以**监听用户行为**。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。
3. 可以通过**修改 DOM**伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
4. 还可以**在页面内生成浮窗广告**，这些广告会严重地影响用户体验。

**脚本注入方式**

- 存储型（server 端）: 恶意代码存在数据库里

  常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等

- 反射型（server 端）: 恶意代码存在 URL 里

  常见于通过 URL 传递参数的功能，如网站搜索、跳转等。用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端

- DOM 型（浏览器端） 取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞.

  黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 **Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据**

**后端预防 xss 手段**

1. 服务器对输入脚本进行过滤或转码

   不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码，比如最典型的

   ```html
   <!-- 原始恶意代码 -->
   <script>
     alert("你被 xss 攻击了");
   </script>

   <!-- 过滤后的安全代码 -->
   &lt;script&gt;alert(&#39;你被 xss 攻击了&#39;)&lt;/script&gt;
   ```

2. 配置 CSP

   网页安全政策，“Content Security Policy”，缩写 CSP。
   CSP 的实质就是`白名单制度`，明确**告诉客户端哪些外部资源可以加载和执行**

   两种方法可以启用 CSP。

   - 后端：通过 HTTP 头信息的`Content-Security-Policy`的字段。

   ```http
   Content-Security-Policy: script-src 'self'; object-src 'none';
   style-src cdn.example.org third-party.org; child-src https:
   ```

   - 前端：通过网页的`<meta>`标签

     ```HTML
     <meta http-equiv="Content-Security-Policy" content="script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:">
     ```

     - 脚本：只信任当前域名
     - `<object>`标签：不信任任何 URL，即不加载任何资源
     - 样式表：只信任`cdn.example.org`和`third-party.org`
     - 框架（frame）：必须使用 HTTPS 协议加载
     - 其他资源：没有限制

- 将 cookie **HttpOnly**属性设置为 true ，这样无法通过 js 进行访问 cookie 或其他操作，只是在发送对应域下的请求时，浏览器会自动带上。这样可以有效缓解 XSS 攻击。
  HttpOnly 是服务器通过 HTTP **响应头**来设置的。JavaScript Document.cookie API 无法访问带有 HttpOnly 属性的 cookie；此类 Cookie 仅作用于服务器。例如，持久化服务器端会话的 Cookie 不需要对 JavaScript 可用，而应具有 HttpOnly 属性。

**前端预防 xss**

1. 输入验证：比如一些常见的数字、URL、电话号码、邮箱地址等等，而对于一些不受信任的输入，还可以限制其输入长度做校验判断

2. 对数据进行严格的输出编码：如 HTML 元素的编码，JS 编码，CSS 编码，URL 编码等等**避免拼接 HTML**
   在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等

3. 用 `Vue/React` 技术栈，并且不使用 `v-html`/`dangerouslySetInnerHTML` 功能，就能 `render` 阶段避免 `innerHTML`、`outerHTML` 的 XSS 隐患
   除非使用**dompurify**的 HTML 净化工具，可以检测出 HTML 代码中潜在的恶意部分，输出一个干净安全的版本

4. DOM 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，JavaScript 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能**把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API**，很容易产生安全隐患，请务必避免

   ```html
   <!-- 链接内包含恶意代码 -->
   <a href="javascript:alert('XSS')">点击我</a>
   ```

   ```javascript
   <script>
   // ❌ 危险用法 - 字符串作为代码执行
   setTimeout("alert('XSS')", 1000);
   setInterval("maliciousCode()", 1000);

   // ❌ 危险用法 - 直接执行用户输入
   location.href = userInput;

   // ❌ 危险用法 - eval 执行任意代码
   eval(userInput);

   // ✅ 安全用法
   setTimeout(() => {
     // 安全的代码逻辑
   }, 1000);

   // ✅ 安全用法 - 验证输入
   if (isValidUrl(userInput)) {
     location.href = userInput;
   }
   </script>
   ```

### CSRF

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者（拥有自身网站登陆凭证 Cookie）进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的登临凭证，绕过后台的用户验证，达到**冒充用户对被攻击的网站执行某项操作的目地**。简单来说，就是去第三方网站，对验证了凭证 cookie 的网站发送跨站请求。

### CSRF 攻击实例

CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amount=1000000&for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。

**特点**

- 攻击一般发起在第三方网站，而不是被攻击的网站。
- 攻击利用受害者在被攻击网站的登录凭证，**冒充**受害者提交操作；而不是直接窃取数据
- 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”
- 跨站请求可以用各种方式：**图片 URL、超链接、CORS、Form 提交**等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪

可能会造成以下影响：

- 利用已通过认证的用户权限更新设定信息等；
- 利用已通过认证的用户权限购买商品；
- 利用已通过的用户权限在留言板上发表言论。

**csrf 预防**

CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性

1. 通过添加**验证码**：防止脚本冒充用户提交危险操作

2. 验证 HTTP Referer 字段：根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了**该 HTTP 请求的来源地址**。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory，用户必须先登陆 bank.example

3. Cookie 的**SameSite**属性可用来**限制第三方 Cookie**，从而减少安全风险。

> SameSite 是 HTTP**响应头** `Set-Cookie` 的属性之一。它允许声明该 `Cookie` 是否仅限于第一方或者同一站点上下文。
>
> 1. **Strict** 称为严格模式，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。
>
>    ```css
>     Set-Cookie: CookieName=CookieValue; SameSite=Strict;
>    ```
>
> 2. **Lax** 模式称为宽松模式。如果这个请求是个 GET 请求，并且这个请求改变了当前页面或者打开了新的页面，那么这个 cookie 可以作为第三方 cookie，其余情况下都不能作为第三方 cookie
>
>    > 它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都需要重新登录。还有一个问题就是它的兼容性不够好。
>
>    ```css
>     Set-Cookie: CookieName=CookieValue; SameSite=Lax;
>    ```
>
>    导航到目标网址的 GET 请求，只包括三种情况：**链接，预加载请求，GET 表单**。详见下表。
>
>    | 请求类型     | 示例代码                             | SameSite=None | SameSite=Lax |
>    | ------------ | ------------------------------------ | ------------- | ------------ |
>    | **链接**     | `<a href="..."></a>`                 | 发送 Cookie   | 发送 Cookie  |
>    | **预加载**   | `<link rel="prerender" href="..."/>` | 发送 Cookie   | 发送 Cookie  |
>    | **GET 表单** | `<form method="GET" action="...">`   | 发送 Cookie   | 发送 Cookie  |
>    | POST 表单    | `<form method="POST" action="...">`  | 发送 Cookie   | 不发送       |
>    | iframe       | `<iframe src="..."></iframe>`        | 发送 Cookie   | 不发送       |
>    | AJAX         | `$.get("...")`                       | 发送 Cookie   | 不发送       |
>    | Image        | `<img src="...">`                    | 发送 Cookie   | 不发送       |
>
>    设置了 Strict 或 Lax 以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。
>
> 3. **None** 模式 Cookie 将在所有上下文中发送，即允许跨域发送。不过，前提是必须同时设置**Secure**属性（Cookie 只能通过 HTTPS 协议发送），否则无效。
>
>    ```css
>     // 下面的设置无效。
>    Set-Cookie: widget_session=abc123; SameSite=None
>
>    // 下面的设置有效，前提是必须同时设置Secure属性。
>          Set-Cookie: widget_session=abc123; SameSite=None; Secure
>    ```
>
>    **Chrome 80 之前 SameSite 的默认值是 none，之后是 lax。不过在最新的 `Chrome91` 版本中这个`已经被移除`了，所以在 91 之前的版本依然可以使用**

3. **token 验证 CSRF 防御机制是公认最合适的方案**

> 1. 后端随机产生一个 token，把这个 token 保存到 session 状态中；同时后端把这个 token 交给前端页面；
>
> 2. 前端页面提交请求时，把 token 加入到请求数据或者头信息中，一起传给后端；
>
> 3. 后端验证前端传来的 token 与 session 是否一致，一致则合法，否则是非法请求

### SQL 注入

就是通过把 SQL 命令插入到**Web 表单递交**或**输入域名**或**页面请求**的查询字符串，最终达到欺骗数据库服务器执行恶意的 SQL 命令,从而达到和服务器进行直接的交互

流程如下所示：

- 找出 SQL 漏洞的注入点
- 判断数据库的类型以及版本
- 猜解用户名和密码
- 利用工具查找 Web 后台管理入口
- 入侵和破坏

**预防方式**如下：

- 严格检查输入变量的类型和格式
- 后台进行**输入验证**，对敏感字符过滤和转义特殊字符
- **用参数化查询**，能避免拼接 SQL，就不要拼接 SQL 语句
- 对访问数据库的 Web 应用程序采用 Web 应用防火墙

### 点击挟持

点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 **iframe** 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个**按钮**诱导用户点击；或者使用一张**图片**覆盖在网页，遮挡网页原有的位置含义。

**防御手段**

我们可以在 http **响应头**中设置 **X-Frame-Options** 来防御用 iframe 嵌套的点击劫持攻击。通过不同的值，可以规定页面在特 定的一些情况才能作为 iframe 来使用。

- **X-Frame-Options** **是否允许页面被嵌套**，即是否允许在 frame 中展示

  > - DENY：表示页面**不允许在 frame** 中展示，即便是在相同域名的页面中嵌套也不允许。
  >
  > * SAMEORIGIN：表示该页面可以在**相同域名**页面的 frame 中展示。
  > * ALLOW-FROM url：表示该页面可以在**指定来源**的 frame 中展示。

### 预防中间人攻击

- i）用可信的第三方**CA**厂商
- ii）不下载未知来源的**证书**，不要去下载一些不安全的文件
- iii）确认你访问的 URL 是 HTTPS 的，确保网站使用了**SSL**，确保禁用一些不安全的 SSL，只开启：TLS1.1，TLS1.2
- iv）不要使用公用网络发送一些敏感的信息
- v）**不要去点击一些不安全的连接或者恶意链接或邮件信息**

### 网络挟持

**DNS 劫持（涉嫌违法）**：修改运行商的 DNS 记录，重定向到其他网站。DNS 劫持是违法的行为，目前 DNS 劫持已被监管，现在很少见 DNS 劫持

**HTTP 劫持**：前提有 HTTP 请求。因 HTTP 是明文传输，运营商便可借机修改 HTTP 响应内容（如加广告）

**HTTP 劫持预防**：全站 HTTPS

### HTTPS 降级

黑客可以利用 SSL Stripping 这种攻击手段，强制让 HTTPS 降级回 HTTP，从而继续进行中间人攻击。

**预防**：**使用 HSTS**（HTTP Strict Transport Security），它通过下面这个 HTTP Header 以及一个预加载的清单，来告知浏览器和网站进行通信的时候强制性的使用 HTTPS，而不是通过明文的 HTTP 进行通信。这里的“强制性”表现为浏览器无论在何种情况下都直接向务器端发起 HTTPS 请求，而不再像以往那样从 HTTP 跳转到 HTTPS。另外，当遇到证书或者链接不安全的时候，则首先警告用户，并且不再让用户选择是否继续进行不安全的通信。

### 前端的常规安全策略

- 定期请第三方机构做安全性测试，漏洞扫描
- 使用第三方开源库做上线前的安全测试，可以考虑融合到 CI 中
- code review 保证代码质量
- 默认项目中设置对应的 Header 信息，如 X-XSS-Protection、 X-Content-Type-Options 、**X-Frame-Options** 、**Content-Security-Policy** 等等
- 对第三方包和库做检测：NSP(Node Security Platform)，Snyk

### 安全头配置详解

**常用的安全响应头：**

```http
# 防止 XSS 攻击
X-XSS-Protection: 1; mode=block

# 防止 MIME 类型嗅探
X-Content-Type-Options: nosniff

# 防止点击劫持
X-Frame-Options: DENY

# 内容安全策略
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'

# 强制 HTTPS
Strict-Transport-Security: max-age=31536000; includeSubDomains

# 防止信息泄露
X-Permitted-Cross-Domain-Policies: none
Referrer-Policy: strict-origin-when-cross-origin
```

**Express.js 中配置安全头：**

```javascript
const helmet = require("helmet");

app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"],
      },
    },
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true,
    },
  })
);
```

---

## 其他前端安全问题

### 1. **信息泄露**

**问题描述：**
前端代码中可能包含敏感信息，如 API 密钥、数据库连接字符串、内部系统地址等。

**常见泄露场景：**

- 代码注释中的敏感信息
- 前端配置文件中的密钥
- 错误信息暴露系统架构
- 控制台日志输出敏感数据

**预防措施：**

```javascript
// ❌ 错误示例
const API_KEY = "sk-1234567890abcdef"; // 敏感信息
console.log("用户密码:", password); // 控制台泄露

// ✅ 正确做法
const API_KEY = process.env.REACT_APP_API_KEY; // 环境变量
// 生产环境移除 console.log
if (process.env.NODE_ENV !== "production") {
  console.log("调试信息:", data);
}
```

### 2. **依赖包安全**

**问题描述：**
第三方依赖包可能存在安全漏洞，被恶意利用。

**预防措施：**

```bash
# 定期检查依赖包漏洞
npm audit
npm audit fix

# 使用安全工具
npx snyk test
npx retire
```

**最佳实践：**

- 定期更新依赖包
- 使用 `package-lock.json` 锁定版本
- 审查新添加的依赖包
- 使用自动化安全扫描工具

### 3. **本地存储安全**

**问题描述：**
localStorage、sessionStorage 中存储敏感信息可能被恶意脚本访问。

**预防措施：**

```javascript
// ❌ 错误示例
localStorage.setItem("token", "sensitive-token");
localStorage.setItem("userInfo", JSON.stringify({ password: "123456" }));

// ✅ 正确做法
// 1. 加密存储
const encryptedToken = CryptoJS.AES.encrypt(token, secretKey).toString();
localStorage.setItem("token", encryptedToken);

// 2. 设置过期时间
const tokenData = {
  token: token,
  expires: Date.now() + 24 * 60 * 60 * 1000, // 24小时
};
localStorage.setItem("token", JSON.stringify(tokenData));

// 3. 定期清理
function cleanExpiredTokens() {
  const tokenData = JSON.parse(localStorage.getItem("token") || "{}");
  if (tokenData.expires && Date.now() > tokenData.expires) {
    localStorage.removeItem("token");
  }
}
```

### 4. **URL 参数安全**

**问题描述：**
URL 参数可能被篡改，导致权限绕过或信息泄露。

**预防措施：**

```javascript
// ❌ 错误示例
// 直接使用 URL 参数进行权限判断
const userId = new URLSearchParams(window.location.search).get("userId");
if (userId === "admin") {
  showAdminPanel();
}

// ✅ 正确做法
// 1. 服务端验证
const userId = new URLSearchParams(window.location.search).get("userId");
const response = await fetch(`/api/verify-user/${userId}`, {
  headers: { Authorization: `Bearer ${token}` },
});
if (response.ok) {
  showAdminPanel();
}

// 2. 参数加密
const encryptedParams = CryptoJS.AES.encrypt(
  JSON.stringify(params),
  secretKey
).toString();
window.location.href = `/page?data=${encryptedParams}`;
```

### 5. **文件上传安全**

**问题描述：**
恶意文件上传可能导致服务器被攻击。

**预防措施：**

```javascript
// 前端文件类型验证
function validateFile(file) {
  const allowedTypes = ["image/jpeg", "image/png", "image/gif"];
  const maxSize = 5 * 1024 * 1024; // 5MB

  if (!allowedTypes.includes(file.type)) {
    throw new Error("不支持的文件类型");
  }

  if (file.size > maxSize) {
    throw new Error("文件大小超过限制");
  }

  return true;
}

// 文件内容验证
function validateFileContent(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = function (e) {
      const content = e.target.result;
      // 检查文件头
      if (
        content.startsWith("FFD8FF") || // JPEG
        content.startsWith("89504E47") || // PNG
        content.startsWith("47494638")
      ) {
        // GIF
        resolve(true);
      } else {
        reject(new Error("文件内容验证失败"));
      }
    };
    reader.readAsArrayBuffer(file);
  });
}
```

### 6. **WebSocket 安全**

**问题描述：**
WebSocket 连接可能被恶意利用，进行数据窃取或攻击。

**预防措施：**

```javascript
// WebSocket 连接安全配置
const ws = new WebSocket("wss://secure-websocket.com/ws", {
  // 使用 WSS 协议
  // 添加认证头
  headers: {
    Authorization: `Bearer ${token}`,
  },
});

// 消息验证
ws.onmessage = function (event) {
  try {
    const data = JSON.parse(event.data);
    // 验证消息格式和内容
    if (validateMessage(data)) {
      handleMessage(data);
    }
  } catch (error) {
    console.error("无效的消息格式");
  }
};

// 连接状态监控
ws.onclose = function (event) {
  if (event.code === 1006) {
    // 异常关闭，可能是攻击
    console.warn("WebSocket 连接异常关闭");
  }
};
```

### 7. **第三方脚本安全**

**问题描述：**
第三方脚本可能被篡改，执行恶意代码。

**预防措施：**

```html
<!-- 使用 SRI (Subresource Integrity) -->
<script
  src="https://cdn.example.com/library.js"
  integrity="sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC"
  crossorigin="anonymous"
></script>

<!-- 使用 CSP 限制脚本来源 -->
<meta
  http-equiv="Content-Security-Policy"
  content="script-src 'self' https://trusted-cdn.com"
/>
```

### 8. **客户端路由安全**

**问题描述：**
前端路由可能被绕过，访问未授权页面。

**预防措施：**

```javascript
// React Router 路由守卫
import { Navigate } from "react-router-dom";

function ProtectedRoute({ children }) {
  const isAuthenticated = checkAuth();

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return children;
}

// Vue Router 路由守卫
router.beforeEach((to, from, next) => {
  const isAuthenticated = checkAuth();

  if (to.meta.requiresAuth && !isAuthenticated) {
    next("/login");
  } else {
    next();
  }
});
```

---

## 前端安全最佳实践

### 1. **开发阶段安全规范**

**代码审查清单：**

- [ ] 检查是否有硬编码的敏感信息
- [ ] 验证所有用户输入
- [ ] 检查第三方依赖包安全性
- [ ] 确认错误信息不泄露系统信息
- [ ] 验证文件上传功能安全性
- [ ] 检查本地存储使用是否安全

**开发工具配置：**

```json
// .eslintrc.js - 安全规则配置
{
  "extends": ["eslint:recommended", "plugin:security/recommended"],
  "plugins": ["security"],
  "rules": {
    "security/detect-eval-with-expression": "error",
    "security/detect-non-literal-regexp": "error",
    "security/detect-unsafe-regex": "error"
  }
}
```

### 2. **生产环境安全配置**

**HTTP 安全头配置：**

```javascript
// Express.js 安全头配置
const helmet = require("helmet");

app.use(
  helmet({
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:", "https:"],
      },
    },
    hsts: {
      maxAge: 31536000,
      includeSubDomains: true,
      preload: true,
    },
  })
);
```

**环境变量管理：**

```bash
# .env.production
REACT_APP_API_URL=https://api.yourdomain.com
REACT_APP_CDN_URL=https://cdn.yourdomain.com

# .env.development
REACT_APP_API_URL=http://localhost:3000
REACT_APP_CDN_URL=http://localhost:3001
```

### 3. **安全监控和日志**

**前端错误监控：**

```javascript
// 错误监控配置
import * as Sentry from "@sentry/react";

Sentry.init({
  dsn: process.env.REACT_APP_SENTRY_DSN,
  environment: process.env.NODE_ENV,
  beforeSend(event) {
    // 过滤敏感信息
    if (event.exception) {
      event.exception.values.forEach((exception) => {
        if (exception.stacktrace) {
          exception.stacktrace.frames.forEach((frame) => {
            // 移除敏感信息
            frame.filename = frame.filename?.replace(
              /\/[^\/]*\/[^\/]*\//,
              "/***/"
            );
          });
        }
      });
    }
    return event;
  },
});
```

**安全事件日志：**

```javascript
// 安全事件记录
function logSecurityEvent(eventType, details) {
  const securityLog = {
    timestamp: new Date().toISOString(),
    eventType: eventType,
    userAgent: navigator.userAgent,
    url: window.location.href,
    details: details,
  };

  // 发送到安全监控系统
  fetch("/api/security/log", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(securityLog),
  });
}

// 使用示例
logSecurityEvent("XSS_ATTEMPT", {
  input: userInput,
  sanitized: sanitizedInput,
});
```

### 4. **安全测试策略**

**自动化安全测试：**

```json
// package.json 安全测试脚本
{
  "scripts": {
    "security:audit": "npm audit",
    "security:test": "npx snyk test",
    "security:monitor": "npx snyk monitor",
    "security:check": "npm run security:audit && npm run security:test"
  }
}
```

**安全测试用例：**

```javascript
// 安全测试示例
describe("安全测试", () => {
  test("XSS 防护测试", () => {
    const maliciousInput = '<script>alert("XSS")</script>';
    const sanitized = sanitizeInput(maliciousInput);
    expect(sanitized).not.toContain("<script>");
  });

  test("CSRF 防护测试", () => {
    const csrfToken = generateCSRFToken();
    expect(csrfToken).toBeDefined();
    expect(csrfToken.length).toBeGreaterThan(10);
  });

  test("文件上传安全测试", () => {
    const maliciousFile = new File(["malicious content"], "test.exe", {
      type: "application/x-executable",
    });
    expect(() => validateFile(maliciousFile)).toThrow();
  });
});
```

### 5. **团队安全培训**

**安全开发规范：**

1. **输入验证**：所有用户输入必须验证
2. **输出编码**：所有输出必须正确编码
3. **权限控制**：最小权限原则
4. **错误处理**：不泄露敏感信息
5. **日志记录**：记录安全相关事件
6. **依赖管理**：定期更新和审计

**安全代码审查要点：**

- 检查敏感信息泄露
- 验证输入输出处理
- 确认权限控制逻辑
- 检查错误处理机制
- 验证第三方依赖安全性

### 6. **应急响应计划**

**安全事件响应流程：**

1. **发现阶段**：监控系统告警
2. **评估阶段**：确定影响范围
3. **响应阶段**：实施防护措施
4. **恢复阶段**：修复漏洞
5. **总结阶段**：改进安全措施

### 7. **安全等级评估**

**前端安全风险等级表：**

| 风险等级 | 影响程度             | 示例场景             | 响应时间  |
| -------- | -------------------- | -------------------- | --------- |
| **高危** | 数据泄露、系统被控   | XSS 攻击、CSRF 攻击  | 立即响应  |
| **中危** | 功能异常、用户体验差 | 点击劫持、信息泄露   | 24 小时内 |
| **低危** | 轻微影响             | 依赖包漏洞、配置不当 | 1 周内    |

**安全评估检查清单：**

- [ ] **输入验证**：所有用户输入是否经过验证
- [ ] **输出编码**：所有输出是否经过正确编码
- [ ] **权限控制**：是否遵循最小权限原则
- [ ] **错误处理**：错误信息是否泄露敏感信息
- [ ] **数据传输**：是否使用 HTTPS 加密传输
- [ ] **存储安全**：敏感数据是否加密存储
- [ ] **依赖管理**：第三方依赖是否定期更新
- [ ] **安全头**：是否配置了必要的安全响应头
- [ ] **监控日志**：是否建立了安全监控和日志系统
- [ ] **应急响应**：是否有完善的安全事件响应流程

**应急响应工具：**

```javascript
// 紧急安全响应
function emergencySecurityResponse() {
  // 1. 立即清除敏感数据
  localStorage.clear();
  sessionStorage.clear();

  // 2. 重定向到安全页面
  window.location.href = "/security-warning";

  // 3. 记录安全事件
  logSecurityEvent("EMERGENCY_RESPONSE", {
    action: "data_cleared",
    timestamp: Date.now(),
  });
}
```

---

## 📋 总结

前端安全是一个系统性工程，需要从多个维度进行防护：

### **核心安全原则**

1. **输入验证** - 永远不要信任用户输入
2. **输出编码** - 所有输出都要正确编码
3. **最小权限** - 只给予必要的权限
4. **深度防御** - 多层防护机制
5. **持续监控** - 建立安全监控体系

### **实施建议**

- **开发阶段**：使用安全工具和最佳实践
- **测试阶段**：进行全面的安全测试
- **部署阶段**：配置安全头和防护措施
- **运维阶段**：持续监控和应急响应

### **关键工具推荐**

- **开发工具**：ESLint Security、Semgrep
- **测试工具**：Snyk、npm audit、OWASP ZAP
- **监控工具**：Sentry、Bugsnag
- **防护库**：DOMPurify、helmet、crypto-js

记住：**安全不是一次性的工作，而是持续的过程**。只有建立完善的安全体系，才能有效保护前端应用和用户数据。
