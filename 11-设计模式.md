# 设计模式

## 单例模式

单例模式（Singleton Pattern）。顾名思义，单例模式中Class的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。

- 使用 IIFE创建局部作用域并即时执行

- 隐藏Class的构造函数，避免多次实例化

- 通过暴露一个 getInstance() 方法来创建/获取唯一实例

  > `getInstance() `为一个 闭包 ，使用闭包保存局部作用域中的单例对象并返回。

```js
// 单例构造器
const SingleFn = (function () {
    // 隐藏的Class的构造函数
    function Demo() {}
  
    // 未初始化的单例对象
    let instance;
  
    return {
      // 创建/获取单例对象的函数
      getInstance: function () {
        if (!instance) {
            instance = new Demo();
        }
        return instance;
      }
    }
  })();
```

我们可以验证下单例对象是否创建成功：

```js
  const singleFn1 = SingleFn.getInstance();
  const singleFn2 = SingleFn.getInstance();
  
  console.log(singleFn1 === singleFn2); // true
```

**场景例子**

- 定义命名空间和实现分支型方法
- 登录框
- vuex 和 redux中的store

**优点**

- 划分命名空间，减少全局变量
- 增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护
- 只会实例化一次。简化了代码的调试和维护

**缺点**

- 由于单例模式提供的是一种单点访问，所以它有可能导致模块间的**强耦合**

- **不利于单元测试**。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一

  个单元一起测试。

## 发布订阅模式

发布-订阅模式其实是一**种对象间一对多的依赖关系**，对象状态改变后，通知给所有关心这个状态的订阅者。发布订阅模式有订阅的动作，可以不和观察者直接产生联系，只要能订阅上关心的状态即可，通常可用第三媒介来做，而发布者也会利用第三媒介来通知订阅者。

**订阅者把自己想要订阅的事件注册到调度中心，当发布者发布事件到调度中心（就是该事件被触发），再由调度中心统一调度订阅者注册到调度中心的处理代码。**

原生事件API。（也就是鼠标点击/移动/进入等事件,就是使用了发布订阅模式)

```js
const handleClick = (event: ClickEvent) => {
	console.log(event)
  alert(2);
}
// 订阅
document.body.addEventListener('click', handleClick);
// 发布
document.body.click();
// 移除订阅者`handleClick`，之后handleClick将不再订阅其消息
document.body.removeEventListener('click', handleClick)

// 发布者是document.body；订阅者是自己
```

**为什么要用发布订阅模式**

在没有`Promise`之前，我们使用异步API的时候经常会使用回调，但是如果有几个互相依赖的异步API调用，回调层级太多可能就会陷入“回调地狱”。下面代码演示了假如我们有三个网络请求，第二个必须等第一个结束才能发出，第三个必须等第二个结束才能发起，如果我们使用回调就会变成这样：

```js
const request = require("request");

request('https://www.baidu.com', function (error, response) {
  if (!error && response.statusCode == 200) {
    console.log('get times 1');

    request('https://www.baidu.com', function(error, response) {
      if (!error && response.statusCode == 200) {
        console.log('get times 2');

        request('https://www.baidu.com', function(error, response) {
          if (!error && response.statusCode == 200) {
            console.log('get times 3');
          }
        })
      }
    })
  }
});
```

**如何实现发布-订阅模式？**

+ 创建一个对象
+ 在该对象上创建一个缓存列表（调度中心）
+ **on** 方法用来把函数 fn 都加到缓存列表中（订阅者注册事件到调度中心）
+ **emit** 方法取到 arguments 里第一个当做 event，根据 event 值去执行对应缓存列表中的函数（发布者发布事件到调度中心，调度中心处理代码）
+ **off** 方法可以根据 event 值取消订阅（取消订阅）
+ **once** 方法只监听一次，调用完毕后删除缓存函数（订阅一次）

```js
class EventEmitter {
    constructor() {
        // 一个对象存放所有的消息订阅
        // 每个消息对应一个数组，数组结构如下
        // {
        //   "event1": [cb1, cb2]
        // }
        this.message = {}; 
    }

    // 订阅 subscribe
    on(type, callback) {
        if(this.message[type]) {
          this.message[type].push(callback);
        } else {
          this.message[type] = [callback];
        }
    }

    // 发布 publish
    emit(type, ...payload) {
        if (Array.isArray(this.message[type])) {
            this.message[type].forEach((cb) => cb.apply(this, payload));
        }
    }

    // 单次订阅
    once(type, callback) {
        const proxyCallback = (...payload) => {
            callback.apply(this, payload);
            // 回调函数执行完成之后就取消订阅当前事件
            this.off(type, proxyCallback);
        };

        this.on(type, proxyCallback);
    }

    // 删除订阅 unsubscribe
    off(type, callback) {
        if (typeof type === "string" && !!type) {
            if (typeof callback === "function") {
                // 删除指定事件的回调
                this.message[type] = this.message[type].filter(cb => cb !== callback);
            } else {
                // 删除整个事件
                delete this.message[type];
            }
        }
    }
}
```

**解决回调地狱**

只需要让**前面的成功后发布消息，后面的订阅前面的成功消息**就行了。

```js
const request = require("request");
const pubSub = new PubSub();

request('https://www.baidu.com', function (error, response) {
  if (!error && response.statusCode == 200) {
    console.log('get times 1');
    // 发布请求1成功消息
    pubSub.emit('request1Success');
  }
});

// 订阅请求1成功的消息，然后发起请求2
pubSub.on('request1Success', () => {
  request('https://www.baidu.com', function (error, response) {
    if (!error && response.statusCode == 200) {
      console.log('get times 2');
      // 发布请求2成功消息
      pubSub.emit('request2Success');
    }
  });
})

// 订阅请求2成功的消息，然后发起请求3
pubSub.on('request2Success', () => {
  request('https://www.baidu.com', function (error, response) {
    if (!error && response.statusCode == 200) {
      console.log('get times 3');
      // 发布请求3成功消息
      pubSub.emit('request3Success');
    }
  });
})
```

发布订阅模式有以下特点：

1. 解决了“回调地狱”
2. 将多个模块进行了解耦，自己执行时，不需要知道另一个模块的存在，只需要关心发布出来的事件就行
3. 因为多个模块可以不知道对方的存在，自己关心的事件可能是一个很遥远的旮旯发布出来的，也不能通过代码跳转直接找到发布事件的地方，debug的时候可能会有点困难。

**优点**

- 对象之间解耦
- 异步编程中，可以更松耦合的代码编写

**缺点**

- 创建订阅者本身要消耗一定的时间和内存
- 虽然可以弱化对象之间的联系，多个发布者和订阅者嵌套一起的时候，程序难以跟踪维护

场景

### DOM事件

### Vue父子组件通信 on/emit

## 观察者模式

观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。

**一个对象（观察者）订阅另一个对象（主题），当主题被激活的时候，触发观察者里面的事件。**

**观察者模式的主要角色如下**

1. 抽象主题（Subject）：即：被观察者。也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。
2. 抽象观察者（Observer）：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。
3. 具体主题（Concrete Subject）：即：具体被观察者。也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。
4. 具体观察者（Concrete Observer）：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。

主题提供维护观察者的一系列方法，观察者提供更新接口。观察者把自己注册到主题里，在主题发生变化时候，调度观察者的更新方法。

```js
// 主题（被观察者） 发布者
class Subject {
    constructor() {
        this.state = 0
        // 观察者列表
        this.observers = []
    }
    // 获取状态值
    getState() {
        return this.state
    }
    // 设置状态值
    setState(state) {
        this.state = state
        // 当自身状态改变时，通知所有观察者
        this.notify()
    }
    // 添加观察者
    add(observer) {
        this.observers.push(observer)
    }
    // 删除观察者
    remove(observer) {
        this.observers = this.observers?.filter(o => observer !== o)
    }
    //  通知所有观察者（调度观察者的更新方法）
    notify() {
        for (let observer of this.observers) {
            observer.update()
        }
    }
}

// 观察者类 订阅
class Observer {
    constructor(name) {
        this.name = name
    }
    // 观察目标更新时
    update() {
        console.log(`${this.name}观察到目标主题状态发生了改变`)
    }
}

// 主题（被观察者）
let subject = new Subject()

// 观察者
let obs1 = new Observer('观察者1')
let obs2 = new Observer('观察者2')

// 观察者把自己注册到主题里
subject.add(obs1)
subject.add(obs2)

// 主题发生变化时候，内部会通知观察者，调度观察者的更新方法。
subject.setState(1) // 观察者1观察到目标主题状态发生了改变;观察者2观察到目标主题状态发生了改变
subject.remove(obs2)
subject.setState(1) // 观察者1观察到目标主题状态发生了改变
```

**优点:** 观察者与被观察者之间是属于轻度的关联关系，并且是抽象耦合的，这样，对于两者来说都比较容易进行扩展。

**缺点:** 观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察者的方法进行处理。由于是链式触发，当观察者比较多的时候，性能问题是比较令人担忧的。并且，在链式结构中，比较容易出现循环引用的错误，造成系统假死。

**简单版响应式**

```html
<!DOCTYPE html>
<html lang="en">
<body>
    <h2>观察者模式</h2>
    <div id="id1"></div>
    <div id="id2"></div>
    <script>
      function observer(key, _value) {
        let obj = {}
        let listers = []
        function notify() { listers.forEach(fn => fn(_value)) }
        function addLister(fn) { listers.push(fn) }
        Object.defineProperty(obj, key, {
          get() {
            return _value
          },
          set(newVal) {
            if (newVal !== _value) {
              _value = newVal
              notify()
            }
          }
        })
        return { obj, addLister }
      }

      const { obj, addLister } = observer('age', 10)
      addLister(val => { document.getElementById('id1').innerHTML = 'listener1  ' + val })
      addLister(val => { document.getElementById('id2').innerHTML = 'listener2  ' + 2 * val })

      // age改变了，页面渲染跟着改变
      setInterval(() => {
        obj.age += 10
      }, 1000);

 		</script>
</body>
</html>
```

### Vue 双向绑定

## 观察者和发布订阅的关系

在【**观察者模式**】中，观察者需要直接订阅目标事件；在目标发出内容改变的事件后，直接接收事件并作出响应。

```vbnet
 ╭─────────────╮  Fire Event  ╭──────────────╮
 │             │─────────────>│              │
 │   Subject   │              │   Observer   │
 │             │<─────────────│              │
 ╰─────────────╯  Subscribe   ╰──────────────╯
```

在【**发布订阅模式**】中，发布者和订阅者之间多了一个发布通道，一方面从发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件。

以此避免发布者和订阅者之间产生依赖关系，从而达到完全解耦。

```vbnet
 ╭─────────────╮                 ╭───────────────╮   Fire Event   ╭──────────────╮
 │             │  Publish Event  │               │───────────────>│              │
 │  Publisher  │────────────────>│ Event Channel │                │  Subscriber  │
 │             │                 │               │<───────────────│              │
 ╰─────────────╯                 ╰───────────────╯    Subscribe   ╰──────────────╯
```

两种模式都存在订阅者和发布者（具体目标可认为是发布者、具体观察者可认为是订阅者）

发布者直接触及到订阅者的操作，叫观察者模式。发布者不直接触及到订阅者、而是由统一的第三方来完成实际的通信的操作，叫做发布-订阅模式。

**总结**

1. 角色数量

   > 观察者模式里，只有两个角色：观察者 和 被观察者
   >
   > 发布订阅模式里，却不仅仅只有发布者和订阅者两个角色，还有一个调度中心

2. 调度方式

   > 观察者模式是由具体目标调度的
   >
   > 发布/订阅模式是统一由调度中心调度的。

3. 依赖关系

   > 观察者模式中的观察者和被观察者，是松耦合的关系;
   >
   > 发布/订阅模式中的发布者和订阅者，则完全不存在耦合

4. 使用场景

   > 观察者模式，多用于单个应用内部
   >
   > 发布订阅模式，则更多的是一种跨应用的模式，比如我们常用的消息中间件





