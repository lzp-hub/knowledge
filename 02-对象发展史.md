# 对象发展史

## 📚 目录

- [ES1 时代（1997 年）](#es1-时代1997年)
- [ES3 时代（1999 年）](#es3-时代1999年)
- [ES5 时代（2009 年）](#es5-时代2009年)
- [ES2015/ES6 时代（2015 年）](#es2015es6-时代2015年)
- [ES2017 时代（2017 年）](#es2017-时代2017年)
- [ES2018 时代（2018 年）](#es2018-时代2018年)
- [ES2019 时代（2019 年）](#es2019-时代2019年)
- [ES2022 时代（2022 年）](#es2022-时代2022年)
- [实际应用场景](#实际应用场景)
- [性能对比与最佳实践](#性能对比与最佳实践)
- [面试常考算法](#面试常考算法)

---

## ES1 时代（1997 年）

### 📝 ES1 对象基础总览

| 功能分类 | 特性       | 语法                   | 参数   | 返回值 | 用途     |
| -------- | ---------- | ---------------------- | ------ | ------ | -------- |
| **创建** | 对象字面量 | `{}`                   | 无     | 对象   | 创建对象 |
| **访问** | 点语法     | `obj.property`         | 属性名 | 属性值 | 访问属性 |
| **访问** | 方括号语法 | `obj['property']`      | 属性名 | 属性值 | 动态访问 |
| **修改** | 属性赋值   | `obj.property = value` | 属性值 | 属性值 | 设置属性 |
| **删除** | delete     | `delete obj.property`  | 属性名 | 布尔值 | 删除属性 |

### 🔧 ES1 详细方法说明

**对象字面量 - 创建对象**

```javascript
// 语法：{ key: value }
// 参数：键值对
// 返回值：对象

const person = {
  name: "张三",
  age: 25,
  city: "北京",
};

console.log(person.name); // "张三"
console.log(person["age"]); // 25

// 实际应用：配置对象
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3,
};
```

**属性访问 - 动态访问**

```javascript
// 语法：obj[propertyName]
// 参数：属性名
// 返回值：属性值

const obj = {
  name: "张三",
  age: 25,
};

const propertyName = "name";
console.log(obj[propertyName]); // "张三"

// 实际应用：动态属性访问
function getProperty(obj, prop) {
  return obj[prop];
}
```

---

## ES3 时代（1999 年）

> **🎯 解决的问题**：ES3 引入了 Object 原型方法，提供了对象操作的基础能力，让对象处理更加便捷。

### 📝 ES3 对象方法总览

| 功能分类 | 方法           | 语法                       | 参数   | 返回值 | 用途         |
| -------- | -------------- | -------------------------- | ------ | ------ | ------------ |
| **检查** | hasOwnProperty | `obj.hasOwnProperty(prop)` | 属性名 | 布尔值 | 检查自有属性 |
| **检查** | isPrototypeOf  | `obj.isPrototypeOf(other)` | 对象   | 布尔值 | 检查原型关系 |
| **转换** | toString()     | `obj.toString()`           | 无     | 字符串 | 转字符串     |
| **转换** | valueOf()      | `obj.valueOf()`            | 无     | 原始值 | 转原始值     |

### 🔧 ES3 详细方法说明

**hasOwnProperty() - 检查自有属性**

> **🎯 解决的问题**：解决了区分自有属性和继承属性的问题，让属性检查更加准确。

```javascript
// 语法：obj.hasOwnProperty(property)
// 参数：属性名
// 返回值：布尔值

const obj = {
  name: "张三",
  age: 25,
};

console.log(obj.hasOwnProperty("name")); // true
console.log(obj.hasOwnProperty("toString")); // false (继承属性)

// 实际应用：对象遍历
function getOwnProperties(obj) {
  const ownProps = [];
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      ownProps.push(key);
    }
  }
  return ownProps;
}
```

**toString() - 对象转字符串**

```javascript
// 语法：obj.toString()
// 参数：无
// 返回值：字符串

const obj = {
  name: "张三",
  age: 25,
  toString() {
    return `${this.name} (${this.age})`;
  },
};

console.log(obj.toString()); // "张三 (25)"

// 实际应用：自定义字符串表示
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  toString() {
    return `Person(${this.name}, ${this.age})`;
  }
}
```

---

## ES5 时代（2009 年）

> **🎯 解决的问题**：ES5 引入了对象属性描述符和静态方法，解决了对象属性控制和操作的问题，让对象处理更加精细。

### 📝 ES5 对象方法总览

| 功能分类 | 方法                     | 语法                                         | 参数             | 返回值 | 用途           |
| -------- | ------------------------ | -------------------------------------------- | ---------------- | ------ | -------------- |
| **控制** | defineProperty           | `Object.defineProperty(obj, prop, desc)`     | 对象,属性,描述符 | 对象   | 定义属性       |
| **控制** | defineProperties         | `Object.defineProperties(obj, props)`        | 对象,属性描述符  | 对象   | 批量定义属性   |
| **获取** | getOwnPropertyDescriptor | `Object.getOwnPropertyDescriptor(obj, prop)` | 对象,属性        | 描述符 | 获取属性描述符 |
| **获取** | getOwnPropertyNames      | `Object.getOwnPropertyNames(obj)`            | 对象             | 数组   | 获取所有属性名 |
| **获取** | keys                     | `Object.keys(obj)`                           | 对象             | 数组   | 获取可枚举属性 |
| **获取** | getPrototypeOf           | `Object.getPrototypeOf(obj)`                 | 对象             | 对象   | 获取原型       |
| **设置** | setPrototypeOf           | `Object.setPrototypeOf(obj, proto)`          | 对象,原型        | 对象   | 设置原型       |
| **创建** | create                   | `Object.create(proto)`                       | 原型             | 对象   | 创建对象       |
| **冻结** | freeze                   | `Object.freeze(obj)`                         | 对象             | 对象   | 冻结对象       |
| **密封** | seal                     | `Object.seal(obj)`                           | 对象             | 对象   | 密封对象       |
| **扩展** | preventExtensions        | `Object.preventExtensions(obj)`              | 对象             | 对象   | 禁止扩展       |

### 🔧 ES5 详细方法说明

**Object.defineProperty() - 定义属性**

> **🎯 解决的问题**：解决了对象属性控制的问题，让属性可以设置为只读、不可枚举、不可配置等。

```javascript
// 语法：Object.defineProperty(obj, prop, descriptor)
// 参数：对象, 属性名, 描述符
// 返回值：对象

const obj = {};

Object.defineProperty(obj, "name", {
  value: "张三",
  writable: false, // 不可写
  enumerable: true, // 可枚举
  configurable: false, // 不可配置
});

console.log(obj.name); // "张三"
obj.name = "李四"; // 无效，严格模式下会报错

// 实际应用：创建只读属性
function createReadOnlyObject(data) {
  const obj = {};
  Object.keys(data).forEach((key) => {
    Object.defineProperty(obj, key, {
      value: data[key],
      writable: false,
      enumerable: true,
      configurable: false,
    });
  });
  return obj;
}
```

**Object.keys() - 获取可枚举属性**

```javascript
// 语法：Object.keys(obj)
// 参数：对象
// 返回值：属性名数组

const obj = {
  name: "张三",
  age: 25,
  city: "北京",
};

console.log(Object.keys(obj)); // ["name", "age", "city"]

// 实际应用：对象遍历
function processObject(obj) {
  return Object.keys(obj).map((key) => ({
    key,
    value: obj[key],
    type: typeof obj[key],
  }));
}
```

**Object.create() - 创建对象**

```javascript
// 语法：Object.create(proto, propertiesObject)
// 参数：原型对象, 属性描述符
// 返回值：新对象

const personProto = {
  greet() {
    return `Hello, I'm ${this.name}`;
  },
};

const person = Object.create(personProto, {
  name: {
    value: "张三",
    writable: true,
    enumerable: true,
  },
  age: {
    value: 25,
    writable: true,
    enumerable: true,
  },
});

console.log(person.greet()); // "Hello, I'm 张三"

// 实际应用：继承
function createUser(name, age) {
  const user = Object.create(userProto);
  user.name = name;
  user.age = age;
  return user;
}
```

---

## ES2015/ES6 时代（2015 年）

> **🎯 解决的问题**：ES6 引入了对象解构、属性简写、方法简写等特性，解决了对象操作繁琐的问题，让对象处理更加简洁。

### 📝 ES6 对象特性总览

| 功能分类 | 特性                  | 语法                                | 参数            | 返回值 | 用途       |
| -------- | --------------------- | ----------------------------------- | --------------- | ------ | ---------- |
| **解构** | 对象解构              | `const {a, b} = obj`                | 对象            | 变量   | 解构赋值   |
| **解构** | 嵌套解构              | `const {a: {b}} = obj`              | 对象            | 变量   | 嵌套解构   |
| **解构** | 默认值                | `const {a = 1} = obj`               | 对象            | 变量   | 解构默认值 |
| **解构** | 剩余属性              | `const {a, ...rest} = obj`          | 对象            | 变量   | 剩余属性   |
| **简写** | 属性简写              | `{name}`                            | 变量            | 对象   | 属性简写   |
| **简写** | 方法简写              | `{method() {}}`                     | 无              | 对象   | 方法简写   |
| **计算** | 计算属性名            | `{[key]: value}`                    | 表达式          | 对象   | 动态属性名 |
| **合并** | Object.assign         | `Object.assign(target, ...sources)` | 目标对象,源对象 | 对象   | 对象合并   |
| **设置** | Object.setPrototypeOf | `Object.setPrototypeOf(obj, proto)` | 对象,原型       | 对象   | 设置原型   |

### 🔧 ES6 详细方法说明

**对象解构 - 解构赋值**

> **🎯 解决的问题**：解决了对象属性访问繁琐的问题，让对象属性提取更加简洁。

```javascript
// 语法：const {property1, property2} = object
// 参数：对象
// 返回值：变量

const person = {
  name: "张三",
  age: 25,
  city: "北京",
};

// 基础解构
const { name, age } = person;
console.log(name, age); // "张三" 25

// 重命名
const { name: personName, age: personAge } = person;
console.log(personName, personAge); // "张三" 25

// 默认值
const { name, age, country = "中国" } = person;
console.log(country); // "中国"

// 实际应用：函数参数
function greetUser({ name, age, city = "未知" }) {
  return `你好，${name}，${age}岁，来自${city}`;
}
```

**属性简写 - 简洁对象**

> **🎯 解决的问题**：解决了对象属性定义繁琐的问题，让对象创建更加简洁。

```javascript
// 语法：{property} 等价于 {property: property}
// 参数：变量
// 返回值：对象

const name = "张三";
const age = 25;

// 传统写法
const person1 = {
  name: name,
  age: age,
};

// 简写
const person2 = { name, age };

// 方法简写
const person3 = {
  name,
  age,
  greet() {
    return `Hello, I'm ${this.name}`;
  },
};

// 实际应用：API响应处理
function createUserResponse(user) {
  const { id, name, email } = user;
  return {
    id,
    name,
    email,
    timestamp: Date.now(),
  };
}
```

**Object.assign() - 对象合并**

> **🎯 解决的问题**：解决了对象浅拷贝和合并的问题，让对象操作更加便捷。

```javascript
// 语法：Object.assign(target, ...sources)
// 参数：目标对象, 源对象列表
// 返回值：目标对象

const target = { a: 1, b: 2 };
const source1 = { b: 3, c: 4 };
const source2 = { c: 5, d: 6 };

const result = Object.assign(target, source1, source2);
console.log(result); // {a: 1, b: 3, c: 5, d: 6}
console.log(target); // {a: 1, b: 3, c: 5, d: 6} (被修改)

// 实际应用：对象合并
function mergeConfig(defaultConfig, userConfig) {
  return Object.assign({}, defaultConfig, userConfig);
}

// 实际应用：对象克隆
function shallowClone(obj) {
  return Object.assign({}, obj);
}
```

---

## ES2017 时代（2017 年）

> **🎯 解决的问题**：ES2017 引入了 Object.entries() 和 Object.values()，解决了对象遍历和转换的问题，让对象操作更加统一。

### 📝 ES2017 对象方法总览

| 功能分类 | 方法           | 语法                  | 参数 | 返回值 | 用途       |
| -------- | -------------- | --------------------- | ---- | ------ | ---------- |
| **遍历** | Object.entries | `Object.entries(obj)` | 对象 | 数组   | 获取键值对 |
| **遍历** | Object.values  | `Object.values(obj)`  | 对象 | 数组   | 获取值数组 |

### 🔧 ES2017 详细方法说明

**Object.entries() - 获取键值对**

> **🎯 解决的问题**：解决了对象遍历的问题，让对象操作更加统一，配合数组方法使用。

```javascript
// 语法：Object.entries(obj)
// 参数：对象
// 返回值：键值对数组

const person = {
  name: "张三",
  age: 25,
  city: "北京",
};

console.log(Object.entries(person));
// [["name", "张三"], ["age", 25], ["city", "北京"]]

// 实际应用：对象遍历
Object.entries(person).forEach(([key, value]) => {
  console.log(`${key}: ${value}`);
});

// 实际应用：对象过滤
function filterObject(obj, predicate) {
  return Object.fromEntries(
    Object.entries(obj).filter(([key, value]) => predicate(key, value))
  );
}
```

**Object.values() - 获取值数组**

```javascript
// 语法：Object.values(obj)
// 参数：对象
// 返回值：值数组

const person = {
  name: "张三",
  age: 25,
  city: "北京",
};

console.log(Object.values(person)); // ["张三", 25, "北京"]

// 实际应用：值统计
function getObjectStats(obj) {
  const values = Object.values(obj);
  return {
    count: values.length,
    types: [...new Set(values.map((v) => typeof v))],
    hasNumbers: values.some((v) => typeof v === "number"),
  };
}
```

---

## ES2018 时代（2018 年）

> **🎯 解决的问题**：ES2018 引入了 Object.getOwnPropertyDescriptors()，解决了对象属性描述符获取的问题，让对象操作更加精细。

### 📝 ES2018 对象方法总览

| 功能分类 | 方法                      | 语法                                    | 参数 | 返回值 | 用途               |
| -------- | ------------------------- | --------------------------------------- | ---- | ------ | ------------------ |
| **获取** | getOwnPropertyDescriptors | `Object.getOwnPropertyDescriptors(obj)` | 对象 | 对象   | 获取所有属性描述符 |

### 🔧 ES2018 详细方法说明

**Object.getOwnPropertyDescriptors() - 获取所有属性描述符**

> **🎯 解决的问题**：解决了批量获取对象属性描述符的问题，让对象操作更加精细。

```javascript
// 语法：Object.getOwnPropertyDescriptors(obj)
// 参数：对象
// 返回值：属性描述符对象

const obj = {};
Object.defineProperty(obj, "name", {
  value: "张三",
  writable: false,
  enumerable: true,
  configurable: false,
});

console.log(Object.getOwnPropertyDescriptors(obj));
// {
//   name: {
//     value: '张三',
//     writable: false,
//     enumerable: true,
//     configurable: false
//   }
// }

// 实际应用：对象克隆（包括属性描述符）
function cloneObject(obj) {
  return Object.create(
    Object.getPrototypeOf(obj),
    Object.getOwnPropertyDescriptors(obj)
  );
}
```

---

## ES2019 时代（2019 年）

> **🎯 解决的问题**：ES2019 引入了 Object.fromEntries()，解决了数组转对象的问题，让对象操作更加便捷。

### 📝 ES2019 对象方法总览

| 功能分类 | 方法        | 语法                          | 参数       | 返回值 | 用途       |
| -------- | ----------- | ----------------------------- | ---------- | ------ | ---------- |
| **转换** | fromEntries | `Object.fromEntries(entries)` | 键值对数组 | 对象   | 数组转对象 |

### 🔧 ES2019 详细方法说明

**Object.fromEntries() - 数组转对象**

> **🎯 解决的问题**：解决了数组转对象的问题，让对象操作更加便捷，与 Object.entries() 形成完美配对。

```javascript
// 语法：Object.fromEntries(entries)
// 参数：键值对数组
// 返回值：对象

const entries = [
  ["name", "张三"],
  ["age", 25],
  ["city", "北京"],
];

const obj = Object.fromEntries(entries);
console.log(obj); // {name: "张三", age: 25, city: "北京"}

// 实际应用：Map转对象
const map = new Map([
  ["name", "张三"],
  ["age", 25],
]);
const objFromMap = Object.fromEntries(map);

// 实际应用：对象转换
function transformObject(obj, transformer) {
  return Object.fromEntries(
    Object.entries(obj).map(([key, value]) => transformer(key, value))
  );
}
```

---

## ES2022 时代（2022 年）

> **🎯 解决的问题**：ES2022 引入了 Object.hasOwn()，解决了 hasOwnProperty() 的问题，让属性检查更加可靠。

### 📝 ES2022 对象方法总览

| 功能分类 | 方法   | 语法                       | 参数      | 返回值 | 用途         |
| -------- | ------ | -------------------------- | --------- | ------ | ------------ |
| **检查** | hasOwn | `Object.hasOwn(obj, prop)` | 对象,属性 | 布尔值 | 检查自有属性 |

### 🔧 ES2022 详细方法说明

**Object.hasOwn() - 检查自有属性**

> **🎯 解决的问题**：解决了 hasOwnProperty() 可能被覆盖的问题，让属性检查更加可靠。

```javascript
// 语法：Object.hasOwn(obj, prop)
// 参数：对象, 属性名
// 返回值：布尔值

const obj = {
  name: "张三",
  age: 25,
};

console.log(Object.hasOwn(obj, "name")); // true
console.log(Object.hasOwn(obj, "toString")); // false

// 对比 hasOwnProperty
const objWithOverridden = {
  hasOwnProperty: "not a function",
};

// 会报错
// objWithOverridden.hasOwnProperty("name");

// 安全使用
console.log(Object.hasOwn(objWithOverridden, "name")); // false

// 实际应用：安全的属性检查
function safeHasProperty(obj, prop) {
  return Object.hasOwn(obj, prop);
}
```

---

## 实际应用场景

### 1. 对象合并和克隆场景

**深度合并对象**

```javascript
// 浅合并
function shallowMerge(target, ...sources) {
  return Object.assign({}, target, ...sources);
}

// 深合并
function deepMerge(target, ...sources) {
  if (!sources.length) return target;
  const source = sources.shift();

  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, { [key]: {} });
        deepMerge(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }

  return deepMerge(target, ...sources);
}

function isObject(item) {
  return item && typeof item === "object" && !Array.isArray(item);
}

// 实际应用：配置合并
const defaultConfig = {
  api: {
    baseUrl: "https://api.example.com",
    timeout: 5000,
  },
  ui: {
    theme: "light",
    language: "zh-CN",
  },
};

const userConfig = {
  api: {
    timeout: 10000,
  },
  ui: {
    theme: "dark",
  },
};

const finalConfig = deepMerge(defaultConfig, userConfig);
```

### 2. 对象转换场景

**对象格式转换**

```javascript
// 对象转数组
function objectToArray(obj) {
  return Object.entries(obj).map(([key, value]) => ({
    key,
    value,
    type: typeof value,
  }));
}

// 数组转对象
function arrayToObject(arr, keyField, valueField) {
  return Object.fromEntries(
    arr.map((item) => [item[keyField], item[valueField]])
  );
}

// 实际应用：数据转换
const users = [
  { id: 1, name: "张三", age: 25 },
  { id: 2, name: "李四", age: 30 },
];

const userMap = arrayToObject(users, "id", "name");
console.log(userMap); // {1: '张三', 2: '李四'}
```

### 3. 对象验证场景

**对象属性验证**

```javascript
function validateObject(obj, schema) {
  const errors = [];

  for (const [key, rules] of Object.entries(schema)) {
    const value = obj[key];

    if (rules.required && (value === undefined || value === null)) {
      errors.push(`${key} is required`);
      continue;
    }

    if (value !== undefined && rules.type && typeof value !== rules.type) {
      errors.push(`${key} must be of type ${rules.type}`);
    }

    if (value !== undefined && rules.min && value < rules.min) {
      errors.push(`${key} must be at least ${rules.min}`);
    }

    if (value !== undefined && rules.max && value > rules.max) {
      errors.push(`${key} must be at most ${rules.max}`);
    }
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}

// 实际应用：表单验证
const userSchema = {
  name: { required: true, type: "string" },
  age: { required: true, type: "number", min: 0, max: 150 },
  email: { required: true, type: "string" },
};

const user = { name: "张三", age: 25, email: "zhangsan@example.com" };
const validation = validateObject(user, userSchema);
```

---

## 性能对比与最佳实践

### 1. 对象创建性能对比

```javascript
// 性能测试
function performanceTest() {
  const iterations = 1000000;

  // 对象字面量
  console.time("对象字面量");
  for (let i = 0; i < iterations; i++) {
    const obj = { a: 1, b: 2, c: 3 };
  }
  console.timeEnd("对象字面量");

  // Object.create
  console.time("Object.create");
  for (let i = 0; i < iterations; i++) {
    const obj = Object.create(null);
    obj.a = 1;
    obj.b = 2;
    obj.c = 3;
  }
  console.timeEnd("Object.create");

  // Object.assign
  console.time("Object.assign");
  for (let i = 0; i < iterations; i++) {
    const obj = Object.assign({}, { a: 1, b: 2, c: 3 });
  }
  console.timeEnd("Object.assign");
}

// 典型结果：对象字面量 > Object.assign > Object.create
```

### 2. 最佳实践建议

**对象操作最佳实践：**

```javascript
// ✅ 推荐：使用对象解构
const { name, age } = user;

// ✅ 推荐：使用属性简写
const user = { name, age };

// ✅ 推荐：使用 Object.hasOwn() 而不是 hasOwnProperty()
if (Object.hasOwn(obj, "property")) {
  // 处理逻辑
}

// ✅ 推荐：使用 Object.entries() 进行对象遍历
Object.entries(obj).forEach(([key, value]) => {
  console.log(key, value);
});

// ✅ 推荐：使用 Object.fromEntries() 进行对象转换
const newObj = Object.fromEntries(
  Object.entries(obj).map(([key, value]) => [key, value * 2])
);

// ❌ 避免：直接修改原对象
// 不好的做法
function badMerge(target, source) {
  Object.assign(target, source);
  return target;
}

// ✅ 好的做法
function goodMerge(target, source) {
  return Object.assign({}, target, source);
}
```

---

## 面试常考算法

### 1. 深拷贝实现

```javascript
// 方法1：JSON方法（有限制）
function deepClone1(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// 方法2：递归实现
function deepClone2(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }

  if (obj instanceof Array) {
    return obj.map((item) => deepClone2(item));
  }

  if (typeof obj === "object") {
    const cloned = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        cloned[key] = deepClone2(obj[key]);
      }
    }
    return cloned;
  }
}

// 方法3：使用 Map 处理循环引用
function deepClone3(obj, map = new Map()) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  if (map.has(obj)) {
    return map.get(obj);
  }

  const cloned = Array.isArray(obj) ? [] : {};
  map.set(obj, cloned);

  for (const key in obj) {
    if (Object.hasOwn(obj, key)) {
      cloned[key] = deepClone3(obj[key], map);
    }
  }

  return cloned;
}
```

### 2. 对象比较

```javascript
function deepEqual(obj1, obj2) {
  if (obj1 === obj2) return true;

  if (obj1 == null || obj2 == null) return false;

  if (typeof obj1 !== typeof obj2) return false;

  if (typeof obj1 !== "object") return obj1 === obj2;

  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);

  if (keys1.length !== keys2.length) return false;

  for (const key of keys1) {
    if (!keys2.includes(key)) return false;
    if (!deepEqual(obj1[key], obj2[key])) return false;
  }

  return true;
}

// 测试
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { a: 1, b: { c: 2 } };
const obj3 = { a: 1, b: { c: 3 } };

console.log(deepEqual(obj1, obj2)); // true
console.log(deepEqual(obj1, obj3)); // false
```

### 3. 对象扁平化

```javascript
function flattenObject(obj, prefix = "") {
  const flattened = {};

  for (const key in obj) {
    if (Object.hasOwn(obj, key)) {
      const newKey = prefix ? `${prefix}.${key}` : key;

      if (
        typeof obj[key] === "object" &&
        obj[key] !== null &&
        !Array.isArray(obj[key])
      ) {
        Object.assign(flattened, flattenObject(obj[key], newKey));
      } else {
        flattened[newKey] = obj[key];
      }
    }
  }

  return flattened;
}

// 测试
const nested = {
  user: {
    name: "张三",
    address: {
      city: "北京",
      district: "朝阳区",
    },
  },
  age: 25,
};

console.log(flattenObject(nested));
// {user.name: '张三', user.address.city: '北京', user.address.district: '朝阳区', age: 25}
```

### 4. 对象去重

```javascript
function uniqueObjects(arr, key) {
  const seen = new Set();
  return arr.filter((obj) => {
    const value = obj[key];
    if (seen.has(value)) {
      return false;
    }
    seen.add(value);
    return true;
  });
}

// 测试
const users = [
  { id: 1, name: "张三" },
  { id: 2, name: "李四" },
  { id: 1, name: "张三" },
  { id: 3, name: "王五" },
];

console.log(uniqueObjects(users, "id"));
// [{id: 1, name: '张三'}, {id: 2, name: '李四'}, {id: 3, name: '王五'}]
```

---

## 📋 总结

### 记忆技巧

1. **分类记忆**：按功能分类（创建、访问、修改、检查、转换）
2. **对比记忆**：新旧方法的区别
3. **配对记忆**：Object.entries() 和 Object.fromEntries()
4. **安全记忆**：使用 Object.hasOwn() 而不是 hasOwnProperty()
5. **现代记忆**：优先使用 ES6+ 方法

### 使用建议

1. **优先使用 ES6+方法**：更简洁、更安全
2. **注意深浅拷贝**：选择合适的拷贝方式
3. **使用解构赋值**：简化对象操作
4. **注意性能差异**：选择合适的方法
5. **处理循环引用**：使用 Map 或 WeakMap
