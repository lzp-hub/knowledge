# 类型系统与类型检查

## 📚 目录

- [JavaScript 动态类型](#javascript动态类型)
- [TypeScript 静态类型](#typescript静态类型)
- [类型推断](#类型推断)
- [类型守卫](#类型守卫)
- [泛型](#泛型)
- [接口与类型别名](#接口与类型别名)
- [联合类型与交叉类型](#联合类型与交叉类型)
- [工具类型](#工具类型)
- [实际应用场景](#实际应用场景)
- [面试常考问题](#面试常考问题)

---

## JavaScript 动态类型

### 📝 动态类型特点

| 特性           | 说明           | 示例                     | 问题       |
| -------------- | -------------- | ------------------------ | ---------- |
| **运行时类型** | 运行时确定类型 | `let x = 1; x = "hello"` | 类型错误   |
| **隐式转换**   | 自动类型转换   | `1 + "2"`                | 意外结果   |
| **类型检查**   | 运行时检查     | `obj.method()`           | 运行时错误 |
| **灵活性**     | 类型灵活       | 动态属性                 | 维护困难   |

### 🔧 详细说明

**动态类型问题**

> **🎯 解决的问题**：JavaScript 的动态类型虽然灵活，但容易产生类型错误，需要运行时才能发现。

```javascript
// 动态类型问题示例
function calculateTotal(price, quantity) {
  return price * quantity;
}

// 运行时才发现错误
console.log(calculateTotal("10", "5")); // "105" (字符串拼接)
console.log(calculateTotal(10, 5)); // 50 (正确)

// 对象属性访问错误
const user = {
  name: "张三",
  age: 25,
};

// 运行时才发现属性不存在
console.log(user.nam); // undefined (拼写错误)
console.log(user.name); // "张三" (正确)

// 方法调用错误
const obj = {
  value: 42,
};

// 运行时才发现方法不存在
obj.getValue(); // TypeError: obj.getValue is not a function
```

---

## TypeScript 静态类型

### 📝 TypeScript 特性

| 特性         | 语法       | 示例                | 用途     |
| ------------ | ---------- | ------------------- | -------- |
| **类型注解** | `: type`   | `let x: number = 1` | 类型声明 |
| **类型检查** | 编译时检查 | `tsc`               | 错误检测 |
| **类型推断** | 自动推断   | `let x = 1`         | 自动类型 |
| **类型兼容** | 结构化类型 | `interface`         | 类型兼容 |

### 🔧 详细说明

**TypeScript 基础类型**

> **🎯 解决的问题**：TypeScript 提供了静态类型系统，在编译时就能发现类型错误，提高代码质量。

```typescript
// 基础类型
let name: string = "张三";
let age: number = 25;
let isActive: boolean = true;
let items: string[] = ["apple", "banana"];
let user: { name: string; age: number } = { name: "张三", age: 25 };

// 函数类型
function greet(name: string): string {
  return `Hello, ${name}!`;
}

// 可选参数
function createUser(name: string, age?: number): User {
  return { name, age: age || 0 };
}

// 默认参数
function calculateTotal(price: number, tax: number = 0.1): number {
  return price * (1 + tax);
}

// 实际应用：API接口
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

async function fetchUser(id: number): Promise<ApiResponse<User>> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}
```

---

## 类型推断

### 📝 类型推断规则

| 规则             | 说明         | 示例                  | 结果                   |
| ---------------- | ------------ | --------------------- | ---------------------- |
| **字面量推断**   | 从字面量推断 | `let x = 1`           | `number`               |
| **上下文推断**   | 从上下文推断 | `arr.map(x => x + 1)` | `number`               |
| **最佳公共类型** | 联合类型推断 | `[1, "hello"]`        | `(string \| number)[]` |
| **类型断言**     | 手动指定类型 | `value as string`     | `string`               |

### 🔧 详细说明

**类型推断 - 自动类型**

> **🎯 解决的问题**：TypeScript 能够自动推断类型，减少类型注解，提高开发效率。

```typescript
// 基础类型推断
let x = 1; // 推断为 number
let y = "hello"; // 推断为 string
let z = true; // 推断为 boolean

// 数组类型推断
let numbers = [1, 2, 3]; // 推断为 number[]
let mixed = [1, "hello", true]; // 推断为 (string | number | boolean)[]

// 函数类型推断
function add(a: number, b: number) {
  return a + b; // 推断返回类型为 number
}

// 对象类型推断
const user = {
  name: "张三",
  age: 25,
  isActive: true,
}; // 推断为 {name: string, age: number, isActive: boolean}

// 实际应用：泛型推断
function identity<T>(value: T): T {
  return value;
}

const result = identity("hello"); // 推断为 string
const number = identity(42); // 推断为 number
```

---

## 类型守卫

### 📝 类型守卫类型

| 类型           | 语法                     | 示例                    | 用途           |
| -------------- | ------------------------ | ----------------------- | -------------- |
| **typeof**     | `typeof value`           | `typeof x === "string"` | 基础类型检查   |
| **instanceof** | `value instanceof Class` | `obj instanceof Date`   | 实例类型检查   |
| **in 操作符**  | `"prop" in obj`          | `"name" in user`        | 属性存在检查   |
| **自定义守卫** | `function isType()`      | `isString(value)`       | 自定义类型检查 |

### 🔧 详细说明

**类型守卫 - 类型收窄**

> **🎯 解决的问题**：类型守卫能够收窄类型范围，让 TypeScript 更准确地推断类型。

```typescript
// typeof类型守卫
function processValue(value: string | number) {
  if (typeof value === "string") {
    // 这里value被收窄为string类型
    return value.toUpperCase();
  } else {
    // 这里value被收窄为number类型
    return value * 2;
  }
}

// instanceof类型守卫
function formatDate(date: Date | string) {
  if (date instanceof Date) {
    // 这里date被收窄为Date类型
    return date.toLocaleDateString();
  } else {
    // 这里date被收窄为string类型
    return new Date(date).toLocaleDateString();
  }
}

// in操作符类型守卫
interface Bird {
  fly(): void;
  layEggs(): void;
}

interface Fish {
  swim(): void;
  layEggs(): void;
}

function move(animal: Bird | Fish) {
  if ("fly" in animal) {
    // 这里animal被收窄为Bird类型
    animal.fly();
  } else {
    // 这里animal被收窄为Fish类型
    animal.swim();
  }
}

// 自定义类型守卫
function isString(value: unknown): value is string {
  return typeof value === "string";
}

function processUnknown(value: unknown) {
  if (isString(value)) {
    // 这里value被收窄为string类型
    return value.toUpperCase();
  }
  return value;
}
```

---

## 泛型

### 📝 泛型特性

| 特性         | 语法            | 示例                         | 用途       |
| ------------ | --------------- | ---------------------------- | ---------- |
| **泛型函数** | `function<T>()` | `function identity<T>(x: T)` | 类型参数化 |
| **泛型接口** | `interface<T>`  | `interface ApiResponse<T>`   | 接口参数化 |
| **泛型类**   | `class<T>`      | `class Container<T>`         | 类参数化   |
| **泛型约束** | `T extends U`   | `T extends string`           | 类型约束   |

### 🔧 详细说明

**泛型 - 类型参数化**

> **🎯 解决的问题**：泛型提供了类型参数化，让代码更加灵活和可复用。

```typescript
// 泛型函数
function identity<T>(value: T): T {
  return value;
}

const stringResult = identity<string>("hello");
const numberResult = identity<number>(42);

// 泛型接口
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

interface User {
  id: number;
  name: string;
  email: string;
}

// 使用泛型接口
const userResponse: ApiResponse<User> = {
  data: { id: 1, name: "张三", email: "zhangsan@example.com" },
  status: 200,
  message: "success",
};

// 泛型类
class Container<T> {
  private items: T[] = [];

  add(item: T): void {
    this.items.push(item);
  }

  get(index: number): T | undefined {
    return this.items[index];
  }

  getAll(): T[] {
    return [...this.items];
  }
}

// 使用泛型类
const stringContainer = new Container<string>();
stringContainer.add("hello");
stringContainer.add("world");

const numberContainer = new Container<number>();
numberContainer.add(1);
numberContainer.add(2);

// 泛型约束
interface Lengthwise {
  length: number;
}

function logLength<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}

logLength("hello"); // 5
logLength([1, 2, 3]); // 3
logLength({ length: 10 }); // 10
```

---

## 接口与类型别名

### 📝 接口与类型别名对比

| 特性         | 接口         | 类型别名 | 用途     |
| ------------ | ------------ | -------- | -------- |
| **声明合并** | 支持         | 不支持   | 扩展接口 |
| **继承**     | `extends`    | `&`      | 类型继承 |
| **实现**     | `implements` | 不支持   | 类实现   |
| **联合类型** | 不支持       | 支持     | 类型联合 |

### 🔧 详细说明

**接口 - 对象结构**

> **🎯 解决的问题**：接口定义了对象的结构，提供了类型检查和代码提示。

```typescript
// 基础接口
interface User {
  id: number;
  name: string;
  email: string;
  age?: number; // 可选属性
  readonly createdAt: Date; // 只读属性
}

// 接口继承
interface Admin extends User {
  permissions: string[];
  isActive: boolean;
}

// 接口实现
class UserService implements User {
  id: number;
  name: string;
  email: string;
  createdAt: Date;

  constructor(id: number, name: string, email: string) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.createdAt = new Date();
  }
}

// 接口声明合并
interface User {
  phone?: string;
}

// 现在User接口包含phone属性
const user: User = {
  id: 1,
  name: "张三",
  email: "zhangsan@example.com",
  createdAt: new Date(),
  phone: "13800138000",
};

// 实际应用：API接口
interface ApiEndpoints {
  users: {
    GET: User[];
    POST: (user: Omit<User, "id" | "createdAt">) => User;
    PUT: (id: number, user: Partial<User>) => User;
    DELETE: (id: number) => void;
  };
}
```

**类型别名 - 类型定义**

```typescript
// 基础类型别名
type ID = string | number;
type Status = "pending" | "approved" | "rejected";

// 对象类型别名
type User = {
  id: ID;
  name: string;
  email: string;
  status: Status;
};

// 联合类型别名
type StringOrNumber = string | number;
type EventHandler = (event: Event) => void;

// 交叉类型别名
type AdminUser = User & {
  permissions: string[];
  isActive: boolean;
};

// 实际应用：工具类型
type Partial<T> = {
  [P in keyof T]?: T[P];
};

type Required<T> = {
  [P in keyof T]-?: T[P];
};

type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
```

---

## 联合类型与交叉类型

### 📝 联合类型与交叉类型

| 类型           | 语法         | 示例                   | 用途       |
| -------------- | ------------ | ---------------------- | ---------- |
| **联合类型**   | `A \| B`     | `string \| number`     | 类型选择   |
| **交叉类型**   | `A & B`      | `User & Admin`         | 类型合并   |
| **字面量类型** | `"a" \| "b"` | `"success" \| "error"` | 具体值     |
| **never 类型** | `never`      | 函数永不返回           | 不可能类型 |

### 🔧 详细说明

**联合类型 - 类型选择**

> **🎯 解决的问题**：联合类型允许一个值可以是多种类型中的一种，提供了类型灵活性。

```typescript
// 基础联合类型
type StringOrNumber = string | number;

function processValue(value: StringOrNumber) {
  if (typeof value === "string") {
    return value.toUpperCase();
  } else {
    return value * 2;
  }
}

// 字面量联合类型
type Status = "pending" | "approved" | "rejected";
type Theme = "light" | "dark";

function setStatus(status: Status) {
  console.log(`Status set to: ${status}`);
}

// 对象联合类型
type Circle = {
  kind: "circle";
  radius: number;
};

type Rectangle = {
  kind: "rectangle";
  width: number;
  height: number;
};

type Shape = Circle | Rectangle;

function calculateArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius * shape.radius;
    case "rectangle":
      return shape.width * shape.height;
    default:
      // 这里shape被收窄为never类型
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
  }
}

// 实际应用：API响应
type ApiResponse<T> =
  | { success: true; data: T }
  | { success: false; error: string };

function handleApiResponse<T>(response: ApiResponse<T>) {
  if (response.success) {
    // 这里response被收窄为成功类型
    console.log("Data:", response.data);
  } else {
    // 这里response被收窄为失败类型
    console.error("Error:", response.error);
  }
}
```

**交叉类型 - 类型合并**

```typescript
// 基础交叉类型
type User = {
  id: number;
  name: string;
  email: string;
};

type Admin = {
  permissions: string[];
  isActive: boolean;
};

type AdminUser = User & Admin;

// 使用交叉类型
const adminUser: AdminUser = {
  id: 1,
  name: "张三",
  email: "zhangsan@example.com",
  permissions: ["read", "write", "delete"],
  isActive: true,
};

// 实际应用：混入模式
type Timestamped = {
  createdAt: Date;
  updatedAt: Date;
};

type SoftDelete = {
  deletedAt: Date | null;
  isDeleted: boolean;
};

type BaseEntity = User & Timestamped & SoftDelete;

// 实际应用：函数重载
type EventHandler<T> = (event: T) => void;

type MouseEventHandler = EventHandler<MouseEvent>;
type KeyboardEventHandler = EventHandler<KeyboardEvent>;

type EventHandlers = MouseEventHandler & KeyboardEventHandler;
```

---

## 工具类型

### 📝 内置工具类型

| 类型         | 语法            | 示例                                | 用途         |
| ------------ | --------------- | ----------------------------------- | ------------ |
| **Partial**  | `Partial<T>`    | `Partial<User>`                     | 所有属性可选 |
| **Required** | `Required<T>`   | `Required<User>`                    | 所有属性必需 |
| **Pick**     | `Pick<T, K>`    | `Pick<User, "name">`                | 选择属性     |
| **Omit**     | `Omit<T, K>`    | `Omit<User, "id">`                  | 排除属性     |
| **Record**   | `Record<K, V>`  | `Record<string, number>`            | 键值对类型   |
| **Exclude**  | `Exclude<T, U>` | `Exclude<string \| number, string>` | 排除类型     |
| **Extract**  | `Extract<T, U>` | `Extract<string \| number, string>` | 提取类型     |

### 🔧 详细说明

**工具类型 - 类型操作**

> **🎯 解决的问题**：工具类型提供了类型操作能力，让类型系统更加灵活和强大。

```typescript
// 基础工具类型
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
  isActive: boolean;
}

// Partial - 所有属性可选
type PartialUser = Partial<User>;
// 等价于 { id?: number; name?: string; email?: string; age?: number; isActive?: boolean; }

// Required - 所有属性必需
type RequiredUser = Required<PartialUser>;
// 等价于 User

// Pick - 选择属性
type UserBasicInfo = Pick<User, "name" | "email">;
// 等价于 { name: string; email: string; }

// Omit - 排除属性
type UserWithoutId = Omit<User, "id">;
// 等价于 { name: string; email: string; age: number; isActive: boolean; }

// Record - 键值对类型
type UserRoles = Record<string, string[]>;
// 等价于 { [key: string]: string[]; }

// 实际应用：API类型
type CreateUserRequest = Omit<User, "id">;
type UpdateUserRequest = Partial<Omit<User, "id">>;
type UserResponse = Required<User>;

// 实际应用：表单类型
type UserForm = Pick<User, "name" | "email" | "age">;
type UserFormErrors = Record<keyof UserForm, string>;

// 自定义工具类型
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

type DeepRequired<T> = {
  [P in keyof T]-?: T[P] extends object ? DeepRequired<T[P]> : T[P];
};

// 使用自定义工具类型
interface NestedUser {
  id: number;
  profile: {
    name: string;
    avatar: string;
  };
  settings: {
    theme: string;
    language: string;
  };
}

type PartialNestedUser = DeepPartial<NestedUser>;
type RequiredNestedUser = DeepRequired<PartialNestedUser>;
```

---

## 实际应用场景

### 1. React 组件类型

**React 组件类型定义**

```typescript
import React from "react";

// 组件Props类型
interface ButtonProps {
  children: React.ReactNode;
  onClick: () => void;
  variant?: "primary" | "secondary" | "danger";
  size?: "small" | "medium" | "large";
  disabled?: boolean;
}

// 函数组件
const Button: React.FC<ButtonProps> = ({
  children,
  onClick,
  variant = "primary",
  size = "medium",
  disabled = false,
}) => {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`btn btn-${variant} btn-${size}`}
    >
      {children}
    </button>
  );
};

// 类组件
interface CounterState {
  count: number;
}

class Counter extends React.Component<{}, CounterState> {
  constructor(props: {}) {
    super(props);
    this.state = { count: 0 };
  }

  increment = () => {
    this.setState((prevState) => ({
      count: prevState.count + 1,
    }));
  };

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <Button onClick={this.increment}>Increment</Button>
      </div>
    );
  }
}
```

### 2. API 类型定义

**API 接口类型**

```typescript
// API响应类型
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
  timestamp: string;
}

// 用户相关类型
interface User {
  id: number;
  name: string;
  email: string;
  avatar?: string;
  createdAt: string;
  updatedAt: string;
}

interface CreateUserRequest {
  name: string;
  email: string;
  password: string;
}

interface UpdateUserRequest {
  name?: string;
  email?: string;
  avatar?: string;
}

// API服务类型
class UserService {
  async getUsers(): Promise<ApiResponse<User[]>> {
    const response = await fetch("/api/users");
    return response.json();
  }

  async getUser(id: number): Promise<ApiResponse<User>> {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  }

  async createUser(user: CreateUserRequest): Promise<ApiResponse<User>> {
    const response = await fetch("/api/users", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(user),
    });
    return response.json();
  }

  async updateUser(
    id: number,
    user: UpdateUserRequest
  ): Promise<ApiResponse<User>> {
    const response = await fetch(`/api/users/${id}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(user),
    });
    return response.json();
  }

  async deleteUser(id: number): Promise<ApiResponse<void>> {
    const response = await fetch(`/api/users/${id}`, {
      method: "DELETE",
    });
    return response.json();
  }
}
```

### 3. 状态管理类型

**Redux 类型定义**

```typescript
import { createStore, applyMiddleware, combineReducers } from "redux";
import thunk, { ThunkAction, ThunkDispatch } from "redux-thunk";

// 状态类型
interface UserState {
  users: User[];
  loading: boolean;
  error: string | null;
  currentUser: User | null;
}

interface AppState {
  user: UserState;
}

// Action类型
type UserAction =
  | { type: "FETCH_USERS_START" }
  | { type: "FETCH_USERS_SUCCESS"; payload: User[] }
  | { type: "FETCH_USERS_ERROR"; payload: string }
  | { type: "SET_CURRENT_USER"; payload: User | null };

// Thunk Action类型
type UserThunkAction = ThunkAction<
  Promise<void>,
  AppState,
  unknown,
  UserAction
>;

// Reducer类型
const userReducer = (
  state: UserState = {
    users: [],
    loading: false,
    error: null,
    currentUser: null,
  },
  action: UserAction
): UserState => {
  switch (action.type) {
    case "FETCH_USERS_START":
      return { ...state, loading: true, error: null };
    case "FETCH_USERS_SUCCESS":
      return { ...state, loading: false, users: action.payload };
    case "FETCH_USERS_ERROR":
      return { ...state, loading: false, error: action.payload };
    case "SET_CURRENT_USER":
      return { ...state, currentUser: action.payload };
    default:
      return state;
  }
};

// Store类型
const rootReducer = combineReducers({
  user: userReducer,
});

export type RootState = ReturnType<typeof rootReducer>;
export type AppDispatch = ThunkDispatch<RootState, unknown, UserAction>;

const store = createStore(rootReducer, applyMiddleware(thunk));

// Action Creators
export const fetchUsers = (): UserThunkAction => {
  return async (dispatch) => {
    dispatch({ type: "FETCH_USERS_START" });
    try {
      const response = await fetch("/api/users");
      const users = await response.json();
      dispatch({ type: "FETCH_USERS_SUCCESS", payload: users });
    } catch (error) {
      dispatch({ type: "FETCH_USERS_ERROR", payload: error.message });
    }
  };
};
```

---

## 面试常考问题

### 1. 类型推断

```typescript
// 问题：解释以下代码的类型推断
let x = 1; // 推断为 number
let y = "hello"; // 推断为 string
let z = [1, 2, 3]; // 推断为 number[]

function add(a: number, b: number) {
  return a + b; // 推断返回类型为 number
}

// 答案：TypeScript会根据赋值和上下文自动推断类型
```

### 2. 联合类型

```typescript
// 问题：解释以下代码的类型
type StringOrNumber = string | number;

function process(value: StringOrNumber) {
  if (typeof value === "string") {
    return value.toUpperCase(); // 这里value被收窄为string
  } else {
    return value * 2; // 这里value被收窄为number
  }
}

// 答案：联合类型允许一个值可以是多种类型中的一种
```

### 3. 泛型约束

```typescript
// 问题：解释以下代码的泛型约束
interface Lengthwise {
  length: number;
}

function logLength<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}

logLength("hello"); // 5
logLength([1, 2, 3]); // 3

// 答案：泛型约束限制了类型参数必须满足特定条件
```

### 4. 工具类型

```typescript
// 问题：解释以下工具类型的作用
interface User {
  id: number;
  name: string;
  email: string;
}

type PartialUser = Partial<User>;
type RequiredUser = Required<PartialUser>;
type UserBasicInfo = Pick<User, "name" | "email">;
type UserWithoutId = Omit<User, "id">;

// 答案：
// Partial: 所有属性可选
// Required: 所有属性必需
// Pick: 选择指定属性
// Omit: 排除指定属性
```

---

## 📋 总结

### 记忆技巧

1. **分类记忆**：按类型系统分类记忆
2. **对比记忆**：JavaScript vs TypeScript
3. **实例记忆**：通过实例理解概念
4. **实践记忆**：通过实际项目加深理解
5. **总结记忆**：定期总结和复习

### 使用建议

1. **渐进式使用**：从基础类型开始，逐步使用高级特性
2. **类型安全**：充分利用类型检查，减少运行时错误
3. **代码提示**：利用类型系统提供更好的代码提示
4. **重构安全**：类型系统让重构更加安全
5. **团队协作**：类型系统提高团队协作效率
