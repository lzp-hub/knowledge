## 一、构建工具与打包优化

### 1. Webpack 与 Vite 的区别 🔥

**一句话回答**
 Webpack 是“先打包再服务”的通用打包器；Vite 利用原生 ESM 与 ESBuild 做“按需即开即用”的开发服务器，并在生产阶段用 Rollup 打包，开发体验更快。

**要点**

- **模式**：Webpack 以 **bundle** 为中心；Vite 以 **原生 ESM + 按需编译** 为中心。
- **冷启动**：Webpack 需打包整图后再启动；Vite 仅转换被请求的模块，**冷启动极快**。
- **HMR**：Vite 基于模块级更新，粒度更细、回流更小；Webpack 依赖热替换的包级增量。
- **构建**：Vite 生产构建用 **Rollup**（可配 esbuild-minify）；Webpack 一套配置走到底。
- **依赖预构建**：Vite 用 ESBuild 将大量依赖预打包为 ESM，解决 CJS/多文件过多导致的请求开销。

**详细回答**

- **启动方式不同**
  - Webpack Dev Server：先根据配置从入口构建**依赖图**，应用 **Loader/Plugin** 进行打包（内存中产物），再起服务，所以**冷启动慢**（项目越大越慢）。
  - Vite Dev Server：直接把源码作为 **原生 ESM** 提供给浏览器；当浏览器请求某个模块时再用 **ESBuild** 做**即时转换（TS/JS/JSX）\**与\**按需编译**，无需等待全部打包完成，**冷启动极快**。
- **HMR 机制不同**
  - Webpack：HMR 依旧围绕 bundle，更新会穿过更复杂的模块链路。
  - Vite：以模块为粒度的 HMR，**只更新受影响的模块**，在大型项目中交互更顺滑。
- **依赖与构建**
  - Vite 在开发时对第三方依赖做 **ESBuild 预构建（pre-bundle）**，把 CJS 转为 ESM，并合并成更少的模块，减少请求与解析成本。
  - 生产环境 Vite 使用 **Rollup**：天然支持 **tree-shaking / code splitting**、更优的静态分析与长效缓存策略。
  - Webpack 构建链路灵活强大（loader/plugin 生态极其成熟），复杂场景（老代码/非标准资源/高度定制）依旧有统治力。

**扩展/对比**

- **为什么 Vite 冷启动快？** 👉 因为 **按需编译** + **原生 ESM**：只转换被访问的文件；而 Webpack 需在启动前构建整个依赖图并打包。
- **何时选 Vite？** 前端应用、现代语法、偏重开发体验与研发效率；SSR、Island 架构、现代框架（Vue/React/Svelte）配合优秀。
- **何时选 Webpack？** 老项目迁移成本高、需要复杂的自定义打包逻辑、特定 Loader/Plugin 生态绑定、微前端体系与企业级“黑魔法”较多时。
- **坑位提醒**
  - Vite 的 **依赖预构建** 对大型 CJS 依赖首次运行会花时间，需要理解 `optimizeDeps` 与 `ssr.noExternal` 等配置。
  - 多包/Monorepo 时要留意 **路径/别名/外部化** 与 **TS path** 的一致性（Vite/TS/Rollup 三方对齐）。
  - 构建体量极大且有特殊产物需求（如自定义分包/运行时注入）时，Webpack 的可塑性仍更强。

---

### 2. Tree Shaking 的原理 🔥

**一句话回答**
Tree Shaking 通过静态分析 ESModule，删除未使用代码。

**要点**

- 依赖 ESModule 静态结构。
- DCE（Dead Code Elimination）。
- Rollup/webpack 都支持。

**详细回答**

- Tree Shaking 依赖 import/export 静态声明。
- 动态 require 不能被摇树优化。
- Webpack 通过 Terser 进一步清除死代码。

**扩展/对比**

- 面试官可能问：“为什么 CommonJS 不支持 Tree Shaking？” 👉 因为 require 是运行时动态。

---

### 3. Babel 与 TS 编译器的区别

**一句话回答**
Babel 只做语法转换，不做类型检查；TS 编译器同时支持类型检查和转译。

**要点**

- Babel：快，兼容性好。
- TS：带类型系统。
- 项目中常结合使用。

**详细回答**

- 大项目常用 Babel 转译，TS 用 tsc 做类型检查。

**扩展/对比**

- 面试官常问：“你们项目里怎么跑 TS？” 👉 ts-loader、babel-loader、tsc --noEmit。

---

### 4. Monorepo 的优势与管理工具 🔥

**一句话回答**
Monorepo 把多个项目放在一个仓库，便于依赖共享和统一管理。

**要点**

- 优势：统一版本、依赖共享、代码复用。
- 工具：pnpm workspace、Turborepo、Nx。

**详细回答**

- Monorepo 适合中大型团队，有利于统一规范、减少依赖冲突。
- pnpm workspace：轻量依赖管理。
- Turborepo：缓存 + 并行构建。

**扩展/对比**

- 面试官可能问：“Monorepo 的缺点是什么？” 👉 仓库庞大，构建复杂，需要缓存优化。

---

## 二、CI/CD 与自动化

### 5. 什么是 CI/CD？ 🔥

**一句话回答**
 CI/CD 是持续集成（Continuous Integration）和持续交付/部署（Continuous Delivery/Deployment），通过自动化构建、测试和部署来提高研发效率和上线质量。

**要点**

- **CI**：自动化构建、测试、代码检查，保证代码库始终可用。
- **CD**：自动化部署/交付，让代码快速、安全地上线。
- **工具链**：GitHub Actions、GitLab CI、Jenkins、CircleCI 等。
- **好处**：减少人工操作失误，加快迭代，保证质量与稳定性。

**详细回答**
 CI/CD 是现代软件工程中必备的自动化实践：

- **CI（持续集成）**：
  - 开发者代码提交（push/PR）后自动触发流水线。
  - 自动执行 **Lint → 单元测试 → 构建 → 集成测试**，确保代码质量和兼容性。
  - 优点：及早发现问题，避免集成“地狱”。
- **CD（持续交付/持续部署）**：
  - **持续交付（Continuous Delivery）**：代码经过测试后，系统会生成可随时上线的产物，但最终上线仍需人工批准。
  - **持续部署（Continuous Deployment）**：代码一旦通过测试，会自动部署到生产环境，全程无人干预。
  - 优点：缩短上线周期，减少人为操作风险。
- **典型工具与实践**：
  - GitHub Actions：基于事件触发（push、pull request、tag 发布）。
  - GitLab CI/CD：与 GitLab 深度集成，适合企业私有化部署。
  - Jenkins：插件丰富，适合高度自定义的大型项目。
- **常见流水线步骤**：
  - `Lint` → `Unit Test` → `Build` → `Integration Test` → `Deploy`。

**扩展/对比**

- 面试常见追问：
  - **“你们项目怎么保证上线质量？”** 👉 强调 CI/CD：测试覆盖率、自动化检查、灰度发布。
  - **“你们是持续交付还是持续部署？”** 👉 持续交付强调“随时可发”，持续部署强调“自动上线”。
- **对比手动部署**：CI/CD 极大降低了人为失误（例如配置漏改、环境差异）。
- **最佳实践**：
  - 配置 **Pre-commit Hooks**（如 Husky）在本地先跑校验。
  - 使用 **并行任务**（例如测试与构建分支并行）。
  - 引入 **质量门槛**（测试覆盖率、lint 必须通过，否则拒绝合并/上线）。。

---

### 6. 如何设计前端 CI/CD 流程 🔥

**一句话回答**
典型流程：代码提交 → Lint/测试 → 构建 → Docker 镜像 → 部署。

**要点**

- 提交前：Husky + Lint-Staged。
- 提交后：CI 流水线。
- 部署：CD + Docker。

**详细回答**

```yaml
# GitHub Actions 示例
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run lint && npm run test
      - run: npm run build
```

**扩展/对比**

- 面试官可能问：“怎么支持多环境（dev/staging/prod）？” 👉 .env 文件 + CI 变量。

---

### 7. Husky + Lint-Staged 的作用

**一句话回答**
Husky 用于 Git Hooks，Lint-Staged 只检查提交的文件。

**要点**

- Husky：pre-commit、pre-push。
- Lint-Staged：优化性能。

**详细回答**

- Husky 可以在 commit 前自动执行 ESLint、Prettier。
- Lint-Staged 避免全量检查，加快速度。

**扩展/对比**

- 面试官可能问：“为什么要用 Lint-Staged？” 👉 因为只校验改动文件，性能更好。

---

## 三、代码规范与质量保障

### 8. ESLint 与 Prettier 的区别 🔥

**一句话回答**
ESLint 用于代码质量检查，Prettier 用于代码格式化。

**要点**

- ESLint：检测潜在 bug（未定义变量、无用变量）。
- Prettier：统一格式（缩进、分号）。

**详细回答**

- 两者可以结合：ESLint 负责规则，Prettier 接管格式化相关规则。

**扩展/对比**

- 面试官可能问：“你们团队怎么统一规范？” 👉 ESLint + Prettier + Husky。

---

### 9. 如何保证团队代码风格一致

**一句话回答**
通过 Lint + Prettier + Git Hooks + CI 保证风格一致。

**要点**

- 规范：ESLint、Prettier。
- 提交：Husky 检查。
- CI：二次校验。

**详细回答**

- 本地开发：保存即格式化。
- 提交时：Husky 强制校验。
- CI：阻止不合规范代码进入主分支。

**扩展/对比**

- 面试官可能问：“如何防止有人跳过 Lint？” 👉 在 CI 流程里强制检查。

---

## 四、性能与打包优化

### 10. 前端构建如何优化性能 🔥

**一句话回答**
通过代码分割、缓存、预加载、压缩优化性能。

**要点**

- SplitChunks：代码分割。
- CDN + 缓存。
- Gzip / Brotli。
- 图片优化。

**详细回答**

- 按路由拆分 bundle。
- 第三方库抽离 vendor。
- 使用 CDN 分发资源。

**扩展/对比**

- 面试官常问：“如何减少首屏 JS 体积？” 👉 代码分割 + 按需加载。

---

### 11. Source Map 的作用与风险

**一句话回答**
Source Map 用于调试映射，但生产环境需谨慎。

**要点**

- 作用：源码映射。
- 风险：泄漏源码。
- 解决：只上传到错误监控平台，不公开。

**详细回答**

- `devtool: "source-map"` 可生成调试文件。
- 生产环境一般 hidden-source-map，只在 Sentry 上传。

**扩展/对比**

- 面试官常问：“你们怎么处理 Source Map 安全？” 👉 CI 上传到错误监控平台。

---

### 12. 如何做多环境配置（dev/staging/prod）

**一句话回答**
通过 `.env` 文件 + 构建配置区分环境。

**要点**

- dotenv。
- webpack/next 配置。
- CI 注入变量。

**详细回答**

- `.env.development`、`.env.production`。
- CI/CD 时注入环境变量。

**扩展/对比**

- 面试官常问：“怎么保证不同环境配置隔离？” 👉 独立 .env 文件，避免硬编码。

---
