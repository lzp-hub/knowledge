## 一、构建工具与打包优化

### 1. Webpack 与 Vite 的区别 🔥

**一句话回答**
Webpack 是成熟的打包工具，Vite 基于 ESBuild + Rollup，开发体验更快。

**要点**

- Webpack：bundle 模式，功能全面。
- Vite：原生 ESM，冷启动快。
- 构建阶段：Vite 用 Rollup。

**详细回答**

- Webpack 打包时先编译再运行，冷启动慢。
- Vite 开发阶段直接用 ESBuild 处理，浏览器原生 ESM，启动快。
- Vite 生产构建仍依赖 Rollup。

**扩展/对比**

- 面试官常问：“为什么 Vite 冷启动比 Webpack 快？” 👉 因为它只编译当前依赖文件。

---

### 2. Tree Shaking 的原理 🔥

**一句话回答**
Tree Shaking 通过静态分析 ESModule，删除未使用代码。

**要点**

- 依赖 ESModule 静态结构。
- DCE（Dead Code Elimination）。
- Rollup/webpack 都支持。

**详细回答**

- Tree Shaking 依赖 import/export 静态声明。
- 动态 require 不能被摇树优化。
- Webpack 通过 Terser 进一步清除死代码。

**扩展/对比**

- 面试官可能问：“为什么 CommonJS 不支持 Tree Shaking？” 👉 因为 require 是运行时动态。

---

### 3. Babel 与 TS 编译器的区别

**一句话回答**
Babel 只做语法转换，不做类型检查；TS 编译器同时支持类型检查和转译。

**要点**

- Babel：快，兼容性好。
- TS：带类型系统。
- 项目中常结合使用。

**详细回答**

- 大项目常用 Babel 转译，TS 用 tsc 做类型检查。

**扩展/对比**

- 面试官常问：“你们项目里怎么跑 TS？” 👉 ts-loader、babel-loader、tsc --noEmit。

---

### 4. Monorepo 的优势与管理工具 🔥

**一句话回答**
Monorepo 把多个项目放在一个仓库，便于依赖共享和统一管理。

**要点**

- 优势：统一版本、依赖共享、代码复用。
- 工具：pnpm workspace、Turborepo、Nx。

**详细回答**

- Monorepo 适合中大型团队，有利于统一规范、减少依赖冲突。
- pnpm workspace：轻量依赖管理。
- Turborepo：缓存 + 并行构建。

**扩展/对比**

- 面试官可能问：“Monorepo 的缺点是什么？” 👉 仓库庞大，构建复杂，需要缓存优化。

---

## 二、CI/CD 与自动化

### 5. 什么是 CI/CD？ 🔥

**一句话回答**
CI/CD 是持续集成与持续交付，自动化构建、测试、部署流程。

**要点**

- CI：自动化构建+测试。
- CD：自动化部署/交付。
- 工具：GitHub Actions、Jenkins、GitLab CI。

**详细回答**

- CI/CD 避免了人工操作出错。
- GitHub Actions 可基于事件触发（push/pull request）。
- 常见流程：Lint → Test → Build → Deploy。

**扩展/对比**

- 面试官常问：“你们项目怎么保证上线质量？” 👉 CI/CD 流程。

---

### 6. 如何设计前端 CI/CD 流程 🔥

**一句话回答**
典型流程：代码提交 → Lint/测试 → 构建 → Docker 镜像 → 部署。

**要点**

- 提交前：Husky + Lint-Staged。
- 提交后：CI 流水线。
- 部署：CD + Docker。

**详细回答**

```yaml
# GitHub Actions 示例
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm ci
      - run: npm run lint && npm run test
      - run: npm run build
```

**扩展/对比**

- 面试官可能问：“怎么支持多环境（dev/staging/prod）？” 👉 .env 文件 + CI 变量。

---

### 7. Husky + Lint-Staged 的作用

**一句话回答**
Husky 用于 Git Hooks，Lint-Staged 只检查提交的文件。

**要点**

- Husky：pre-commit、pre-push。
- Lint-Staged：优化性能。

**详细回答**

- Husky 可以在 commit 前自动执行 ESLint、Prettier。
- Lint-Staged 避免全量检查，加快速度。

**扩展/对比**

- 面试官可能问：“为什么要用 Lint-Staged？” 👉 因为只校验改动文件，性能更好。

---

## 三、代码规范与质量保障

### 8. ESLint 与 Prettier 的区别 🔥

**一句话回答**
ESLint 用于代码质量检查，Prettier 用于代码格式化。

**要点**

- ESLint：检测潜在 bug（未定义变量、无用变量）。
- Prettier：统一格式（缩进、分号）。

**详细回答**

- 两者可以结合：ESLint 负责规则，Prettier 接管格式化相关规则。

**扩展/对比**

- 面试官可能问：“你们团队怎么统一规范？” 👉 ESLint + Prettier + Husky。

---

### 9. 如何保证团队代码风格一致

**一句话回答**
通过 Lint + Prettier + Git Hooks + CI 保证风格一致。

**要点**

- 规范：ESLint、Prettier。
- 提交：Husky 检查。
- CI：二次校验。

**详细回答**

- 本地开发：保存即格式化。
- 提交时：Husky 强制校验。
- CI：阻止不合规范代码进入主分支。

**扩展/对比**

- 面试官可能问：“如何防止有人跳过 Lint？” 👉 在 CI 流程里强制检查。

---

## 四、性能与打包优化

### 10. 前端构建如何优化性能 🔥

**一句话回答**
通过代码分割、缓存、预加载、压缩优化性能。

**要点**

- SplitChunks：代码分割。
- CDN + 缓存。
- Gzip / Brotli。
- 图片优化。

**详细回答**

- 按路由拆分 bundle。
- 第三方库抽离 vendor。
- 使用 CDN 分发资源。

**扩展/对比**

- 面试官常问：“如何减少首屏 JS 体积？” 👉 代码分割 + 按需加载。

---

### 11. Source Map 的作用与风险

**一句话回答**
Source Map 用于调试映射，但生产环境需谨慎。

**要点**

- 作用：源码映射。
- 风险：泄漏源码。
- 解决：只上传到错误监控平台，不公开。

**详细回答**

- `devtool: "source-map"` 可生成调试文件。
- 生产环境一般 hidden-source-map，只在 Sentry 上传。

**扩展/对比**

- 面试官常问：“你们怎么处理 Source Map 安全？” 👉 CI 上传到错误监控平台。

---

### 12. 如何做多环境配置（dev/staging/prod）

**一句话回答**
通过 `.env` 文件 + 构建配置区分环境。

**要点**

- dotenv。
- webpack/next 配置。
- CI 注入变量。

**详细回答**

- `.env.development`、`.env.production`。
- CI/CD 时注入环境变量。

**扩展/对比**

- 面试官常问：“怎么保证不同环境配置隔离？” 👉 独立 .env 文件，避免硬编码。

---
