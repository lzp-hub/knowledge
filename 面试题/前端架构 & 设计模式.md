## 一、设计模式

### 1. 前端常见的设计模式有哪些？ 🔥

**一句话回答**
常见模式有单例、工厂、观察者、发布订阅、代理、装饰器。

**要点**

- 单例：全局唯一实例（Store）。
- 工厂：封装创建逻辑（组件工厂）。
- 观察者：对象间一对多依赖（Vue2 响应式）。
- 发布订阅：事件中心（EventEmitter）。
- 代理：拦截操作（Proxy、Vue3）。
- 装饰器：增强功能（TS 装饰器）。

**详细回答**

- Redux store 是典型单例模式。
- Vue2 数据绑定基于观察者模式。
- EventBus 属于发布订阅模式。
- Vue3 响应式用 Proxy，是代理模式应用。

**扩展/对比**

- 面试官可能问：“观察者和发布订阅区别？” 👉 观察者由目标主动通知，发布订阅通过事件中心解耦。

---

### 2. 单例模式在前端的应用

**一句话回答**
单例模式保证全局唯一实例，常用于全局状态、缓存、日志。

**要点**

- Redux store。
- 全局配置。
- 缓存池。

**详细回答**

```js
class Store {
  static instance;
  static getInstance() {
    if (!Store.instance) Store.instance = new Store();
    return Store.instance;
  }
}
```

**扩展/对比**

- 面试官可能问：“为什么 Store 要用单例？” 👉 保证状态唯一性。

---

### 3. 观察者模式 vs 发布订阅 🔥

**一句话回答**
观察者模式由被观察者直接通知观察者，发布订阅模式通过事件中心转发。

**要点**

- 观察者：目标直接依赖。
- 发布订阅：事件中心解耦。

**详细回答**

- 观察者：Vue2 中 data 改变 → watcher 触发。
- 发布订阅：EventEmitter on/emit。

**扩展/对比**

- 发布订阅更解耦，但多一层事件中心。

---

### 4. 代理模式在前端的应用 🔥

**一句话回答**
代理模式通过代理对象控制访问，常用于数据绑定、拦截、缓存。

**要点**

- Vue3 响应式：Proxy。
- 请求代理：缓存代理。
- 图片懒加载：代理对象。

**详细回答**

```js
const proxy = new Proxy(
  {},
  {
    get: (t, k) => (k in t ? t[k] : 0),
    set: (t, k, v) => {
      t[k] = v;
      return true;
    },
  }
);
```

**扩展/对比**

- 面试官可能问：“为什么 Vue3 用 Proxy 而不是 defineProperty？” 👉 Proxy 能拦截更多操作（delete、in）。

---

## 二、前端架构思想

### 5. 组件化架构 🔥

**一句话回答**
组件化把 UI 拆分为独立模块，提升复用性、可维护性。

**要点**

- 高内聚低耦合。
- 可复用。
- 生命周期隔离。

**详细回答**

- React、Vue 都是典型的组件化框架。
- 组件复用减少代码冗余，便于多人协作。

**扩展/对比**

- 面试官可能问：“如何划分组件？” 👉 按 UI + 功能 + 复用性拆分。

---

### 6. 前端如何做模块化管理

**一句话回答**
通过 ESModule / CommonJS 管理模块，结合 Monorepo 管理多项目依赖。

**要点**

- 模块化：import/export。
- Monorepo：统一依赖。

**详细回答**

- ESModule 提供静态依赖分析。
- Monorepo 常用 pnpm workspace、Turborepo。

**扩展/对比**

- 面试官可能问：“为什么 Monorepo 更适合大公司？” 👉 避免依赖地狱。

---

### 7. 微前端的概念 🔥

**一句话回答**
微前端是把一个大应用拆分成多个独立子应用，按需加载与独立部署。

**要点**

- 独立开发、部署。
- 运行时集成。
- 常见方案：qiankun、Module Federation。

**详细回答**

- qiankun 基于 single-spa，支持多框架共存。
- Webpack Module Federation 支持远程模块加载。

**扩展/对比**

- 面试官可能问：“微前端缺点是什么？” 👉 性能开销、技术栈不一致、样式隔离困难。

---

### 8. 前端监控体系 🔥

**一句话回答**
前端监控包括性能监控、错误监控、埋点分析。

**要点**

- 性能：FCP/LCP/CLS。
- 错误：window\.onerror、Promise rejection。
- 埋点：手动埋点 / 无埋点。

**详细回答**

- 错误上报：Sentry、阿里 ARMS。
- 性能监控：Performance API。

**扩展/对比**

- 面试官可能问：“如何监控 React 报错？” 👉 ErrorBoundary + 日志上报。

---

## 三、团队与工程实践

### 9. 如何设计可扩展的前端架构 🔥

**一句话回答**
通过模块化、组件化、状态管理、CI/CD，保证扩展性与可维护性。

**要点**

- 模块化。
- 状态分层。
- 自动化测试。
- CI/CD 流程。

**详细回答**

- 按业务模块拆分（用户/订单/支付）。
- 公共组件库 + 状态管理。
- 自动化测试保障质量。

**扩展/对比**

- 面试官可能问：“如何防止架构腐化？” 👉 Code Review + Lint 规则 + 文档化。

---

### 10. 前端架构的演进 🔥

**一句话回答**
前端架构经历了：页面拼接 → SPA → 组件化 → 微前端 → RSC/Serverless 驱动的新架构。

**要点**

- 页面拼接：JSP/PHP。
- SPA：前后端分离。
- 组件化：React/Vue。
- 微前端：大规模协作。
- RSC/Serverless：轻前端重服务端。

**详细回答**

- 传统：页面直出，缺乏交互。
- SPA：体验好，但首屏性能差。
- 组件化：复用性、维护性提升。
- 微前端：解决大团队协作问题。
- RSC：减少前端状态管理压力。

**扩展/对比**

- 面试官可能问：“你怎么看待微前端和 RSC 的关系？” 👉 微前端解决团队协作，RSC 解决性能和架构简化。
