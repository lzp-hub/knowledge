# 工程化工具链 & 项目流程面试题

## 一、Git 与协作流程

### 1. Git Flow / GitHub Flow / Trunk-based 开发模型 🔥

**一句话回答**
三种分支模型分别适合不同团队规模：Git Flow（完整流程）、GitHub Flow（轻量）、Trunk-based（现代 DevOps）。

**要点**

- **Git Flow**

  - 分支：`master`（线上）、`develop`（开发）、`feature/*`、`release/*`、`hotfix/*`。
  - 优点：分支职责清晰，适合发布节奏长的大型团队。
  - 缺点：分支过多，协作和合并复杂。

- **GitHub Flow**

  - 分支：`main`（线上稳定）、`feature/*`（开发）→ PR → merge main。
  - 优点：简单、易理解，适合快速迭代。
  - 缺点：对自动化要求高，否则容易把 bug 合入主干。

- **Trunk-based**

  - 所有人直接在 `main`（trunk）提交，每天多次集成。
  - 搭配 **CI/CD + Feature Flag**。
  - 优点：持续交付、减少分支合并冲突。
  - 缺点：要求团队有完善的测试与自动化，开发纪律更高。

**详细回答**

- Git Flow：适合金融、电信等行业的大型项目，版本有严格发布周期。
- GitHub Flow：多见于开源项目、初创团队。
- Trunk-based：Google、Meta 等大厂普遍采用，结合 Feature Toggle 管理未完成的功能。

**扩展/对比**

- 面试官可能问：“你们团队如何管理分支？”
  👉 小团队答 GitHub Flow，强调简单；大公司答 Git Flow 或 Trunk-based，强调自动化和质量保证。
- 常见对比：

  - Git Flow：安全但重。
  - GitHub Flow：快但要靠测试。
  - Trunk-based：现代最佳实践，但团队要有较高工程化水平。

---

### 2. rebase 和 merge 的区别 🔥

**一句话回答**
merge 保留原始分支历史，rebase 改造提交形成线性历史。

**要点**

- merge

  - 会生成一个新的 merge commit。
  - 保留所有分支历史。
  - 历史可能比较杂乱。

- rebase

  - 会移动提交到目标分支顶端。
  - 历史更干净，线性展示。
  - 可能需要解决大量冲突。

**详细回答**

- merge 更安全，适合公共分支（如 `main`）。
- rebase 适合个人分支，PR 前用 rebase squash 压缩 commit，历史整洁。
- 不推荐对已推送的公共分支做 rebase，容易引起冲突和历史错乱。

**扩展/对比**

- 面试官常问：“提 PR 用什么方式？”
  👉 通常 PR 合并时用 **Squash Merge**，把多个 commit 合并成一个，历史干净。
- 经典比喻：

  - merge = “两条河流汇合，保留所有分叉”。
  - rebase = “假装你一直在主干上开发”。

---

### 3. Git 常见命令考点 🔥

**一句话回答**
reset/revert、stash、cherry-pick、reflog 是中高级开发必考命令。

**要点**

- reset：回退版本（改历史）。
- revert：生成新提交，撤销某次修改。
- stash：保存未提交的更改，切分支用。
- cherry-pick：选择特定 commit 合并。
- reflog：找回丢失提交。

**详细回答**

- `git reset --hard`：彻底回退，危险。
- `git revert`：更安全，不破坏历史。
- `git stash save "msg"` → `git stash pop`：保存/恢复现场。
- `git cherry-pick abc123`：将某分支修复快速合入当前分支。
- `git reflog`：追踪 HEAD 历史，常用于恢复误删。

**扩展/对比**

- 面试常问：“误删分支怎么办？”
  👉 用 `git reflog` 找回 commit，再新建分支。
- reset vs revert：reset 改历史，revert 保历史。
- stash vs branch：stash 是临时保存，branch 更适合长期切换。

---

### 4. Git 提交规范 🔥

**一句话回答**
提交信息推荐遵循 Conventional Commits，便于自动生成 changelog 和版本号。

**要点**

- 类型：feat、fix、docs、style、refactor、test、chore。
- 工具链：commitlint、husky、semantic-release。
- 好处：提交语义化，自动化发布。

**详细回答**

- `git commit -m "feat(auth): 增加 token 刷新机制"`
- 搭配 CI，可自动根据 commit 类型生成 CHANGELOG.md、发布新版本号。
- husky 可在 git hook 中强制规范。

**扩展/对比**

- 面试官常问：“你们团队怎么保证 commit 规范？”
  👉 答：commitlint + husky。
- 语义化版本规则：

  - MAJOR：不兼容更新。
  - MINOR：新增功能。
  - PATCH：修复。

---

## 二、包管理器

### 5. npm、yarn、pnpm 的区别 🔥

**一句话回答**
npm 官方，yarn 提升一致性，pnpm 节省磁盘，monorepo 更优。

**要点**

- npm：自带 Node，生态最大。
- yarn：速度更快，解决依赖一致性。
- pnpm：硬链接依赖，磁盘占用小。
- monorepo：pnpm workspace 最适合。

**详细回答**

- npm v5+ 增加 package-lock.json。
- yarn v1 改进性能；yarn berry (v2+) 用 Plug’n’Play（不生成 node_modules）。
- pnpm 用内容寻址存储，多个项目共享依赖，减少重复安装。

**扩展/对比**

- 面试常问：“pnpm 有哪些优势？”
  👉 节省磁盘、依赖安装更快、monorepo 支持最好。
- npm vs yarn vs pnpm：

  - npm：默认、最兼容。
  - yarn：历史上比 npm 快，现在差距缩小。
  - pnpm：现代首选，大厂逐渐迁移。

---

### 6. package-lock.json / yarn.lock / pnpm-lock.yaml 🔥

**一句话回答**
lock 文件保证依赖精确版本一致，避免“我这能跑你那不行”。

**要点**

- 锁定版本号。
- 确保 CI/CD 与本地一致。
- 强制使用 `--frozen-lockfile`。

**详细回答**

- package.json 是版本范围，lock 文件是精确版本。
- CI 中执行 `npm ci` / `pnpm install --frozen-lockfile`，保证依赖不漂移。
- lock 文件必须提交到 Git。

**扩展/对比**

- 面试官常问：“npm install 和 npm ci 区别？”
  👉 npm ci 忽略 package.json，完全依赖 lock 文件，更适合 CI。
- 常见 bug：未提交 lock 文件 → 团队依赖不一致。

---

### 7. Monorepo 管理 🔥

**一句话回答**
Monorepo 把多个项目放在一个仓库，常用 pnpm workspace、Turborepo、Nx 管理。

**要点**

- 优点：共享依赖，统一版本，方便重构。
- 缺点：仓库大，构建速度慢。
- 工具：pnpm workspace、Turborepo（缓存）、Nx（插件多）。

**详细回答**

- 大厂（Google、Meta）喜欢 Monorepo，所有代码一个库。
- CI/CD 用缓存加速（Turborepo/Nx）。
- pnpm workspace 提供轻量 monorepo 方案。

**扩展/对比**

- Monorepo vs Multirepo：

  - Monorepo：依赖一致性好，跨项目改动容易。
  - Multirepo：项目独立，隔离性好。

- 面试常问：“为什么要用 Monorepo？” 👉 统一依赖、减少版本冲突。

---

## 三、Node 环境管理

### 8. nvm 的作用 🔥

**一句话回答**
nvm 管理多个 Node 版本，保证团队环境一致。

**要点**

- 安装/切换 Node。
- `.nvmrc` 固定版本。
- CI/CD 一致性。

**详细回答**

- `nvm install 18` → `nvm use 18`。
- 在项目根目录写 `.nvmrc`：

```
16
```

- 团队成员 `nvm use` 自动切换 Node 版本。

**扩展/对比**

- Windows 用 nvm-windows。
- 面试官常问：“如何避免 Node 版本不一致？”
  👉 用 nvm + `.nvmrc`。

---

## 四、开发与部署流程

### 9. CI/CD 流程 🔥

**一句话回答**
CI/CD 实现自动化构建、测试、部署，避免人工出错。

**要点**

- CI：构建 + 测试。
- CD：自动交付/部署。
- 工具：GitHub Actions、GitLab CI、Jenkins。
- 步骤：Lint → Test → Build → Deploy。

**详细回答**

- 提交代码 → CI 自动触发。
- 执行 ESLint、Jest 单测。
- 打包构建产物。
- 部署到测试/生产环境。

**扩展/对比**

- 面试官常问：“你们如何保证上线质量？”
  👉 CI/CD 流程 + 单测 + 自动化回滚。
- CI/CD 对比手动上线：自动化快、可追溯、出错率低。

---

### 10. 前端项目开发流程 🔥

**一句话回答**
前端开发流程包括需求分析 → 建分支 → 开发编码 → 提交 PR → 测试 → 合并发布。

**要点**

- feature 分支开发。
- PR 审核 → Code Review。
- 合并主干 → CI 自动构建。
- 测试环境 → 生产环境。

**详细回答**

- 需求拆分后，每个功能建立独立分支。
- 开发完成，提交 PR，请团队 Code Review。
- 测试通过后合并到 main/master。
- CI/CD 自动部署上线。

**扩展/对比**

- 面试常问：“如何减少线上 bug？”
  👉 Code Review、单元测试、灰度发布。
- 小团队：可能直接 push main。
- 大团队：强制走 PR + 审核流程。

---

### 11. 版本发布与回滚 🔥

**一句话回答**
版本采用语义化（semver），配合 CI/CD 实现自动发布和回滚。

**要点**

- 版本号：MAJOR.MINOR.PATCH。
- 自动生成 changelog。
- 一键回滚。

**详细回答**

- 使用 `npm version patch` 更新版本号。
- CI 自动打 tag、生成 changelog。
- 出现 bug 时，直接回滚到上一个 tag。

**扩展/对比**

- 面试官常问：“如何保证线上稳定？”
  👉 语义化版本 + 灰度发布 + 快速回滚。
