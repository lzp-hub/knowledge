## 一、基础概念

### 1. 什么是公共状态？哪些场景需要全局状态管理 🔥

**一句话回答**
公共状态是多个组件共享的数据，适合跨层级、跨页面或复杂交互的场景。

**要点**

- 单一数据源。
- 跨组件共享。
- 典型场景：用户信息、主题、购物车。

**详细回答**
React 的局部 state 适合单个组件，跨多个组件时需要“公共状态”。
比如用户登录信息、购物车数据、国际化语言选择，都适合放在全局。

**扩展/对比**

- 面试官常问：“什么时候不需要公共状态？” 👉 数据只被单组件使用时，直接用 useState 即可。

---

### 2. 状态提升 vs Context API

**一句话回答**
状态提升适合小范围共享，Context API 适合跨层级传递。

**要点**

- 状态提升：把 state 提到最近公共父组件。
- Context：避免 props drilling。

**详细回答**

- 状态提升适合两个兄弟组件共享数据。
- Context 适合主题、语言等全局配置。

**扩展/对比**

- 面试官常问：“Context 为什么不适合大规模状态管理？” 👉 因为更新会导致所有消费者重新渲染。

---

### 3. Redux 的核心思想 🔥

**一句话回答**
Redux 基于单一数据源、不可变数据和纯函数 reducer。

**要点**

- 单一数据源。
- state 只读。
- 通过纯函数 reducer 修改。

**详细回答**

```ts
const initial = { count: 0 };
function reducer(state = initial, action) {
  switch (action.type) {
    case "inc":
      return { count: state.count + 1 };
    default:
      return state;
  }
}
```

**扩展/对比**

- 面试官常问：“为什么要不可变数据？” 👉 便于时间旅行调试、性能优化（浅比较）。

---

### 4. Redux Toolkit 的优势

**一句话回答**
RTK 简化了 Redux 模板代码，内置 Immer、Thunk，支持切片化。

**要点**

- `createSlice`。
- 内置 Immer（可写“可变”代码）。
- 内置异步处理（createAsyncThunk）。

**详细回答**

```ts
const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value++;
    },
  },
});
```

**扩展/对比**

- 面试官常问：“RTK 为什么比原生 Redux 好？” 👉 减少模板代码，支持异步更优雅。

---

### 5. MobX 的响应式原理

**一句话回答**
MobX 基于响应式编程，数据变化自动触发依赖更新。

**要点**

- observable 状态。
- computed 派生值。
- autorun 响应。

**详细回答**

```ts
import { makeAutoObservable } from "mobx";
class Store {
  count = 0;
  constructor() {
    makeAutoObservable(this);
  }
  inc() {
    this.count++;
  }
}
```

**扩展/对比**

- MobX 学习曲线低，但调试难度大，不如 Redux 可预测。

---

## 二、现代方案

### 6. Zustand 的特点 🔥

**一句话回答**
Zustand 是轻量级状态库，基于 Hooks，API 简单，无需样板代码。

**要点**

- 无 Provider 嵌套。
- Hooks 风格。
- 轻量且性能好。

**详细回答**

```ts
const useStore = create((set) => ({
  count: 0,
  inc: () => set((s) => ({ count: s.count + 1 })),
}));
function Counter() {
  const { count, inc } = useStore();
  return <button onClick={inc}>{count}</button>;
}
```

**扩展/对比**

- 面试官可能问：“Zustand 和 Redux 区别？” 👉 Redux 偏重，Zustand 轻量。

---

### 7. Recoil 与 Jotai 的“原子化状态”

**一句话回答**
Recoil/Jotai 把状态拆成原子（atom），组件只订阅所需部分。

**要点**

- 原子化。
- 依赖追踪。
- 减少无关重渲染。

**详细回答**

- Recoil：基于原子和选择器，支持派生状态。
- Jotai：Hooks 风格，API 更简洁。

**扩展/对比**

- 面试官常问：“Recoil 为什么性能好？” 👉 因为组件只订阅使用的 atom，不会全局刷新。

---

### 8. React Query 的定位 🔥

**一句话回答**
React Query 管理的是“服务端状态”，解决数据获取、缓存、失效、重试等问题。

**要点**

- 适合 API 数据。
- 自动缓存。
- 支持分页、轮询。

**详细回答**

```ts
const { data, isLoading } = useQuery(["user", id], () => fetchUser(id));
```

**扩展/对比**

- 面试官常问：“React Query 和 Redux 有什么区别？” 👉 Redux 管本地状态，React Query 管远程数据。

---

### 9. 公共状态 vs 服务端状态 🔥

**一句话回答**
公共状态是本地共享数据，服务端状态来自 API，需要缓存与同步机制。

**要点**

- 公共状态：用户信息、UI 状态。
- 服务端状态：接口数据。
- React Query 适合服务端状态。

**详细回答**

- 公共状态不需要和后端频繁同步。
- 服务端状态有缓存、失效、并发更新等问题。

**扩展/对比**

- 面试官常问：“什么时候用 React Query？” 👉 只要涉及 API 请求，都比手写 useEffect 更优。

---

### 10. Next.js App Router 对状态管理的影响

**一句话回答**
App Router 引入 Server Components，减少了前端公共状态需求。

**要点**

- Server Components 默认获取数据。
- 公共状态更多用于 UI 层。
- React Query / Zustand 依旧常用。

**详细回答**

- RSC 把数据获取放到服务端，减少客户端状态。
- 但客户端 UI 状态（表单、购物车）依旧需要本地管理。

**扩展/对比**

- 面试官可能问：“RSC 会取代状态管理库吗？” 👉 不会，只是降低了使用场景。

---

## 三、工程实践

### 11. 什么时候用 Context，什么时候用状态库 🔥

**一句话回答**
少量全局配置用 Context，大规模复杂状态用库。

**要点**

- Context：轻量，适合主题/语言。
- Redux/Zustand：复杂应用。

**详细回答**

- Context 更新会导致所有消费者重渲染。
- 状态库通过订阅避免无关刷新。

**扩展/对比**

- 面试官可能问：“为什么不全用 Context？” 👉 性能问题。

---

### 12. Redux 为什么强调不可变数据

**一句话回答**
不可变数据便于调试、优化性能和时间旅行。

**要点**

- 浅比较。
- 可追踪。
- 支持时间旅行调试。

**详细回答**

- Redux 依赖浅比较来决定组件是否更新。
- Immer 内置在 RTK，简化不可变写法。

**扩展/对比**

- 面试官常问：“如果直接修改 state 会怎样？” 👉 UI 不更新或数据错乱。

---

### 13. 状态管理与性能优化 🔥

**一句话回答**
状态库通过订阅和分片，避免全局刷新，提高性能。

**要点**

- Context → 全部刷新。
- Redux → 按 mapStateToProps。
- Zustand → 按 selector 订阅。

**详细回答**

- 状态拆分是优化关键。
- Zustand 允许选择性订阅字段，避免大组件无关刷新。

**扩展/对比**

- 面试官可能问：“Zustand 为什么性能好？” 👉 因为订阅粒度细。

---

### 14. 状态切片（Slice）的设计 🔥

**一句话回答**
Slice 是按业务模块拆分状态，避免单一 store 过于庞大。

**要点**

- 模块化。
- 单独 reducer。
- 独立 action。

**详细回答**

```ts
const userSlice = createSlice({
  name: "user",
  initialState: { name: "" },
  reducers: {
    setName: (s, a) => {
      s.name = a.payload;
    },
  },
});
```

**扩展/对比**

- 面试官可能问：“为什么要切片化？” 👉 降低复杂度，方便多人协作。

---

### 15. 公共状态在多人协作项目中的最佳实践

**一句话回答**
通过模块化、约定规范、类型约束，避免状态混乱。

**要点**

- 按模块拆分。
- 类型定义。
- 持久化。

**详细回答**

- TS 定义 State 类型，避免随意扩展。
- 公共状态持久化到 localStorage/IndexedDB。

**扩展/对比**

- 面试官可能问：“怎么防止状态污染？” 👉 Code Review + 统一规范。

---

## 四、进阶与原理

### 16. Redux 中间件机制 🔥

**一句话回答**
Redux 中间件是函数链，用来扩展 dispatch。

**要点**

- 类似 Koa 洋葱模型。
- thunk/saga/observable。

**详细回答**

```ts
const logger = (store) => (next) => (action) => {
  console.log(action);
  return next(action);
};
```

**扩展/对比**

- thunk 处理异步，saga 用 generator。

---

### 17. React Query 的缓存 & 失效机制

**一句话回答**
React Query 自动缓存 API 数据，并基于失效策略重新获取。

**要点**

- staleTime：数据过期时间。
- cacheTime：缓存保留时间。
- refetchOnWindowFocus。

**详细回答**

```ts
useQuery(["todos"], fetchTodos, { staleTime: 5000, cacheTime: 60000 });
```

**扩展/对比**

- 面试官常问：“React Query 和浏览器缓存区别？” 👉 React Query 在内存中缓存，生命周期更灵活。

---

### 18. Zustand 内部原理

**一句话回答**
Zustand 基于订阅模式，每个 selector 订阅独立状态。

**要点**

- setState。
- 订阅/取消订阅。
- Proxy 或 getter。

**详细回答**

- Zustand 维护一个全局 store。
- 每个组件订阅需要的 state，变更时只通知相关组件。

**扩展/对比**

- 面试官可能问：“为什么 Zustand 不需要 Provider？” 👉 它用单例 store，天然全局可用。

---

### 19. 状态持久化 🔥

**一句话回答**
通过存储层 (localStorage / IndexedDB) 保存状态，实现刷新后恢复。

**要点**

- Zustand persist 插件。
- Redux-persist。
- IndexedDB 存大数据。

**详细回答**

```ts
const useStore = create(
  persist(
    (set) => ({ count: 0, inc: () => set((s) => ({ count: s.count + 1 })) }),
    { name: "counter" }
  )
);
```

**扩展/对比**

- 面试官常问：“localStorage 和 IndexedDB 区别？” 👉 IndexedDB 适合大数据。

---

### 20. 状态管理的发展趋势

**一句话回答**
随着 RSC 和边缘计算发展，前端状态管理更轻量化，本地状态减少，更多交由服务端。

**要点**

- RSC 降低公共状态需求。
- React Query 成为主流服务端状态管理。
- 客户端状态库依然需要（UI/交互）。

**详细回答**

- 公共状态管理从 Redux → RTK → Zustand → React Query。
- 趋势是本地状态轻量化，远程状态交由专门工具。

**扩展/对比**

- 面试官可能问：“未来 Redux 还会流行吗？” 👉 在大型项目依然会用，但轻量项目更倾向 Zustand/Query。
