# 跨域

## 一、什么是跨域？

### 1. 什么是同源策略及其限制内容？

同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 XSS、CSRF 等攻击。所谓同源是指"**协议+域名+端口**"三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/23/1638b3579d9eeb32~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

**同源策略限制内容有：**

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM 节点
- AJAX 请求发送后，结果被浏览器拦截了

但是有三个标签是允许跨域加载资源：

- `<img src=XXX>`
- `<link href=XXX>`
- `<script src=XXX>`

### 2. 常见跨域场景

当**协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域**。不同域之间相互请求资源，就算作“跨域”。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/23/1638b3579dde630e~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

特别说明两点：

- 第一：如果是协议和端口造成的跨域问题“后端”是无能为力的。
- 第二：在跨域问题上，仅仅是通过“URL 的首部”来识别而不会根据域名对应的 IP 地址是否相同来判断。**“URL 的首部”可以理解为“协议, 域名和端口必须匹配”。**

**跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。**你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。

## 二、跨域解决方案

### JSONP

原理利用 `<script>` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。**JSONP 请求一定需要对方的服务器做支持才可以。**

- 好处：简单兼容性好，可以向老浏览器或不支持 CORS 的网站请求数据
- 缺点：仅支持**get**方法具有局限性,不安全可能会遭受**XSS**攻击。

**JSONP 的实现流程**

1. **声明一个回调函数，其函数名(如 show)当做参数值**，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data)。
2. **创建一个`<script>`**标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服务器传递该函数名（可以通过**问号传参:?callback=show**）。
3. **服务器**接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成**一个字符串**,例如：传递进去的函数名是 show，它准备好的数据是`show('我不爱你')`。
4. 最后服务器把准备的数据通过 HTTP 协议返回给客户端，**客户端再调用执行之前声明的回调函数（show）**，对返回的数据进行操作。

在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP 函数。

```js
// index.html
function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) => {
    let script = document.createElement("script");
    window[callback] = function (data) {
      resolve(data);
      document.body.removeChild(script);
    };
    params = { ...params, callback }; // wd=b&callback=show
    let arrs = [];
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`);
    }
    script.src = `${url}?${arrs.join("&")}`;
    document.body.appendChild(script);
  });
}

jsonp({
  url: "http://localhost:3000/say",
  params: { wd: "Iloveyou" },
  callback: "show",
}).then((data) => {
  console.log(data);
});
```

上面这段代码相当于向`http://localhost:3000/say?wd=Iloveyou&callback=show`这个地址请求数据，然后后台返回`show('我不爱你')`，最后会运行 show()这个函数，打印出'我不爱你'

```javascript
// server.js
const express = require("express");
const app = express();

app.get("/say", function (req, res) {
  const { wd, callback } = req.query;
  console.log(wd); // Iloveyou
  console.log(callback); // show

  // 返回 JSONP 格式的响应
  res.end(`${callback}('我不爱你')`);
});

app.listen(3000, () => {
  console.log("JSONP server running on port 3000");
});
```

---

### proxy(node 中间代理)

webpack proxy 即`webpack`提供的代理服务。基本行为就是接收客户端发送的请求后转发给其他服务器

其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）

想要实现代理首先需要一个中间服务器，`webpack`中提供服务器的工具为`webpack-dev-server`

**webpack-dev-server**

`webpack-dev-server`是 `webpack` 官方推出的一款开发工具，将**自动编译和自动刷新浏览器等一系列**对开发友好的功能全部集成在了一起。目的是为了提高开发者日常的开发效率，**只适用在开发阶段**，

`devServetr`里面`proxy`则是关于代理的配置，该**属性为对象**的形式，对象中**每一个属性**就是一个代理的规则匹配，即可以配置**多个代理**。

**属性的名称是需要被代理的请求路径前缀**，一般为了辨别都会设置前缀为` /api`，**值**为对应的代理匹配规则，对应如下：

- target：表示的是代理到的目标地址
- changeOrigin：是否代理跨域
- pathRewrite：默认情况下，我们的 /api 也会被写入到 URL 中，如果希望删除，可以使用 pathRewrite
- secure：默认情况下不接收转发到 https 的服务器上，如果希望支持，可以设置为 false

我们可以通过`webpack`为我们起一个本地服务器作为请求的代理对象，通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是**最终发布上线时如果 web 应用和接口服务器不在一起仍会跨域**

- 如果是通过自定义，可通过`webpack.config.js`配置文件，新增以下代码

```javascript
const path = require("path");

module.exports = {
  // 中间服务器，记得去package.json配置启动服务器的运行命令脚本：webpack-dev-server
  // ...
  devServer: {
    static: {
      directory: path.join(__dirname, "./public"), // 配置服务器根目录
    },
    port: 8888, // 默认是 8080
    host: "localhost", // 主机名，本地：localhost 127.0.0.1，真机 0.0.0.0
    https: false, // 协议
    open: true, // 项目启动时自动打开浏览器

    proxy: {
      // '/api'是被代理请求路径前缀标识，用于告诉node，url前面是/api的就是使用代理的
      "/sinaapi": {
        target: "https://m.weibo.cn", // 代理到的目标地址，一般是指后台服务器地址
        changeOrigin: true, // 是否代理跨域
        pathRewrite: {
          "^/sinaapi": "", // pathRewrite 的作用是把实际Request Url中的'/api'用""代替
        },
        // 可选：添加日志
        logLevel: "debug",
      },
    },
  },
};

request.get("http://localhost:9900/sinaapi/api/config/list");
// 最后会实现 https://m.weibo.cn/api/config/list
```

可以配合`axios`进行请求，配置**baseURL**请求的根路径，于 proxy 的路径代理标识相同

```javascript
import axios from "axios";

const request = axios.create({
  // 根据不同环境设置 baseURL, 最终发送请求时的URL为: baseURL + 发送请求时写URL
  // 比如 get('/test'), 最终发送请求是: /api/test
  baseURL: "/api",
  timeout: 5000, // 请求超时
  // 可选：添加请求拦截器
  headers: {
    "Content-Type": "application/json",
  },
});

// 请求拦截器
request.interceptors.request.use(
  (config) => {
    // 可以在这里添加 token 等
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 响应拦截器
request.interceptors.response.use(
  (response) => {
    return response.data;
  },
  (error) => {
    return Promise.reject(error);
  }
);

export default request;
```

**`proxy`工作原理实质上是利用`http-proxy-middleware` 这个`http`代理中间件，实现请求转发给其他服务器**

**服务端实现代理请求转发**

在开发阶段，本地地址为`http://localhost:3000`，该浏览器发送一个前缀带有`/api`标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中

```javascript
const express = require("express");
const { createProxyMiddleware } = require("http-proxy-middleware");

const app = express();

// 使用新的 API
app.use(
  "/api",
  createProxyMiddleware({
    target: "http://www.example.org",
    changeOrigin: true,
    // 可选：添加日志
    logLevel: "debug",
  })
);

app.listen(3000, () => {
  console.log("Proxy server running on port 3000");
});

// http://localhost:3000/api/foo/bar -> http://www.example.org/api/foo/bar
```

**服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制**

---

### **CORS**

Cross-origin resource sharing（跨来源资源共享）通信过程都是浏览器自动完成，需要浏览器(都支持)和服务器都支持，所以关键在**只要服务器支持，就可以跨域通信**

浏览器将跨域请求分为两类：**简单请求和非简单请求**。

同时满足以下两大条件的，就属于简单请求：

- 请求方法是以下 3 种之一：

  - GET
  - POST
  - HEAD

- HTTP 头信息**不超出**以下字段：

  - Accept

  - Accept-Language

  - Content-Language

  - Last-Event-ID

  - Content-Type：值为三者之一： application/x-www-form-urlencoded、multipart/form-data、text/plain

    - application/x-www-form-urlencoded 作为表单提交中默认的类型，其表明数据以标准的编码格式被编码为键值对。 数据被编码成以 '&' 分隔的键-值对, 同时以 '=' 分隔键和值

    - multipart/form-data：一般用于涉及文件的表单提交，用于 post 请求

    - text/plain：文本

需要这些条件是为了兼容表单，因为历史上表单一直可以跨域

凡是不满足以上条件的，就属于**非简单请求**。如我们常用的 json 格式请求，由于其 Content-Type 的值为 application/json，因此属于非简单请求。

对于这两种请求，浏览器的处理方式是不一样的

**简单请求跨域**

浏览器采用先请求后判断的方式，即浏览器直接发出 CORS 请求，即在**请求头中增加 Origin**字段，表示请求来源来自哪个域(协议+域名+端口)，**服务器根据这个值决定是否同意请求**。

服务器即使判断该源如果不在自己允许的范围内，也会返回一个正常的 HTTP 响应。此时**浏览器判断响应头中是否包含 Access-Control-Allow-Origin**字段，如果没有，浏览器就知道当前服务器是跨域访问的，就会抛出错误。

如果 Origin 在服务器允许的范围内，服务器的 HTTP**响应**中，就会包含如下字段：

- Access-Control-Allow-Origin：它的值要么是请求时 Origin 字段的值，要么是一个\*（表示接受任意域名的请求）。

- Access-Control-Allow-Credentials：它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为 true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。

- Access-Control-Allow-Headers：允许浏览器在 CORS 中发送的头信息。

- Access-Control-Allow-Methods：允许浏览器在 CORS 中使用的方法。

快速记忆：前缀是 Access-Control-Allow- + Origin，Credentials，Headers，Methods，

**因此在简单请求中服务器至少需要设置：`Access-Control-Allow-Origin` 字段才可跨域**

**非简单请求跨域**

比如 PUT 或 DELETE 请求，或 Content-Type 为 application/json 等等 ，就是非简单请求。

非简单请求，**正式请求前会发一次 OPTIONS 类型的查询请求**，称为`预检请求`，询问服务器是否支持网页所在域名的请求，以及可以使用哪些头信息字段。**只有收到肯定的答复，才会发起正式 XMLHttpRequest 请求，否则报错**

预检**请求**的方法是**OPTIONS**，它的**请求头**信息中有几个字段

- **Access-Control-Allow-Origin**: 表示请求来自哪个域，这个字段是必须的
- **Access-Control-Request-Method**：列出 CORS 请求会用到哪些 HTTP 方法，这个字段是必须的
- **Access-Control-Request-Headers**： 指定 CORS 请求会额外发送的头信息字段，用逗号隔开

**OPTIONS 请求**次数过多也会损耗性能，所以要尽量减少 OPTIONS 请求，这时可以让服务器在**响应头**部**添加 Access-Control-Max-Age，表示预检请求的返回结果可以被缓存多久，在这个时间范围内再请求就不需要预检了。不过这个缓存**只对完全一样的 URL 才会生效\*\*

```css
access-control-max-age: // 数字 单位是秒，例如：3600，即允许缓存该条回应3600秒;;
```

---

CORS 请求**默认不包含 Cookie 以及 HTTP 认证信息**，如果需要包含 Cookie，需要满足几个条件：

1. 前端请求时在`request`对象中配置`"withCredentials": true`；
2. 服务端在`response`的`header`中配置`"Access-Control-Allow-Credentials", "true"`
3. 服务端在`response`的`header`中配置 `Access-Control-Allow-Origin不要设为*星号`，指定明确的与请求网页一致的域名，这样才不会把其他域名的 Cookie 上传
4. Set-Cookie: **SameSite**=None; Secure

**跨域时怎么处理 cookie？**

1. 前端请求时在`request`对象中配置`"withCredentials": true`；

   **XMLHttpRequest.withCredentials** 属性是一个[`Boolean`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FBoolean)类型，它指示了是否该使用类似 cookies,authorization headers(头部授权)或者 TLS 客户端证书这一类资格证书来创建一个跨站点访问控制（cross-site `Access-Control`）请求。在同一个站点下使用`withCredentials属性是无效的。`

   如果在发送来自其他域的 XMLHttpRequest 请求之前，未设置`withCredentials` 为 true，那么就不能为它自己的域设置 cookie 值。**而通过设置`withCredentials` 为 true 获得的第三方 cookies，将会依旧享受同源策略，因此不能被通过 document.cookie 或者从头部相应请求的脚本等访问。**

```javascript
// axios 方式
axios({
  withCredentials: true, // 允许携带 cookie
  method: "get",
  url: "http://localhost:8003/anotherService",
})
  .then((res) => {
    console.log(res);
  })
  .catch((error) => {
    console.error("请求失败:", error);
  });

// 原生 xhr 方式
const xhr = new XMLHttpRequest();
const url = "http://bar.other/resources/credentialed-content/";

function callXhr() {
  if (xhr) {
    xhr.open("GET", url, true);
    xhr.withCredentials = true; // 带上 cookie
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          console.log(xhr.responseText);
        } else {
          console.error("请求失败:", xhr.status);
        }
      }
    };
    xhr.send();
  }
}
```

2. 服务端在`response`的`header`中配置`"Access-Control-Allow-Credentials", "true"`

3. 服务端在`response`的`header`中配置`"Access-Control-Allow-Origin", "http://xxx:${port}"`;

```javascript
// Express 中间件配置
app.all("*", (req, res, next) => {
  res.header("Access-Control-Allow-Origin", "http://localhost:3000"); // 不要设为*星号，指定明确的域名
  res.header("Access-Control-Allow-Credentials", "true"); // 允许携带凭证
  res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
  res.header("Access-Control-Allow-Headers", "Content-Type, Authorization");
  next();
});

// 或者使用 cors 中间件
const cors = require("cors");
app.use(
  cors({
    origin: "http://localhost:3000",
    credentials: true,
  })
);
```

4. set-cookie 时将 cookie 的 sameSite 设置为 none；由于将 sameSite 设置为 none 时，此时也要将 Secure 设置上，因为 Cookie 只能通过 HTTPS 协议发送;

   SameSite 属性可用来**限制第三方 Cookie** 。有三个值：

   - `strict`：严格模式，完全禁止使用 Cookie
   - `lax`：宽松模式，允许部分情况使用 Cookie，`跨域的都行`，a 标签跳转，link 标签，GET 提交的表单
   - `none`：任何情况下都会发送 Cookie，但必须同时设置 Secure 属性，意思是需要安全上下文，Cookie `只能通过https发送`，否则无效。Chrome 80 之前默认值是 none，之后是 lax。不过在最新的 `Chrome91` 版本中这个`已经被移除`了，所以在 91 之前的版本依然可以使用

```javascript
// 设置 Cookie 的 SameSite 属性
response.setHeader(
  "Set-Cookie",
  "sessionId=abc123; HttpOnly; Secure; SameSite=None"
);

// 或者使用 Express 的 cookie 中间件
const cookieParser = require("cookie-parser");
app.use(cookieParser());

app.get("/set-cookie", (req, res) => {
  res.cookie("sessionId", "abc123", {
    httpOnly: true,
    secure: true,
    sameSite: "none",
  });
  res.send("Cookie set");
});
```

---

### postMessage

postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的 iframe 消息传递
- 上面三个场景的跨域数据传递

**postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递**。

```javascript
otherWindow.postMessage(message, targetOrigin, [transfer]);
```

- message:：将要发送到其他 window 的数据。
- targetOrigin：通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串"\*"（表示任意窗口）或者一个 URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。
- transfer(可选)：是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

接下来我们看个例子： `http://localhost:3000/a.html`页面向`http://localhost:4000/b.html`传递“我爱你”,然后后者传回"我不爱你"。

```html
<!-- a.html -->
<iframe
  src="http://localhost:4000/b.html"
  frameborder="0"
  id="frame"
  onload="load()"
></iframe>
<!-- 等它加载完触发一个事件，内嵌在 http://localhost:3000/a.html -->
<script>
  function load() {
    const frame = document.getElementById("frame");
    // 发送数据
    frame.contentWindow.postMessage("我爱你", "http://localhost:4000");

    // 接收返回数据
    window.onmessage = function (e) {
      console.log(e.data); // 我不爱你
    };
  }
</script>
```

```html
<!-- b.html -->
<script>
  window.onmessage = function (e) {
    console.log(e.data); // 我爱你

    // 验证来源并回复
    if (e.origin === "http://localhost:3000") {
      e.source.postMessage("我不爱你", e.origin);
    }
  };
</script>
```

---

### WebSocket

WebSocket 是 HTML5 标准中的一种通信协议，以`ws://`(非加密)和`wss://`(加密)作为协议前缀，该协议不实行同源政策，只要服务器支持就行。因为 WebSocket 请求头信息中有 Origin 字段，表示请求源来自哪个域，服务器可以根据这个字段判断是否允许本次通信，如果在白名单内，就可以通信

Websocket 是 HTML5 的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 **WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据**。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

原生 WebSocket API 使用起来不太方便，我们使用`Socket.io`，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。

我们先来看个例子：本地文件 socket.html 向`localhost:3000`发生数据和接受数据

```html
<!-- socket.html -->
<script>
  const socket = new WebSocket("ws://localhost:3000");

  socket.onopen = function () {
    console.log("WebSocket 连接已建立");
    socket.send("我爱你"); // 向服务器发送数据
  };

  socket.onmessage = function (e) {
    console.log("收到服务器消息:", e.data); // 接收服务器返回的数据
  };

  socket.onclose = function () {
    console.log("WebSocket 连接已关闭");
  };

  socket.onerror = function (error) {
    console.error("WebSocket 错误:", error);
  };
</script>
```

```javascript
// server.js
const express = require("express");
const WebSocket = require("ws"); // 记得安装 ws

const app = express();
const wss = new WebSocket.Server({ port: 3000 });

wss.on("connection", function (ws) {
  console.log("新的 WebSocket 连接");

  ws.on("message", function (data) {
    console.log("收到客户端消息:", data);
    ws.send("我不爱你"); // 回复客户端
  });

  ws.on("close", function () {
    console.log("WebSocket 连接已关闭");
  });
});

app.listen(8080, () => {
  console.log("HTTP 服务器运行在端口 8080");
  console.log("WebSocket 服务器运行在端口 3000");
});
```

### nginx 反向代理

nginx 反向代理是解决跨域问题的另一种有效方案，通过 nginx 服务器作为中间代理，将前端请求转发到后端服务器。

**工作原理：**

1. 前端请求发送到 nginx 服务器（同源）
2. nginx 将请求转发到目标后端服务器
3. 后端服务器响应给 nginx
4. nginx 将响应返回给前端

**nginx 配置示例：**

```nginx
server {
    listen 80;
    server_name localhost;

    # 前端静态资源
    location / {
        root /usr/share/nginx/html;
        index index.html index.htm;
        try_files $uri $uri/ /index.html;
    }

    # API 代理配置
    location /api/ {
        # 代理到后端服务器
        proxy_pass http://backend-server:8080/;

        # 设置代理请求头
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # 跨域配置
        add_header Access-Control-Allow-Origin *;
        add_header Access-Control-Allow-Methods 'GET, POST, PUT, DELETE, OPTIONS';
        add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';

        # 处理预检请求
        if ($request_method = 'OPTIONS') {
            return 204;
        }
    }
}
```

**优势：**

- 性能好，nginx 处理静态资源效率高
- 配置灵活，可以处理复杂的路由规则
- 支持负载均衡
- 生产环境常用方案

**适用场景：**

- 生产环境部署
- 需要负载均衡的场景
- 静态资源和 API 需要统一管理的项目

---

### document.domain

document.domain 主要用于解决**主域相同，子域不同**的跨域问题。

**适用场景：**

- `www.example.com` 和 `api.example.com`
- `a.example.com` 和 `b.example.com`

**实现原理：**
通过设置 `document.domain` 为相同的主域名，让浏览器认为这两个页面属于同一个域。

**实现步骤：**

1. **在两个页面都设置相同的 domain：**

```html
<!-- 页面 a.example.com -->
<script>
  document.domain = "example.com";
</script>

<!-- 页面 b.example.com -->
<script>
  document.domain = "example.com";
</script>
```

2. **通过 iframe 进行通信：**

```html
<!-- 父页面 a.example.com -->
<iframe id="iframe" src="http://b.example.com/b.html"></iframe>
<script>
  document.domain = "example.com";
  const iframe = document.getElementById("iframe");
  iframe.onload = function () {
    // 现在可以访问 iframe 的内容
    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
    console.log(iframeDoc.body.innerHTML);

    // 也可以调用 iframe 中的函数
    iframe.contentWindow.someFunction();
  };
</script>
```

```html
<!-- 子页面 b.example.com -->
<script>
  document.domain = "example.com";

  // 定义可以被父页面调用的函数
  function someFunction() {
    return "Hello from iframe!";
  }

  // 也可以访问父页面的内容
  function accessParent() {
    const parentDoc = window.parent.document;
    console.log(parentDoc.title);
  }
</script>
```

**限制条件：**

- 只能用于主域相同，子域不同的情况
- 两个页面都必须设置相同的 `document.domain`
- 只能设置为当前域或其父域
- 一旦设置，不能撤销

**注意事项：**

- 现代浏览器对 document.domain 的限制越来越严格
- 不推荐在新项目中使用，建议使用 postMessage 替代

---

### window.name

window.name 是一个特殊的属性，它有一个特性：**在同一个窗口（或标签页）中，即使页面跳转到不同的域，window.name 的值依然保持不变**。

**实现原理：**

1. 在页面 A 中设置 `window.name = data`
2. 页面跳转到页面 B（可以是不同域）
3. 在页面 B 中仍然可以读取到 `window.name` 的值

**实现步骤：**

```html
<!-- 页面 A (http://a.example.com) -->
<script>
  // 要传递的数据
  const data = JSON.stringify({
    name: "张三",
    age: 25,
    message: "Hello from page A",
  });

  // 设置 window.name
  window.name = data;

  // 跳转到页面 B
  window.location.href = "http://b.example.com/b.html";
</script>
```

```html
<!-- 页面 B (http://b.example.com) -->
<script>
  // 读取传递过来的数据
  const receivedData = JSON.parse(window.name);
  console.log(receivedData); // { name: '张三', age: 25, message: 'Hello from page A' }

  // 处理数据
  document.getElementById(
    "result"
  ).innerHTML = `姓名: ${receivedData.name}, 年龄: ${receivedData.age}, 消息: ${receivedData.message}`;
</script>
```

**更复杂的实现（通过 iframe 中转）：**

```html
<!-- 主页面 -->
<iframe id="proxy" src="about:blank" style="display:none;"></iframe>
<script>
  const iframe = document.getElementById("proxy");
  let isFirstLoad = true;

  iframe.onload = function () {
    if (isFirstLoad) {
      // 第一次加载，设置数据并跳转到目标页面
      iframe.contentWindow.name = JSON.stringify({
        token: "abc123",
        userInfo: { id: 1, name: "用户" },
      });
      iframe.src = "http://target-domain.com/target.html";
      isFirstLoad = false;
    } else {
      // 第二次加载，读取数据
      const data = JSON.parse(iframe.contentWindow.name);
      console.log("接收到的数据:", data);

      // 清理 iframe
      document.body.removeChild(iframe);
    }
  };
</script>
```

**优势：**

- 可以传递大量数据（最大约 2MB）
- 兼容性好，支持所有浏览器
- 实现相对简单

**缺点：**

- 只能传递字符串数据
- 需要页面跳转，用户体验不好
- 现代浏览器有安全限制
- 不推荐在新项目中使用

**注意事项：**

- 现代浏览器对 window.name 有安全限制
- 建议使用 postMessage 或 CORS 替代
- 主要用于历史遗留项目的兼容

---

## 三、跨域解决方案选择指南

### 不同场景的最佳实践

| 场景            | 推荐方案                   | 原因                           |
| --------------- | -------------------------- | ------------------------------ |
| **开发环境**    | webpack proxy / vite proxy | 配置简单，热更新支持好         |
| **生产环境**    | nginx 反向代理             | 性能好，配置灵活，支持负载均衡 |
| **前后端分离**  | CORS                       | 标准方案，浏览器原生支持       |
| **第三方 API**  | JSONP（仅 GET）            | 兼容老浏览器，无需后端支持     |
| **iframe 通信** | postMessage                | 安全可靠，功能强大             |
| **实时通信**    | WebSocket                  | 双向通信，性能好               |
| **子域通信**    | document.domain            | 简单直接（不推荐新项目）       |

### 安全考虑

**1. CORS 安全配置：**

```javascript
// 不安全的配置
app.use(
  cors({
    origin: "*", // 允许所有域名
    credentials: true,
  })
);

// 安全的配置
app.use(
  cors({
    origin: ["https://yourdomain.com", "https://app.yourdomain.com"],
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE"],
    allowedHeaders: ["Content-Type", "Authorization"],
  })
);
```

**2. 代理安全：**

```nginx
# nginx 代理安全配置
location /api/ {
    # 限制请求方法
    limit_except GET POST {
        deny all;
    }

    # 限制请求大小
    client_max_body_size 10M;

    # 隐藏后端服务器信息
    proxy_hide_header X-Powered-By;
    proxy_hide_header Server;

    proxy_pass http://backend;
}
```

### 性能优化建议

**1. 减少预检请求：**

```javascript
// 设置预检请求缓存时间
app.use(
  cors({
    origin: true,
    maxAge: 86400, // 24小时
  })
);
```

**2. 代理缓存：**

```nginx
# nginx 代理缓存
location /api/ {
    proxy_cache api_cache;
    proxy_cache_valid 200 1h;
    proxy_cache_key $scheme$proxy_host$request_uri;

    proxy_pass http://backend;
}
```

### 常见问题解决

**1. Cookie 跨域问题：**

```javascript
// 前端
axios.defaults.withCredentials = true;

// 后端
app.use(
  cors({
    origin: "https://yourdomain.com",
    credentials: true,
  })
);
```

**2. 预检请求失败：**

```javascript
// 确保 OPTIONS 请求被正确处理
app.options("*", cors());
```

**3. 代理路径重写：**

```javascript
// webpack proxy
proxy: {
    '/api': {
        target: 'http://localhost:3000',
        pathRewrite: {
            '^/api': '' // 移除 /api 前缀
        }
    }
}
```

### 调试技巧

**1. 浏览器开发者工具：**

- Network 面板查看请求头
- Console 面板查看错误信息
- Application 面板检查 Cookie

**2. 常用调试命令：**

```bash
# 检查 CORS 头
curl -H "Origin: http://localhost:3000" \
     -H "Access-Control-Request-Method: POST" \
     -H "Access-Control-Request-Headers: X-Requested-With" \
     -X OPTIONS \
     http://api.example.com/data

# 测试代理
curl http://localhost:8080/api/users
```

### 总结

选择跨域解决方案时，应该考虑：

1. **开发阶段**：优先使用开发工具代理（webpack proxy、vite proxy）
2. **生产环境**：推荐 nginx 反向代理或 CORS
3. **安全性**：避免使用 `*` 通配符，明确指定允许的域名
4. **性能**：合理设置缓存，减少不必要的预检请求
5. **兼容性**：考虑目标用户使用的浏览器版本

现代前端开发中，**CORS + nginx 反向代理** 是最常用和推荐的组合方案。
