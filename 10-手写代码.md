# 手写代码

### 实现原生的 AJAX 请求

```js
const ajax = {
  get(url, data, fn) {
    //	兼容IE7 之前
    const xhr = !!window.XMLHttpRequest
      ? new XMLHttpRequest()
      : new ActiveXObject("Microsoft.XMLHttp");
    // const xhr = new XMLHttpRequest();
    const dataArr = [];
    for (let key in data) {
      dataArr.push(`${key}=${data[key]}`);
    }
    xhr.open(
      "GET",
      `${url}${!!dataArr.length ? "?" : ""}${dataArr.join("&")}`,
      true
    );
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        fn(xhr.responseText);
      }
    };
    xhr.send();
  },
  post(url, data, fn) {
    const xhr = new XMLHttpRequest();
    const dataArr = [];
    for (let key in data) {
      dataArr.push(`${key}=${data[key]}`);
    }
    xhr.open("POST", url, true);
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        fn(xhr.responseText);
      }
    };
    xhr.send(dataArr.join("&"));
  },
};
```

---

### JavaScript 深入之从原型到原型链

**构造函数、实例原型、和实例之间的关系**

每个函数都有一个 **prototype** 属性，指向了一个对象，这个对象正是调用该构造函数而创建的**实例**的原型，也就是这个例子中的 person

```js
function Person() {}
var person = new Person();

// 实例与实例原型
console.log(person.__proto__ === Person.prototype); // true
// 顺便学习一个ES5的方法,可以获得对象的原型
console.log(Object.getPrototypeOf(person) === Person.prototype); // true
// 每个原型都有一个 constructor 属性指向关联的构造函数
console.log(Person.prototype.constructor === Person); // true
```

**实例与原型**

当读取**实例的属性**时，如果找不到，就会查找**与对象关联的原型**中的属性，如果还查不到，就去找**原型的原型**，一直找到最顶层为止。

```js
function Person() {}

Person.prototype.name = "Kevin";

var person = new Person();

person.name = "Daisy";
console.log(person.name); // Daisy

delete person.name;
console.log(person.name); // Kevi
```

在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。

但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 `person.__proto__` ，也就是 Person.prototype 中查找，幸运的是我们找到了 name 属性，结果为 Kevin。

但是万一还没有找到呢？原型的原型又是什么呢? 在这里是

```js
console.log(Person.prototype.__proto__ === Object.prototype); // true
// 或者
console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype);
```

那 Object.prototype 的原型呢？

```js
console.log(Object.prototype.__proto__ === null); // true
// 或者
console.log(Object.getPrototypeOf(Object.prototype) === null);
```

**查找属性的时候查到 Object.prototype 就可以停止查找了**

原型组成的链状结构就是原型链，比如：person >>> Person.prototype >>> Object.prototype >>> null

---

### 手写 new 的过程

new 关键字内部干了如下 4 件事

> 1. 首先创一个新的空对象。
> 2. 根据原型链，设置空对象的 `__proto__` 为构造函数的 `prototype` 。
> 3. 构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。
> 4. 判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。

- 方式 1，使用 `__proto__`

```js
const MyNew = function (fn) {
  const obj = new Object();
  obj.__proto__ = fn.prototype;
  const result = fn.apply(obj, Array.prototype.slice.call(arguments, 1));
  return result instanceof Object ? result : obj;
};
```

- 方式 2，**Object.setPrototypeOf**（现有对象,原型对象 ) 为现有对象设置原型，返回一个新对象。

```js
function myNew(fn) {
  const obj = new Object();
  Object.setPrototypeOf(obj, fn.prototype);
  const result = fn.apply(obj, [...arguments].slice(1));
  return result instanceof Object ? result : obj;
}
```

---

### 手写 Instanceof 的过程

Instanceof 实现原理是通过原型链判断的，在 instanceof 左侧对象的原型链上找到等于右侧原型对象

- 方式 1，使用 `__proto__`

```js
function myInstanceof(obj, Fn) {
  // 获取左边的 __proto__  原型链
  let proto = obj.__proto__;
  //obj.__proto__往上找不到了就返回false，退出循环，
  while (proto) {
    // 如果原型链和原型对象相等说明在，直接返回true结束函数
    if (proto === Fn.prototype) {
      return true;
    }
    // 往上找，当前找不到就获取上一级的原型对象
    proto = proto.__proto__;
  }
  return false;
}
```

- 方式 2，**Object.getPrototypeOf(obj )** 方法用于获取指定对象的原型对象（也就是`__protp__`的指向）

```js
function myInstanceof(obj, Fn) {
  if (typeof obj !== "object" || obj === null) return false;
  if (typeof Fn !== "function") throw new TypeError("Fn must be function");
  // 判断构造函数 Fn 是否出现在 obj 的原型链上
  let proto = Object.getPrototypeOf(obj);
  while (proto) {
    if (proto === Fn.prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}

function Foo() {}
var f1 = new Foo();
console.log(myInstanceof(f1, Foo)); //true
console.log(myInstanceof(f1, Object)); //true
console.log(myInstanceof(Object, Function)); //true
console.log(myInstanceof(Object, Object)); //true
console.log(myInstanceof(Function, Object)); //true
console.log(myInstanceof(Function, Function)); //true
console.log(myInstanceof(Object, Foo)); //false
```

---

### 手写防抖 debounce

搜索框搜索输入、窗口大小 resize 变化后，再重新渲染

```js
const container = document.getElementById("container");
let count = 1;
function getUserAction(event) {
  console.log("event", event, "this", this);
  container.innerHTML = count++;
}
container.onmousemove = debounce(getUserAction, 3000);
```

- 简单版

```js
function debounce(fun, wait) {
  let timeout = null;
  return function (...args) {
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(() => {
      fun.apply(this, args);
    }, wait);
  };
}
```

- 我不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。

  想想这个需求也是很有道理的嘛，那我们加个 immediate 参数判断是否是立刻执行。

```js
function debounce(fun, wait, immediate) {
  let timeout = null;
  return function (...args) {
    if (timeout) {
      clearTimeout(timeout);
    }
    if (immediate) {
      // 只有计时结束到，令timeout = null才可触发
      var callNow = !timeout;
      timeout = setTimeout(() => {
        timeout = null;
      }, wait);
      if (callNow) {
        fun.apply(this, args);
      }
    } else {
      timeout = setTimeout(() => {
        fun.apply(this, args);
      }, wait);
    }
  };
}
```

---

### 手写节流 throttle

onscroll 事件 滚动加载更多

```js
const container = document.getElementById("container");
let count = 1;
function getUserAction(event) {
  console.log("event", event, "this", this);
  container.innerHTML = count++;
}
container.onmousemove = throttle(getUserAction, 3000);
```

- 使用时间戳 ——第一种事件会立刻执行，停止触发后没有办法再执行事件。

  当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。

  > 当鼠标移入的时候，事件立刻执行，每过 3s 会执行一次，如果在 4.2s 停止触发，以后不会再执行事件。

```js
function throttle(func, wait) {
  let pass = 0;
  return function (...args) {
    const now = Date.now();
    if (now - pass > wait) {
      func.apply(this, args);
      pass = now;
    }
  };
}
```

- 使用**定时器**实现——事件会在 n 秒后第一次执行，停止触发后依然会再执行一次事件。

  当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器

  > 当鼠标移入的时候，事件不会立刻执行，晃了 3s 后终于执行了一次，此后每 3s 执行一次，当数字显示为 3 的时候，立刻移出鼠标，相当于大约 9.2s 的时候停止触发，但是依然会在第 12s 的时候执行一次事件。

```js
function throttle(func, wait) {
  let timeout = null;
  return function (...args) {
    if (!timeout) {
      timeout = setTimeout(() => {
        func.apply(this, args);
        timeout = null;
      }, wait);
    }
  };
}
```

- 双剑合璧——鼠标移入能立刻执行，停止触发的时候还能再执行一次！

```js
function throttle(func, wait) {
  let timeout = null;
  let pass = 0;
  return function () {
    const now = +new Date();
    const args = arguments;
    //下次触发 func 剩余的时间
    var remaining = wait - (now - pass);
    // 如果没有剩余的时间了或者你改了系统时间
    if (remaining <= 0 || remaining > wait) {
      // 使用时间戳
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      pass = now;
      func.apply(this, args);
    } else if (!timeout) {
      // 使用定时器方式节流
      timeout = setTimeout(() => {
        pass = +new Date();
        func.apply(this, args);
        timeout = null;
      }, remaining);
    }
  };
}
```

## 深浅拷贝

### 浅拷贝

浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝

如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址

即**浅拷贝是拷贝一层，深层次的引用类型则共享内存地址**

下面手动简单实现一个浅拷贝

```js
function clone(obj) {
  const newObj = {};
  for (let key in obj) {
    //hasOwnProperty 可以判断一个属性定义在对象本身而不是继承原型链的方法
    if (obj.hasOwnProperty(key)) {
      newObj[key] = obj[key];
    }
  }
  return newObj;
}
```

在`JavaScript`中，存在浅拷贝的现象有：

- \_clone( ) lodash 工具函数

  ```js
  import { clone } from "lodash";
  const obj = {
    name: "lin",
  };
  
  const newObj = clone(obj);
  obj.name = "xxx"; // 改变原来的对象
  console.log("两者指向同一地址", obj == newObj); // false
  ```

* `Object.assign`

  ```js
  const obj = {
    name: "lin",
  };
  const newObj = Object.assign({}, obj);
  obj.name = "xxx"; // 改变原来的对象
  console.log(newObj); // { name: 'lin' } 新对象不变（第一层）
  console.log(obj == newObj); // false 两者指向不同地址
  ```

* `Array.prototype.slice()`

  ```js
  const fxArr = ["One", "Two", "Three"];
  const fxArrs = fxArr.slice(0);
  fxArrs[1] = "love";
  console.log(fxArr); // ["One", "Two", "Three"]
  console.log(fxArrs); // ["One", "love", "Three"]
  ```

* `Array.prototype.concat()`

  ```js
  const fxArr = ["One", "Two", "Three"];
  const fxArrs = fxArr.concat();
  fxArrs[1] = "love";
  console.log(fxArr); // ["One", "Two", "Three"]
  console.log(fxArrs); // ["One", "love", "Three"]
  ```

- 拓展运算符 实现的数组或者对象的浅拷贝

  ```js
  const fxArr = ["One", "Two", "Three"];
  const fxArrs = [...fxArr];
  fxArrs[1] = "love";
  console.log(fxArr); // ["One", "Two", "Three"]
  console.log(fxArrs); // ["One", "love", "Three"]
  
  const obj = {
    name: "lin",
  };
  const newObj = { ...obj };
  obj.name = "xxx"; // 改变原来的对象
  console.log(newObj); // { name: 'lin' } // 新对象不变
  console.log(obj == newObj); // false 两者指向不同地址
  ```

* 数组静态方法 Array.from

  ```js
  const arr = ["lin", "is", "handsome"];
  const newArr = Array.from(arr);
  arr[2] = "rich"; // 改变原来的数组
  console.log(newArr); // ['lin', 'is', 'handsome']
  console.log(arr == newArr); // false 两者指向不同地址
  ```

### 深拷贝

深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性

常见的深拷贝方式有：

- \_.cloneDeep() lodash 工具函数

  ```js
  const _ = require("lodash");
  const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3],
  };
  const obj2 = _.cloneDeep(obj1);
  console.log(obj1.b.f === obj2.b.f); // false
  ```

- jQuery.extend()

  ```js
  const $ = require("jquery");
  const obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3],
  };
  const obj2 = $.extend(true, {}, obj1);
  console.log(obj1.b.f === obj2.b.f); // false
  ```

- JSON.parse(JSON.stringify( ))

  首先通过 stringify 将 json 序列化(json 字符串)，然后在通过 parse 实现反序列(还原)js 对象，序列化的作用是存储和传输，在这个过程中就会开启新的内存空间就会产生和源对象不一样的空间从而实现深拷贝，实际开发中这个用法已经可以解决很多场景了，但是依然有很多弊端。

  > 1. 会忽略`undefined`、`symbol`和`函数`
  >
  > ```js
  > const obj = {
  >   a: undefined,
  >   b: Symbol("b"),
  >   c: function () {},
  > };
  >
  > const newObj = JSON.parse(JSON.stringify(obj));
  > console.log(newObj); // {}
  > ```
  >
  > 2. `NaN`、`Infinity`、`-Infinity` 会被序列化为 `null`：
  >
  > ```js
  > const obj = {
  >   a: NaN,
  >   b: Infinity,
  >   c: -Infinity,
  > };
  > const newObj = JSON.parse(JSON.stringify(obj));
  > console.log(newObj); // {a: null, b: null, c: null}
  > ```
  >
  > 3. 正则 RegExp、Error 对象会变为空对象
  >
  > ```js
  > const obj = {
  >   a: /123/,
  > };
  > const newObj = JSON.parse(JSON.stringify(obj));
  > console.log(newObj); // {a:{}}
  > ```

- 手写循环递归

  > - 支持对象、数组、日期、正则的拷贝。
  > - 处理 DOM 元素（DOM 元素直接返回，拷贝 DOM 元素没有意义，都是指向页面中同一个）。
  >
  > - 处理原始类型（原始类型直接返回，只有引用类型才有深拷贝这个概念）。
  >
  > - 处理函数（函数直接返回，拷贝函数没有意义，两个对象使用内存中同一个地址的函数，问题不大）。
  >
  > - 额外开辟一个储存空间 WeakMap，解决循环引用递归爆栈问题（引入 WeakMap 的另一个意义，配合垃圾回收机制，防止内存泄漏,因为对象是一组键/值对的集合，其中的键是弱引用的。）
  >
  > ```js
  > function deepClone(obj, map = new WeakMap()) {
  >   if (obj === null) return obj; // 如果是null，不需要深拷贝，直接返回
  >   if (obj instanceof Date) return new Date(obj);
  >   if (obj instanceof RegExp) return new RegExp(obj);
  >   if (obj instanceof HTMLElement) return obj;
  >   // 处理原始类型和函数 不需要深拷贝，直接返回
  >   if (typeof obj !== "object") return obj;
  >
  >   if (map.has(obj)) return map.get(obj);
  >   // 创建一个新的克隆对象或克隆数组
  >   let cloneObj = new obj.constructor();
  >   map.set(obj, cloneObj);
  >   for (const key in obj) {
  >     if (obj.hasOwnProperty(key)) {
  >       // 实现一个递归拷贝
  >       cloneObj[key] = deepClone(obj[key], map);
  >     }
  >   }
  >   return cloneObj;
  > }
  > // obj.a = obj
  > ```
  >
  > 1.  `new 实例.constructor()`运用在我们的深拷贝函数里，就不用在拷贝时去判断数组或者对象类型了。原对象是对象，就创建一个新的克隆对象，原对象是数组，就创建一个新的克隆数组
  >
  > ```js
  > let cloneObj = new obj.constructor();
  >
  > console.log([].constructor === Array); // true
  > console.log({}.constructor === Object); // true
  >
  > console.log(new {}.constructor()); // {}
  > // 等价于
  > console.log(new Object()); // {}
  >
  > console.log(new [].constructor()); // []
  > // 等价于
  > console.log(new Array()); // []
  > ```
  >
  > 2.  解决**循环引用**问题，即对象的属性间接或直接的引用了自身的情况，不处理会导致递归进入死循环导致栈内存溢出。
  >
  > > 我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话就继续拷贝，这样就巧妙化解的循环引用的问题。
  >
  > ```js
  > // obj.obj = obj // 循环引用场景
  >
  > const map = new WeakMap(); // 额外开辟一个存储空间来存储当前对象和拷贝对象的对应关系
  > if (map.has(obj)) {
  >   // 当需要拷贝当前对象时，先去存储空间中找，如果有的话直接返回
  >   return map.get(obj);
  > }
  > map.set(obj, cloneObj); // (key:value) 如果存储空间中没有就存进存储空间 map 里
  > ```

**区别：** 下面首先借助两张图，可以更加清晰看到浅拷贝与深拷贝的区别

![](https://static.vue-js.com/d9862c00-69b8-11eb-ab90-d9ae814b240d.png)

从上图发现，浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样

浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象

```js
// 浅拷贝
const obj1 = {
  name: "init",
  arr: [1, [2, 3], 4],
};
const obj3 = clone(obj1); // 一个浅拷贝方法
obj3.name = "update";
obj3.arr[1] = [5, 6, 7]; // 新旧对象还是共享同一块内存

console.log("obj1", obj1); // obj1 { name: 'init',  arr: [ 1, [ 5, 6, 7 ], 4 ] }
console.log("obj3", obj3); // obj3 { name: 'update', arr: [ 1, [ 5, 6, 7 ], 4 ] }
```

但深拷贝会另外创造一个一模一样的对象，**新对象跟原对象不共享内存**，修改新对象不会改到原对象

```js
// 深拷贝
const obj1 = {
  name: "init",
  arr: [1, [2, 3], 4],
};
const obj4 = deepClone(obj1); // 一个深拷贝方法
obj4.name = "update";
obj4.arr[1] = [5, 6, 7]; // 新对象跟原对象不共享内存

console.log("obj1", obj1); // obj1 { name: 'init', arr: [ 1, [ 2, 3 ], 4 ] }
console.log("obj4", obj4); // obj4 { name: 'update', arr: [ 1, [ 5, 6, 7 ], 4 ] }
```

前提为拷贝类型为引用类型的情况下：

- **浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址**
- 深拷贝是**递归拷贝深层次**，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址

### object.assign 和扩展运算法两者区别是什么？

两者都是**浅拷贝**。

- Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。源对象所**有可枚举属性都会复制**

- 扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它**不复制继承的属性或类的属性**，但是它会复制 ES6 的 symbols 属性。

### 手写 call

call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。

实现原理：传递进去的对象添加 fn 属性，执行完之后再删除该属性

```js
Function.prototype.myCall = function (context, ...args) {
  // 判断调用对象
  if (typeof this !== "function") {
    throw new Error("Type error");
  }
  let result = null;
  // 判断 context 是否传入，如果没有传就设置为 window
  context = context || window;
  // 将被调用的方法(this)设置为 context 的属性fnSymbol,Symbol 来保证属性唯一
  const fnSymbol = Symbol();
  context[fnSymbol] = this;
  // 执行要被调用的方法fn
  result = context[fnSymbol](...args);
  // 删除手动增加的属性方法fn
  delete context[fnSymbol];
  // 将执行结果返回
  return result;
};

const obj = {
  value: "vortesnail",
};
function fn(a, b) {
  console.log(this.value, a, b);
}
fn.myCall(obj, "lzp", "hello"); // vortesnail lzp hello
```

### 手写 apply

```JS
Function.prototype.myApply = function (context, args) {
    // 判断调用对象
    if (typeof this !== "function" || !Array.isArray(args)) {
        throw new Error("Type error");
    }
    let result = null;
    // 判断 context 是否传入，如果没有传就设置为 window
    context = context || window;
    // 将被调用的方法(this)设置为 context 的属性fnSymbol,Symbol 来保证属性唯一
    const fnSymbol = Symbol();
    context[fnSymbol] = this;
    // 执行要被调用的方法fn
    result = context[fnSymbol](...args);
    // 删除手动增加的属性方法fn
    delete context[fnSymbol];
    // 将执行结果返回
    return result;
};

const obj = {
    value: "vortesnail",
};
function fn(a, b) {
    console.log(this.value, a, b);
}
fn.myApply(obj, ['lzp', 'hello']); // vortesnail lzp hello
```

### 手写 bind

`bind()` 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

`bind` 方法与 `call / apply` 最大的不同就是前者返回一个绑定上下文的**函数**，而后两者是**直接执行**了函数。例如：

```js
let value = 2;
let foo = {
  value: 1,
};
function bar(name, age) {
  return {
    value: this.value,
    name: name,
    age: age,
  };
}

bar.call(foo, "Jack", 20); // 直接执行了函数
// {value: 1, name: "Jack", age: 20}

let bindFoo1 = bar.bind(foo, "Jack", 20); // 返回一个函数
bindFoo1();
// {value: 1, name: "Jack", age: 20}

let bindFoo2 = bar.bind(foo, "Jack"); // 返回一个函数
bindFoo2(22);
// {value: 1, name: "Jack", age: 22}
```

通过上述代码可以看出 `bind` 有如下特性：

1. 指定 `this`
2. 传入参数
3. 返回一个函数
4. 柯里化

但是还要一个特性：一个**绑定函数也能使用 new 操作符创建对象**：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。

``` js
let value = 2;
let foo = {
    value: 1
};
function bar(name, age) {
    this.habit = 'shopping';
    console.log(this.value);
    console.log(name);
    console.log(age);
}
bar.prototype.friend = 'kevin';

let bindFoo = bar.bind(foo, 'Jack');
let obj = new bindFoo(20); // undefined >>> Jack >>> 20

console.log(o.habit); // shopping
console.log(o.friend) // kevin
```

上面例子中，运行结果 `this.value` 输出为 `undefined` ，这不是全局 `value` 也不是 `foo` 对象中的 `value` ，这说明 **`bind` 的 `this` 对象失效了，`new` 的实现中生成一个新的对象**，这个时候的 `this` 指向的是 `obj` 。

**手写实现**

```js
Function.prototype.MyBind = function (context, ...args) {
  // 调用 bind 的不是函数，需要抛出异常
  if (typeof this !== "function") {
    throw new Error("Type error");
  }
  var fn = this;
  const newFn = function (...bindArgs) {
    // 作为构造函数时，this指向实例，所以不用传进来的context
    return fn.call(
      this instanceof newFn ? this : context,
      ...args,
      ...bindArgs
    );
  };
  // 一些情况下函数没有prototype，比如箭头函数
  if (fn.prototype) {
    // bind 和 Object.create() 都是ES5方法，部分IE浏览器（IE < 9）并不支
    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
    newFn.prototype = Object.create(fn.prototype);
  }
  return newFn;
};
```

### 数据类型

- 在 JS 中共有 `7` 种基本的数据类型，分别为： `Undefined` 、 `Null` 、 `Boolean` 、 `Number` 、 `String` 、 `Symbol` 、 `BigInt` 。

  > ES6 新增的数据类型
  >
  > - Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。
  > - BigInt 可以表示任意大小的整数。

- 引用类型：Array、Object、Function

**数据类型的判断**

#### typeof

能判断所有**基本数据类型，函数**。不可对 **null、对象、数组**进行精确判断，因为都返回 `object`

```js
console.log(typeof undefined); // undefined
console.log(typeof 2); // number
console.log(typeof true); // boolean
console.log(typeof "str"); // string
console.log(typeof Symbol("foo")); // symbol
console.log(typeof 2172141653n); // bigint
console.log(typeof function () {}); // function
// 不能判别
console.log(typeof []); // object
console.log(typeof {}); // object
console.log(typeof null); // object
```

#### instanceof

能判断**对象**类型，不能判断基本数据类型，**其内部运行机制是判断在其原型链中能否找到该类型的原型**。

```js
class People {}
class Student extends People {}
const vortesnail = new Student();

console.log(vortesnail instanceof People); // true
console.log(vortesnail instanceof Student); // true
```

#### Object.prototype.toString.call()

**所有**原始数据类型都是能判断的，还有 **Error 对象，Date 对象**等。

```js
Object.prototype.toString.call(2); // "[object Number]"
Object.prototype.toString.call(""); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(Math); // "[object Math]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(function () {}); // "[object Function]"
```

### 区分数组和对象

1. 通过 ES6 中的 **Array.isArray** 来识别

```js
console.log(Array.isArray([])); //true
console.log(Array.isArray({})); //false
```

2. 通过 **instanceof** 来识别

```js
console.log([] instanceof Array); //true
console.log({} instanceof Array); //false
```

3. 通过调用 **constructor** 来识别

```js
console.log([].constructor === Array); // true
console.log({}.constructor === Array); // false
```

4. 通过 **Object.prototype.toString.call** 方法来识别。借用 Object 原型的 call 或者 apply 方法，调用 toString()是否为[object Array]

```js
console.log(Object.prototype.toString.call([]).slice(8, -1)); // Array
console.log(Object.prototype.toString.call({}).slice(8, -1)); // Object
```

5. **Object.getPrototypeOf** 方法返回指定对象的**原型**（内部[[Prototype]]属性的值）。

```js
Object.getPrototypeOf([]) === Array.prototype // true
[].__proto__ === Array.prototype // true
```

### 类数组对象

一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。

常见的类数组转换为数组的方法有这样几种：

1. 调用**数组的原型**方法来转换

   > 通过 call 调用数组的 **slice** 方法来实现转换
   >
   > ```css
   > Array.prototype.slice.call(arguments);
   > ```
   >
   > 通过 call 调用数组的 **splice** 方法来实现转换
   >
   > ```css
   > Array.prototype.splice.call(arguments, 0);
   > ```
   >
   > ```js
   > var foo = function (a, b) {
   >   console.log(Array.prototype.slice.call(arguments));
   > };
   > foo(1, 2); //(2) [1, 2]
   > ```

2. 使用 ES6 中的 **Array.from()** 来转换

   `Array.from() ` 方法用于将两类对象转为真正的数组：类似数组的对象和可遍历对象（包括 Set 和 Map）。

   ```js
   var foo = function (a, b) {
     var arr = Array.from(arguments);
     console.log(arr);
   };
   foo(1, 2); // (2) [1, 2]
   ```

3. 利用 ES6 中的**扩展运算符** ...restappendChild

   ```js
   var foo = function (...args) {
     console.log(args);
   };
   foo(1, 2); // (2) [1, 2]
   ```

4. 使用 for 循环挨个将 arguments 对象中的内容复制给新数组中

   ```js
   function foo() {
     var args = [];
     for (var i = 0; i < arguments.length; i++) {
       args.push(arguments[i]);
     }
     return args;
   }
   foo(1, 2); // (2) [1, 2]
   ```

### 数组去重

1. [...new Set(arr)]

   ```js
   const unique1 = (arr) => [...new Set(arr)];
   ```

2. filter+indexOf

   ```js
   const unique2 = (arr) =>
     arr.filter((item, index, array) => array.indexOf(item) === index);
   ```

3. filter+Map，数组对象，基于对象的某个唯一属性去重

   ```js
   function unique3(arr, uniId) {
     const res = new Map();
     return arr.filter(
       (item) => !res.has(item[uniId]) && res.set(item[uniId], true)
     );
   }
   ```

### 数组扁平化

扁平化就是将多维数组变成一维数组,不存在数组的嵌套

例如：已有多级嵌套数组 : `[1, [2, [3, [4, 5]]], 6]` 将其扁平化处理 输出: `[1,2,3,4,5,6]`

1. es6 中的**flat**方法

   ```js
   const flatten = (arr) => arr.flat(Infinity);
   ```

2. for of + concat 配合递归

   ```js
   function flatten(arr) {
     let result = [];
     for (let item of arr) {
       result = result.concat(Array.isArray(item) ? flatten(item) : item);
     }
     return result;
   }
   ```

3. reduce 配合递归实现

   ```js
   const flatten = (arr) =>
     arr.reduce(
       (prev, item) => prev.concat(Array.isArray(item) ? flatten(item) : item),
       []
     );
   ```

### 判断空对象的方法

1. 通过**JSON.stringify**方法来判断

   ```css
   JSON.stringify(obj) === '{}' // true
   ```

2. **for in** 循环判断

   ```js
   function isEmptyObj(obj) {
     for (let item in obj) {
       return true;
     }
     return false;
   }
   console.log("对象是否为空：", isEmptyObj({}));
   ```

3. ES6 的**Object.keys**方法

   ```css
   Object.keys(obj).length === 0 // true
   ```

### 手写 reduce

```js
Array.prototype.myReduce = function (cb, initialValue) {
  const arr = this;
  let total = initialValue || arr[0];
  // 有初始值的话从0遍历，否则从1遍历
  for (let i = initialValue ? 0 : 1; i < arr.length; i++) {
    total = cb(total, arr[i], i, arr);
  }
  return total;
};
```

### 手写 sleep 函数

````js
/**
 * 延时: 单位ms
 *
 * @param {number} [time=0]
 * @returns {Promise<undefined>}
 */
function sleep(time = 0) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(null)
        }, time)
    })
}

(async function (){
    console.log('开始, ' + new Date());
    await sleep(2000)
    console.log('结束, ' + new Date());
})()

````

### 手写Promise

```js
class MyPromise {
    constructor(executor) {
        this.state = 'pending';
        this.value = undefined;
        this.reason = undefined;
        this.onFulfilledCallbacks = [];
        this.onRejectedCallbacks = [];

        const resolve = (value) => {
            if (this.state === 'pending') {
                this.state = 'fulfilled';
                this.value = value;
                this.onFulfilledCallbacks.forEach(callback => callback());
            }
        };

        const reject = (reason) => {
            if (this.state === 'pending') {
                this.state = 'rejected';
                this.reason = reason;
                this.onRejectedCallbacks.forEach(callback => callback());
            }
        };

        try {
            executor(resolve, reject);
        } catch (error) {
            reject(error);
        }
    }

    then(onFulfilled, onRejected) {
        return new MyPromise((resolve, reject) => {
            if (this.state === 'fulfilled') {
                try {
                    const result = onFulfilled ? onFulfilled(this.value) : this.value;
                    resolve(result);
                } catch (error) {
                    reject(error);
                }
            } else if (this.state === 'rejected') {
                try {
                    const result = onRejected ? onRejected(this.reason) : this.reason;
                    resolve(result);
                } catch (error) {
                    reject(error);
                }
            } else {
                this.onFulfilledCallbacks.push(() => {
                    try {
                        const result = onFulfilled ? onFulfilled(this.value) : this.value;
                        resolve(result);
                    } catch (error) {
                        reject(error);
                    }
                });
                this.onRejectedCallbacks.push(() => {
                    try {
                        const result = onRejected ? onRejected(this.reason) : this.reason;
                        resolve(result);
                    } catch (error) {
                        reject(error);
                    }
                });
            }
        });
    }

    catch(onRejected) {
        return this.then(null, onRejected);
    }

    static resolve(value) {
        return new MyPromise(resolve => resolve(value));
    }

    static reject(reason) {
        return new MyPromise((resolve, reject) => reject(reason));
    }
}
```

### 手写 EventEmitter

```js
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
  }

  emit(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].forEach((callback) => {
        callback.apply(this, args);
      });
    }
  }

  off(eventName, callback) {
    if (this.events[eventName]) {
      this.events[eventName] = this.events[eventName].filter(
        (cb) => cb !== callback
      );
    }
  }

  once(eventName, callback) {
    const onceCallback = (...args) => {
      callback.apply(this, args);
      this.off(eventName, onceCallback);
    };
    this.on(eventName, onceCallback);
  }
}

// 使用示例
const emitter = new EventEmitter();
emitter.on("test", (data) => console.log("test:", data));
emitter.emit("test", "hello"); // test: hello
```

### 手写 LRU 缓存

```js
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
  }

  get(key) {
    if (this.cache.has(key)) {
      const value = this.cache.get(key);
      // 删除并重新添加，使其成为最新的
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return -1;
  }

  put(key, value) {
    if (this.cache.has(key)) {
      // 如果存在，删除旧的
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // 如果容量已满，删除最旧的（第一个）
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    // 添加新的
    this.cache.set(key, value);
  }
}
```

### 手写柯里化函数

```js
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function (...nextArgs) {
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
}

// 使用示例
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6
```

### 手写 compose 函数

```js
function compose(...fns) {
  return function (value) {
    return fns.reduceRight((acc, fn) => fn(acc), value);
  };
}

// 使用示例
const add1 = (x) => x + 1;
const multiply2 = (x) => x * 2;
const subtract3 = (x) => x - 3;

const composed = compose(subtract3, multiply2, add1);
console.log(composed(5)); // (5 + 1) * 2 - 3 = 9
```

### 手写 JSON.stringify

```js
function myStringify(obj) {
  if (obj === null) return "null";
  if (typeof obj === "undefined") return undefined;
  if (typeof obj === "string") return `"${obj}"`;
  if (typeof obj === "number" || typeof obj === "boolean") return String(obj);

  if (Array.isArray(obj)) {
    const items = obj.map((item) => myStringify(item));
    return `[${items.join(",")}]`;
  }

  if (typeof obj === "object") {
    const pairs = [];
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        const value = myStringify(obj[key]);
        if (value !== undefined) {
          pairs.push(`"${key}":${value}`);
        }
      }
    }
    return `{${pairs.join(",")}}`;
  }

  return undefined;
}
```

### 手写 JSON.parse

```js
function myParse(jsonString) {
  let index = 0;

  function parseValue() {
    skipWhitespace();
    const char = jsonString[index];

    if (char === '"') return parseString();
    if (char === "{") return parseObject();
    if (char === "[") return parseArray();
    if (char === "t") return parseTrue();
    if (char === "f") return parseFalse();
    if (char === "n") return parseNull();
    if (char === "-" || (char >= "0" && char <= "9")) return parseNumber();

    throw new Error(`Unexpected character: ${char}`);
  }

  function parseString() {
    index++; // skip opening quote
    let result = "";
    while (jsonString[index] !== '"') {
      if (jsonString[index] === "\\") {
        index++;
        const char = jsonString[index];
        if (char === "n") result += "\n";
        else if (char === "t") result += "\t";
        else if (char === "r") result += "\r";
        else result += char;
      } else {
        result += jsonString[index];
      }
      index++;
    }
    index++; // skip closing quote
    return result;
  }

  function parseObject() {
    index++; // skip opening brace
    const result = {};
    skipWhitespace();

    if (jsonString[index] === "}") {
      index++;
      return result;
    }

    while (true) {
      skipWhitespace();
      const key = parseString();
      skipWhitespace();
      if (jsonString[index] !== ":") throw new Error("Expected colon");
      index++;
      const value = parseValue();
      result[key] = value;
      skipWhitespace();

      if (jsonString[index] === "}") {
        index++;
        break;
      }
      if (jsonString[index] !== ",") throw new Error("Expected comma");
      index++;
    }

    return result;
  }

  function parseArray() {
    index++; // skip opening bracket
    const result = [];
    skipWhitespace();

    if (jsonString[index] === "]") {
      index++;
      return result;
    }

    while (true) {
      result.push(parseValue());
      skipWhitespace();

      if (jsonString[index] === "]") {
        index++;
        break;
      }
      if (jsonString[index] !== ",") throw new Error("Expected comma");
      index++;
    }

    return result;
  }

  function parseTrue() {
    if (jsonString.substr(index, 4) === "true") {
      index += 4;
      return true;
    }
    throw new Error("Expected true");
  }

  function parseFalse() {
    if (jsonString.substr(index, 5) === "false") {
      index += 5;
      return false;
    }
    throw new Error("Expected false");
  }

  function parseNull() {
    if (jsonString.substr(index, 4) === "null") {
      index += 4;
      return null;
    }
    throw new Error("Expected null");
  }

  function parseNumber() {
    let start = index;
    if (jsonString[index] === "-") index++;
    while (jsonString[index] >= "0" && jsonString[index] <= "9") index++;
    if (jsonString[index] === ".") {
      index++;
      while (jsonString[index] >= "0" && jsonString[index] <= "9") index++;
    }
    if (jsonString[index] === "e" || jsonString[index] === "E") {
      index++;
      if (jsonString[index] === "+" || jsonString[index] === "-") index++;
      while (jsonString[index] >= "0" && jsonString[index] <= "9") index++;
    }
    return Number(jsonString.substr(start, index - start));
  }

  function skipWhitespace() {
    while (
      jsonString[index] === " " ||
      jsonString[index] === "\n" ||
      jsonString[index] === "\r" ||
      jsonString[index] === "\t"
    ) {
      index++;
    }
  }

  return parseValue();
}
```

### 手写发布订阅模式

```js
class PubSub {
  constructor() {
    this.subscribers = {};
  }

  subscribe(event, callback) {
    if (!this.subscribers[event]) {
      this.subscribers[event] = [];
    }
    this.subscribers[event].push(callback);

    // 返回取消订阅函数
    return () => {
      this.unsubscribe(event, callback);
    };
  }

  unsubscribe(event, callback) {
    if (this.subscribers[event]) {
      this.subscribers[event] = this.subscribers[event].filter(
        (cb) => cb !== callback
      );
    }
  }

  publish(event, data) {
    if (this.subscribers[event]) {
      this.subscribers[event].forEach((callback) => callback(data));
    }
  }
}

// 使用示例
const pubsub = new PubSub();
const unsubscribe = pubsub.subscribe("message", (data) => {
  console.log("Received:", data);
});
pubsub.publish("message", "Hello World!");
unsubscribe(); // 取消订阅
```

### 手写观察者模式

```js
class Subject {
  constructor() {
    this.observers = [];
  }

  addObserver(observer) {
    this.observers.push(observer);
  }

  removeObserver(observer) {
    this.observers = this.observers.filter((obs) => obs !== observer);
  }

  notify(data) {
    this.observers.forEach((observer) => observer.update(data));
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) {
    console.log(`${this.name} received:`, data);
  }
}

// 使用示例
const subject = new Subject();
const observer1 = new Observer("Observer 1");
const observer2 = new Observer("Observer 2");

subject.addObserver(observer1);
subject.addObserver(observer2);
subject.notify("Hello Observers!");
```

---

## Promise 相关手写

### 手写 Promise.all

**功能说明：** 等待所有 Promise 完成，返回结果数组。如果任何一个 Promise 失败，立即返回失败。

**实现原理：** 使用计数器跟踪完成的 Promise 数量，当所有 Promise 都完成时 resolve 结果数组。

**使用场景：** 并发请求多个接口、批量处理异步任务。

```js
Promise.myAll = function (promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      reject(new TypeError("参数必须是数组"));
      return;
    }

    const results = [];
    let completedCount = 0;

    if (promises.length === 0) {
      resolve(results);
      return;
    }

    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then((value) => {
          results[index] = value;
          completedCount++;

          if (completedCount === promises.length) {
            resolve(results);
          }
        })
        .catch(reject);
    });
  });
};

// 测试
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = Promise.resolve(3);

Promise.myAll([p1, p2, p3]).then(console.log); // [1, 2, 3]
```

### 手写 Promise.race

**功能说明：** 返回第一个完成的 Promise 结果（无论成功还是失败）。

**实现原理：** 遍历所有 Promise，一旦有 Promise 完成就立即 resolve 或 reject。

**使用场景：** 超时控制、竞速请求、快速响应。

```js
Promise.myRace = function (promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      reject(new TypeError("参数必须是数组"));
      return;
    }

    promises.forEach((promise) => {
      Promise.resolve(promise).then(resolve).catch(reject);
    });
  });
};

// 测试
const p1 = new Promise((resolve) => setTimeout(() => resolve(1), 1000));
const p2 = new Promise((resolve) => setTimeout(() => resolve(2), 500));

Promise.myRace([p1, p2]).then(console.log); // 2
```

### 手写 Promise.allSettled

**功能说明：** 等待所有 Promise 完成，返回每个 Promise 的状态和结果，不会因为某个 Promise 失败而中断。

**实现原理：** 使用 finally 确保每个 Promise 都会处理，记录成功和失败的结果。

**使用场景：** 需要获取所有异步操作结果的场景，即使部分失败也要继续处理。

```js
Promise.myAllSettled = function (promises) {
  return new Promise((resolve) => {
    if (!Array.isArray(promises)) {
      resolve([]);
      return;
    }

    const results = [];
    let completedCount = 0;

    if (promises.length === 0) {
      resolve(results);
      return;
    }

    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then((value) => {
          results[index] = { status: "fulfilled", value };
        })
        .catch((reason) => {
          results[index] = { status: "rejected", reason };
        })
        .finally(() => {
          completedCount++;
          if (completedCount === promises.length) {
            resolve(results);
          }
        });
    });
  });
};
```

### 手写 async/await

**功能说明：** 将 Generator 函数转换为 async 函数，实现异步代码的同步写法。

**实现原理：** 通过递归调用 step 函数处理 Generator 的 next 和 throw 操作，将 yield 的 Promise 结果传递给下一步。

**使用场景：** 简化异步代码、错误处理、代码可读性提升。

```js
function asyncToGenerator(generatorFn) {
  return function (...args) {
    const generator = generatorFn.apply(this, args);

    return new Promise((resolve, reject) => {
      function step(key, arg) {
        let result;
        try {
          result = generator[key](arg);
        } catch (error) {
          reject(error);
          return;
        }

        const { value, done } = result;
        if (done) {
          resolve(value);
        } else {
          return Promise.resolve(value).then(
            (val) => step("next", val),
            (err) => step("throw", err)
          );
        }
      }

      step("next");
    });
  };
}

// 使用示例
const asyncFn = asyncToGenerator(function* () {
  const result1 = yield Promise.resolve(1);
  const result2 = yield Promise.resolve(2);
  return result1 + result2;
});

asyncFn().then(console.log); // 3
```

---

## Object 相关手写

### 手写 Object.create

**功能说明：** 创建一个新对象，使用现有的对象作为新创建对象的原型。

**实现原理：** 创建一个空函数，将其 prototype 指向传入的原型对象，然后返回该函数的实例。

**使用场景：** 原型继承、对象创建、ES5 之前的继承实现。

```js
Object.myCreate = function (proto, propertiesObject) {
  if (typeof proto !== "object" && proto !== null) {
    throw new TypeError("Object prototype may only be an Object or null");
  }

  function F() {}
  F.prototype = proto;
  const obj = new F();

  if (propertiesObject !== undefined) {
    Object.defineProperties(obj, propertiesObject);
  }

  return obj;
};

// 测试
const person = {
  name: "John",
  sayHello() {
    console.log(`Hello, I'm ${this.name}`);
  },
};

const john = Object.myCreate(person);
john.name = "John Doe";
john.sayHello(); // Hello, I'm John Doe
```

### 手写 Object.assign

**功能说明：** 将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回目标对象。

**实现原理：** 遍历源对象的所有可枚举属性，使用 hasOwnProperty 检查后复制到目标对象。

**使用场景：** 对象合并、浅拷贝、配置对象合并。

```js
Object.myAssign = function (target, ...sources) {
  if (target == null) {
    throw new TypeError("Cannot convert undefined or null to object");
  }

  const to = Object(target);

  sources.forEach((source) => {
    if (source != null) {
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          to[key] = source[key];
        }
      }
    }
  });

  return to;
};

// 测试
const obj1 = { a: 1 };
const obj2 = { b: 2 };
const obj3 = { c: 3 };

const result = Object.myAssign(obj1, obj2, obj3);
console.log(result); // { a: 1, b: 2, c: 3 }
```

---

## Array 相关手写

### 手写 Array.prototype.forEach

**功能说明：** 对数组的每个元素执行一次提供的函数，不返回新数组。

**实现原理：** 遍历数组，对每个元素调用回调函数，支持 thisArg 参数绑定。

**使用场景：** 数组遍历、副作用操作、不关心返回值的场景。

```js
Array.prototype.myForEach = function (callback, thisArg) {
  if (this == null) {
    throw new TypeError("this is null or not defined");
  }

  if (typeof callback !== "function") {
    throw new TypeError(callback + " is not a function");
  }

  const O = Object(this);
  const len = O.length >>> 0;

  for (let i = 0; i < len; i++) {
    if (i in O) {
      callback.call(thisArg, O[i], i, O);
    }
  }
};

// 测试
const arr = [1, 2, 3];
arr.myForEach((item, index) => {
  console.log(`索引${index}: ${item}`);
});
```

### 手写 Array.prototype.map

**功能说明：** 创建一个新数组，其结果是该数组中的每个元素调用提供的函数后的返回值。

**实现原理：** 遍历数组，对每个元素调用回调函数，将返回值存入新数组的对应位置。

**使用场景：** 数组转换、数据映射、函数式编程。

```js
Array.prototype.myMap = function (callback, thisArg) {
  if (this == null) {
    throw new TypeError("this is null or not defined");
  }

  if (typeof callback !== "function") {
    throw new TypeError(callback + " is not a function");
  }

  const O = Object(this);
  const len = O.length >>> 0;
  const result = new Array(len);

  for (let i = 0; i < len; i++) {
    if (i in O) {
      result[i] = callback.call(thisArg, O[i], i, O);
    }
  }

  return result;
};

// 测试
const arr = [1, 2, 3];
const doubled = arr.myMap((x) => x * 2);
console.log(doubled); // [2, 4, 6]
```

---

## 设计模式手写

### 手写单例模式

**功能说明：** 确保一个类只有一个实例，并提供全局访问点。

**实现原理：** 使用闭包或类的静态属性来保存唯一实例，通过条件判断控制实例创建。

**使用场景：** 全局配置、数据库连接、日志记录器、缓存管理。

```js
// 方式1：使用闭包
const Singleton = (function () {
  let instance;

  function createInstance() {
    return {
      name: "Singleton Instance",
      getInstance() {
        return this;
      },
    };
  }

  return {
    getInstance() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    },
  };
})();

// 方式2：使用类
class SingletonClass {
  constructor() {
    if (SingletonClass.instance) {
      return SingletonClass.instance;
    }
    SingletonClass.instance = this;
    this.name = "Singleton Instance";
  }

  static getInstance() {
    if (!SingletonClass.instance) {
      SingletonClass.instance = new SingletonClass();
    }
    return SingletonClass.instance;
  }
}

// 测试
const s1 = Singleton.getInstance();
const s2 = Singleton.getInstance();
console.log(s1 === s2); // true
```

### 手写工厂模式

**功能说明：** 根据不同的参数创建不同类型的对象，而不需要直接使用构造函数。

**实现原理：** 通过工厂函数封装对象创建逻辑，根据传入参数决定创建哪种类型的对象。

**使用场景：** 对象创建复杂、需要根据条件创建不同对象、解耦对象创建和使用。

```js
class Car {
  constructor(type, brand) {
    this.type = type;
    this.brand = brand;
  }

  drive() {
    console.log(`Driving ${this.brand} ${this.type}`);
  }
}

class CarFactory {
  static createCar(type, brand) {
    switch (type) {
      case "sedan":
        return new Car("Sedan", brand);
      case "suv":
        return new Car("SUV", brand);
      case "sports":
        return new Car("Sports Car", brand);
      default:
        throw new Error("Unknown car type");
    }
  }
}

// 测试
const sedan = CarFactory.createCar("sedan", "Toyota");
const suv = CarFactory.createCar("suv", "BMW");
sedan.drive(); // Driving Toyota Sedan
suv.drive(); // Driving BMW SUV
```

---

## 算法相关手写

### 手写快速排序

**功能说明：** 通过选择一个基准元素，将数组分为小于、等于、大于基准的三部分，然后递归排序。

**实现原理：** 分治法思想，每次选择一个基准值，将数组分为三部分，递归处理左右两部分。

**使用场景：** 大数据量排序、需要稳定排序性能的场景。

```js
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const pivot = arr[Math.floor(arr.length / 2)];
  const left = [];
  const right = [];
  const equal = [];

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else if (arr[i] > pivot) {
      right.push(arr[i]);
    } else {
      equal.push(arr[i]);
    }
  }

  return [...quickSort(left), ...equal, ...quickSort(right)];
}

// 测试
const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(quickSort(arr)); // [11, 12, 22, 25, 34, 64, 90]
```

### 手写二分查找

**功能说明：** 在有序数组中查找目标值，每次比较后排除一半的搜索范围。

**实现原理：** 使用双指针（left、right）维护搜索范围，通过中间值比较缩小搜索区间。

**使用场景：** 有序数组查找、查找插入位置、范围查询。

```js
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }

  return -1;
}

// 测试
const arr = [1, 3, 5, 7, 9, 11, 13, 15];
console.log(binarySearch(arr, 7)); // 3
console.log(binarySearch(arr, 4)); // -1
```

### 手写斐波那契数列

**功能说明：** 计算斐波那契数列的第 n 项，每个数字是前两个数字的和。

**实现原理：** 提供递归、动态规划、记忆化三种实现方式，优化时间复杂度。

**使用场景：** 算法学习、性能优化、动态规划入门。

```js
// 递归版本（效率低）
function fibonacciRecursive(n) {
  if (n <= 1) return n;
  return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}

// 动态规划版本（效率高）
function fibonacciDP(n) {
  if (n <= 1) return n;

  let a = 0,
    b = 1;
  for (let i = 2; i <= n; i++) {
    [a, b] = [b, a + b];
  }
  return b;
}

// 记忆化版本
function fibonacciMemo(n, memo = {}) {
  if (n in memo) return memo[n];
  if (n <= 1) return n;

  memo[n] = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
  return memo[n];
}

// 测试
console.log(fibonacciDP(10)); // 55
console.log(fibonacciMemo(10)); // 55
```

---

## 工具函数手写

### 手写数字千分位格式化

**功能说明：** 将数字格式化为千分位分隔的字符串，提高数字可读性。

**实现原理：** 使用正则表达式、toLocaleString 或手动实现三种方式添加千分位分隔符。

**使用场景：** 金额显示、数据展示、报表生成。

```js
function formatNumber(num) {
  // 方式1：使用正则表达式
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

function formatNumber2(num) {
  // 方式2：使用toLocaleString
  return num.toLocaleString();
}

function formatNumber3(num) {
  // 方式3：手动实现
  const str = num.toString();
  const parts = str.split(".");
  parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  return parts.join(".");
}

// 测试
console.log(formatNumber(1234567.89)); // 1,234,567.89
console.log(formatNumber2(1234567.89)); // 1,234,567.89
console.log(formatNumber3(1234567.89)); // 1,234,567.89
```

### 手写 URL 参数解析

**功能说明：** 解析 URL 中的查询参数，提取键值对信息。

**实现原理：** 使用 URL API 或手动解析 queryString，处理 URL 编码和特殊字符。

**使用场景：** 路由参数处理、API 参数解析、URL 状态管理。

```js
function parseURL(url) {
  const urlObj = new URL(url);
  const params = {};

  for (const [key, value] of urlObj.searchParams) {
    params[key] = value;
  }

  return {
    protocol: urlObj.protocol,
    hostname: urlObj.hostname,
    port: urlObj.port,
    pathname: urlObj.pathname,
    search: urlObj.search,
    hash: urlObj.hash,
    params,
  };
}

// 手写版本
function parseURLParams(url) {
  const params = {};
  const queryString = url.split("?")[1];

  if (queryString) {
    const pairs = queryString.split("&");
    pairs.forEach((pair) => {
      const [key, value] = pair.split("=");
      params[decodeURIComponent(key)] = decodeURIComponent(value || "");
    });
  }

  return params;
}

// 测试
const url =
  "https://www.example.com:8080/path?name=John&age=30&city=New%20York#section1";
console.log(parseURL(url));
console.log(parseURLParams(url));
```

### 手写 Cookie 操作

**功能说明：** 提供完整的 Cookie 管理功能，包括设置、获取、删除操作。

**实现原理：** 封装 document.cookie 的读写操作，支持各种 Cookie 属性配置。

**使用场景：** 用户状态管理、登录信息存储、个性化设置。

```js
const Cookie = {
  set(name, value, options = {}) {
    let cookieString = `${encodeURIComponent(name)}=${encodeURIComponent(
      value
    )}`;

    if (options.expires) {
      cookieString += `; expires=${options.expires.toUTCString()}`;
    }

    if (options.maxAge) {
      cookieString += `; max-age=${options.maxAge}`;
    }

    if (options.path) {
      cookieString += `; path=${options.path}`;
    }

    if (options.domain) {
      cookieString += `; domain=${options.domain}`;
    }

    if (options.secure) {
      cookieString += "; secure";
    }

    if (options.sameSite) {
      cookieString += `; samesite=${options.sameSite}`;
    }

    document.cookie = cookieString;
  },

  get(name) {
    const cookies = document.cookie.split(";");
    for (let cookie of cookies) {
      const [cookieName, cookieValue] = cookie.trim().split("=");
      if (cookieName === encodeURIComponent(name)) {
        return decodeURIComponent(cookieValue);
      }
    }
    return null;
  },

  remove(name) {
    this.set(name, "", { expires: new Date(0) });
  },
};

// 测试
Cookie.set("username", "John", { maxAge: 3600, path: "/" });
console.log(Cookie.get("username")); // John
Cookie.remove("username");
```

### 手写 localStorage 封装

**功能说明：** 封装 localStorage 操作，支持数据过期时间管理。

**实现原理：** 将数据和过期时间一起存储，读取时检查是否过期，自动清理过期数据。

**使用场景：** 本地数据缓存、用户偏好设置、临时数据存储。

```js
const Storage = {
  set(key, value, expire) {
    const data = {
      value,
      expire: expire ? Date.now() + expire * 1000 : null,
    };
    localStorage.setItem(key, JSON.stringify(data));
  },

  get(key) {
    const item = localStorage.getItem(key);
    if (!item) return null;

    try {
      const data = JSON.parse(item);
      if (data.expire && Date.now() > data.expire) {
        localStorage.removeItem(key);
        return null;
      }
      return data.value;
    } catch (error) {
      return null;
    }
  },

  remove(key) {
    localStorage.removeItem(key);
  },

  clear() {
    localStorage.clear();
  },
};

// 测试
Storage.set("user", { name: "John", age: 30 }, 3600); // 1小时过期
console.log(Storage.get("user")); // { name: 'John', age: 30 }
```

### 手写图片懒加载

**功能说明：** 实现图片的延迟加载，只有当图片进入可视区域时才加载，提升页面性能。

**实现原理：** 使用 IntersectionObserver API 或 scroll 事件监听，检测图片是否进入视口。

**使用场景：** 长列表优化、图片画廊、移动端性能优化。

```js
class LazyLoad {
  constructor(selector = "img[data-src]") {
    this.images = document.querySelectorAll(selector);
    this.init();
  }

  init() {
    if ("IntersectionObserver" in window) {
      this.observeWithIntersectionObserver();
    } else {
      this.observeWithScroll();
    }
  }

  observeWithIntersectionObserver() {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          this.loadImage(entry.target);
          observer.unobserve(entry.target);
        }
      });
    });

    this.images.forEach((img) => observer.observe(img));
  }

  observeWithScroll() {
    const loadImages = () => {
      this.images.forEach((img) => {
        if (this.isInViewport(img)) {
          this.loadImage(img);
        }
      });
    };

    window.addEventListener("scroll", this.throttle(loadImages, 100));
    loadImages(); // 初始加载
  }

  isInViewport(element) {
    const rect = element.getBoundingClientRect();
    return (
      rect.top >= 0 &&
      rect.left >= 0 &&
      rect.bottom <=
        (window.innerHeight || document.documentElement.clientHeight) &&
      rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );
  }

  loadImage(img) {
    const src = img.dataset.src;
    if (src) {
      img.src = src;
      img.removeAttribute("data-src");
      img.classList.add("loaded");
    }
  }

  throttle(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
}

// 使用
new LazyLoad();
```

```

```
