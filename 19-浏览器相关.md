### 进程与线程概念

- 进程：程序的一次执行，占有一片独立的内存空间

- 线程：
  1.  是进程内的一个独立执行单元，
  2.  是程序执行的一个完整流程，
  3.  是 CPU 的最小的调度单元

### 单线程与多线程概念

- 单线程：一个进程内只有一个线程

- 多线程：一个进程内有多个线程

### 到底何为多进程与多线程？

- 多进程：一应用程序可以同时启动多个实例运行。

- 多线程：在一个进程内，同时有多个线程运行。
  1.  应用程序必须运行在某个进程的某个线程上
  2.  一个进程中至少有一个运行的线程：主线程，进程启动后自动创建
  3.  一个进程中也可以同时运行多个线程，即程序是多线程运行的
  4.  一个进程内的数据可以供其中的多个线程直接共享
  5.  多个进程之间的数据是不能直接共享的
  6.  线程池：保存多个线程对象的容器，实现线程对象的反复利用

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02b623f1d9384781a707b54b6c273a4e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

### 多线程优缺点

- 优点：有效提升 CPU 的利用率

- 缺点：
  1.  创建多线程开销
  2.  线程切换开销。
  3.  死锁与状态同步问题。
      死锁就是没有线程去唤醒阻塞的线程。导致线程一直就是 waiting。

### 单线程优缺点

优点：顺序编程简单易懂（js 单线程运行 ）

缺点：效率低 （h5 中 Web Workers 可以多线程运行）

### 浏览器是多线程还是单线程？

浏览器是多线程的。

### 浏览器是多进程还是单进程？

有的是多进程的，有的是单进程的（ie/火狐）

### 浏览器进程

> 浏览器作为一个计算机应用程序，如果打开浏览器默认进入一个空白页，相当于新起了一个浏览器的
>
> 主进程和 GPU 进程，如果再打开一个标签页，则又创建了一个渲染进程。
>
> 浏览器每打开一个 Tab 页，就相当于创建了一个独立的浏览器进程。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b95bd9b71f2a42a398366852531d5075~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

### 浏览器多进程的优点与缺点

优点：

> 1. 避免单个页面崩溃影响整个浏览器
> 2. 避免第三方插件崩溃影响整个浏览器
> 3. 多进程充分利用多核优势
> 4. 方便使用沙盒模型隔离插件等进程，提高浏览器安全性
> 5. 大大改善了用户体验。

缺点：

> 对系统资源的消耗加大，特别是内存的消耗。

### 浏览器五大进程

#### 1、Browser 进程

> 浏览器的主进程（负责协调、主控），只有一个，相当于浏览器的大脑，作用有：
>
> 负责浏览器界面显示，与用户交互，如前进，后退等；
>
> 负责各个页面的管理，创建和销毁其他进程；
>
> 将渲染线程得到的内存中的位图渲染到用户界面上；
>
> 网络资源的管理，下载等。

#### 2、插件进程

> 因为插件易崩溃，所以通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
> 每种类型的插件对应一个进程，仅当使用该插件时才创建。

#### 3、GPU 进程

> 也只有一个，用于 3D 绘制，只有当该页面使用了硬件加速才会使用它，来渲染页面。
>
> 否则的话，不使用这个进程，而是用 Browser 进程来渲染页面。

#### 4、渲染进程 （前端重点）

> 每一个 tab 页面都有一个渲染进程，而且互相之间是不影响的，主要用来渲染页面，进行脚本执行等。在这个进程中，还有 1、界面渲染线程，2、js 引擎线程，3、浏览器事件处理线程等，4、http 请求线程

#### 5、网络进程

> 主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立处理，成为单独一个进程。

### 浏览器渲染进程中的常用线程

#### 1、界面渲染线程（GUI）

> 负责渲染浏览器界面，解析 html，css，建立 DOM 树等，当我们修改了一些元素的颜色或者背景色，页面就会重绘，当我们修改元素的尺寸、位置、增删，页面就会回流，回流比重绘的成本要高。
>
> 回流一定会触发重绘，而重绘不一定会回流。

#### 2、js 引擎线程

> 负责解析 js 脚本，运行 js 代码，一个 tab 页面无论什么时候都只能有一个 js 线程在运行 js 程序，JS 是单线程的。
>
> GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行;如果 JS 执行的时间过长，会导致页面渲染被阻塞。

#### 3、事件处理线程（任务队列）

> 事件触发线程管理着一个任务队列。
>
> 接受浏览器里面的操作事件响应。如在监听到鼠标、键盘等事件的时候， 如果有事件处理函数，就将对应的任务压入任务队列（添加到待处理队列的队尾），等待 JS 引擎的处理。

#### 4、http 请求线程

> 当执行到一个 http 异步请求时，就把异步请求事件添加到异步请求线程，等收到响应，再把回调函数添加到事件队列，等待 js 引擎线程来执行。

#### 5、定时器线程

> setInternal 与 setTimeout 所在线程
>
> 浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于
>
> 阻塞线程状态就会影响记计时的准确）
>
> 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行）
>
> 注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms。

### 事件循环机制

> js 任务可以分成两种，一种是同步任务，另一种是异步任务。
>
> 1. 同步任务都在主线程上执行，形成一个执行栈。
> 2. 主线程之外，事件处理线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放一个事件回调。
> 3. 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，将可以运行的异步任务添加到执行栈中，开始执行。
> 4. 主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。

## 浏览器 navigator

### \_.userAgent

分辨是否移动端

```js
export const IS_MOBILE =
  /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i.test(
    navigator.userAgent
  );
```

移动端跳转链接

```js
onclick = (e) => {
  e.preventDefault();
  const ios = navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad)/);
  if (ios) {
    document.location.href = v.href;
  } else {
    window.open(v.href);
  }
};
```

### \_.clipboard.writeText

复制文本到粘贴板

```js
export const copyText = async (text: string) => {
  await navigator.clipboard.writeText(text);
};
```

### \_.onLine

监听网络状况

```js
import { message } from "antd";
/**
 * 网络状态监测
 *
 */
function checkOnlineStatus() {
  if (navigator.onLine === undefined) {
    return;
  }
  if (navigator.onLine) {
    return message.success("网络已重新连接!");
  } else {
    return message.error("网络已断开连接!");
  }
}

/**
 * 监测网络状态
 *
 * @export
 */
export default function monNetworkStatus() {
  window.addEventListener("online", checkOnlineStatus);
  window.addEventListener("offline", checkOnlineStatus);
}
```
