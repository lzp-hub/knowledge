# 数组与字符串操作大全

## 📚 目录

- [ES1 时代（1997 年）](#es1-时代1997年)
- [ES5 时代（2009 年）](#es5-时代2009年)
- [ES2015/ES6 时代（2015 年）](#es2015es6-时代2015年)
- [ES2016 时代（2016 年）](#es2016-时代2016年)
- [ES2017 时代（2017 年）](#es2017-时代2017年)
- [ES2019 时代（2019 年）](#es2019-时代2019年)
- [ES2021 时代（2021 年）](#es2021-时代2021年)
- [ES2022 时代（2022 年）](#es2022-时代2022年)
- [实际应用场景](#实际应用场景)
- [性能对比与最佳实践](#性能对比与最佳实践)
- [面试常考算法](#面试常考算法)

---

## ES1 时代（1997 年）

### 📝 ES1 数组方法总览

| 功能分类 | 方法        | 语法                                       | 参数                       | 返回值         | 改变原数组 | 用途         |
| -------- | ----------- | ------------------------------------------ | -------------------------- | -------------- | ---------- | ------------ |
| **增加** | push        | `arr.push(...items)`                       | 要添加的元素               | 新数组长度     | ✅         | 末尾添加     |
| **增加** | unshift     | `arr.unshift(...items)`                    | 要添加的元素               | 新数组长度     | ✅         | 开头添加     |
| **增加** | splice      | `arr.splice(start, deleteCount, ...items)` | 开始位置,删除数量,插入元素 | 被删除元素数组 | ✅         | 指定位置添加 |
| **增加** | concat      | `arr.concat(...items)`                     | 要拼接的元素               | 新数组         | ❌         | 数组拼接     |
| **删除** | pop         | `arr.pop()`                                | 无                         | 被删除的元素   | ✅         | 删除末尾     |
| **删除** | shift       | `arr.shift()`                              | 无                         | 被删除的元素   | ✅         | 删除开头     |
| **删除** | splice      | `arr.splice(start, deleteCount)`           | 开始位置,删除数量          | 被删除元素数组 | ✅         | 指定位置删除 |
| **删除** | slice       | `arr.slice(start, end)`                    | 开始位置,结束位置          | 新数组         | ❌         | 截取片段     |
| **查询** | indexOf     | `arr.indexOf(item, start)`                 | 查找元素,开始位置          | 索引或-1       | ❌         | 查找索引     |
| **查询** | lastIndexOf | `arr.lastIndexOf(item, start)`             | 查找元素,开始位置          | 索引或-1       | ❌         | 最后查找     |
| **排序** | sort        | `arr.sort(compareFunction)`                | 比较函数                   | 排序后的数组   | ✅         | 数组排序     |
| **排序** | reverse     | `arr.reverse()`                            | 无                         | 反转后的数组   | ✅         | 数组反转     |
| **转换** | join        | `arr.join(separator)`                      | 分隔符                     | 字符串         | ❌         | 数组转字符串 |
| **转换** | toString    | `arr.toString()`                           | 无                         | 字符串         | ❌         | 数组转字符串 |

### 📝 ES1 字符串方法总览

| 功能分类 | 方法        | 语法                                | 参数              | 返回值   | 改变原字符串 | 用途       |
| -------- | ----------- | ----------------------------------- | ----------------- | -------- | ------------ | ---------- |
| **增加** | concat      | `str.concat(...strings)`            | 要拼接的字符串    | 新字符串 | ❌           | 字符串拼接 |
| **删除** | slice       | `str.slice(start, end)`             | 开始位置,结束位置 | 新字符串 | ❌           | 截取字符串 |
| **删除** | substring   | `str.substring(start, end)`         | 开始位置,结束位置 | 新字符串 | ❌           | 截取字符串 |
| **删除** | substr      | `str.substr(start, length)`         | 开始位置,长度     | 新字符串 | ❌           | 截取字符串 |
| **修改** | toUpperCase | `str.toUpperCase()`                 | 无                | 新字符串 | ❌           | 转大写     |
| **修改** | toLowerCase | `str.toLowerCase()`                 | 无                | 新字符串 | ❌           | 转小写     |
| **查询** | charAt      | `str.charAt(index)`                 | 索引              | 字符     | ❌           | 获取字符   |
| **查询** | indexOf     | `str.indexOf(substring, start)`     | 子字符串,开始位置 | 索引或-1 | ❌           | 查找索引   |
| **查询** | lastIndexOf | `str.lastIndexOf(substring, start)` | 子字符串,开始位置 | 索引或-1 | ❌           | 最后查找   |
| **查询** | charCodeAt  | `str.charCodeAt(index)`             | 索引              | 字符码   | ❌           | 获取字符码 |
| **修改** | replace     | `str.replace(search, replace)`      | 查找值,替换值     | 新字符串 | ❌           | 字符串替换 |
| **修改** | split       | `str.split(separator, limit)`       | 分隔符,限制数量   | 数组     | ❌           | 字符串分割 |
| **转换** | toString    | `str.toString()`                    | 无                | 字符串   | ❌           | 转字符串   |

### 🔧 ES1 详细方法说明

#### 增加操作

**push() - 末尾添加**

```javascript
// 语法：arr.push(...items)
// 参数：要添加的元素（可多个）
// 返回值：新数组长度
// 改变原数组：是

const arr = [1, 2, 3];
const length = arr.push(4, 5);
console.log(arr); // [1, 2, 3, 4, 5]
console.log(length); // 5

// 实际应用：动态添加数据
function addToCart(cart, item) {
  cart.push(item);
  return cart.length;
}
```

**unshift() - 开头添加**

```javascript
// 语法：arr.unshift(...items)
// 参数：要添加的元素（可多个）
// 返回值：新数组长度
// 改变原数组：是

const arr = [2, 3, 4];
const length = arr.unshift(0, 1);
console.log(arr); // [0, 1, 2, 3, 4]
console.log(length); // 5

// 实际应用：优先级队列
function addToQueue(queue, item, priority = false) {
  if (priority) {
    queue.unshift(item);
  } else {
    queue.push(item);
  }
}
```

**splice() - 指定位置添加**

```javascript
// 语法：arr.splice(start, deleteCount, ...items)
// 参数：开始位置, 删除数量, 插入元素
// 返回值：被删除元素数组
// 改变原数组：是

const arr = [1, 5];
const deleted = arr.splice(1, 0, 2, 3, 4);
console.log(arr); // [1, 2, 3, 4, 5]
console.log(deleted); // []

// 实际应用：数组中间插入
function insertAt(array, index, ...items) {
  array.splice(index, 0, ...items);
  return array;
}
```

**concat() - 数组拼接**

```javascript
// 语法：arr.concat(...items)
// 参数：要拼接的元素（数组会被展开）
// 返回值：新数组
// 改变原数组：否

const arr1 = [1, 2];
const arr2 = [3, 4];
const result = arr1.concat(arr2, 5, [6, 7]);
console.log(result); // [1, 2, 3, 4, 5, 6, 7]
console.log(arr1); // [1, 2] (原数组不变)

// 实际应用：合并多个数组
function mergeArrays(...arrays) {
  return [].concat(...arrays);
}
```

#### 删除操作

**pop() - 删除末尾元素**

```javascript
// 语法：arr.pop()
// 参数：无
// 返回值：被删除的元素
// 改变原数组：是

const arr = [1, 2, 3, 4];
const last = arr.pop();
console.log(arr); // [1, 2, 3]
console.log(last); // 4

// 实际应用：栈操作
class Stack {
  constructor() {
    this.items = [];
  }

  push(item) {
    this.items.push(item);
  }

  pop() {
    return this.items.pop();
  }
}
```

**shift() - 删除开头元素**

```javascript
// 语法：arr.shift()
// 参数：无
// 返回值：被删除的元素
// 改变原数组：是

const arr = [1, 2, 3, 4];
const first = arr.shift();
console.log(arr); // [2, 3, 4]
console.log(first); // 1

// 实际应用：队列操作
class Queue {
  constructor() {
    this.items = [];
  }

  enqueue(item) {
    this.items.push(item);
  }

  dequeue() {
    return this.items.shift();
  }
}
```

**slice() - 截取数组片段**

```javascript
// 语法：arr.slice(start, end)
// 参数：开始位置, 结束位置（不包含）
// 返回值：新数组
// 改变原数组：否

const arr = [1, 2, 3, 4, 5];
const slice1 = arr.slice(1, 3); // [2, 3]
const slice2 = arr.slice(2); // [3, 4, 5]
const slice3 = arr.slice(-2); // [4, 5]
const slice4 = arr.slice(); // [1, 2, 3, 4, 5] (浅拷贝)

// 实际应用：数组分页
function paginate(array, page, pageSize) {
  const start = (page - 1) * pageSize;
  const end = start + pageSize;
  return array.slice(start, end);
}
```

#### 查询操作

**indexOf() - 查找元素索引**

```javascript
// 语法：arr.indexOf(item, start)
// 参数：查找元素, 开始位置
// 返回值：索引或-1
// 改变原数组：否

const arr = ["a", "b", "c", "b"];
console.log(arr.indexOf("b")); // 1
console.log(arr.indexOf("b", 2)); // 3
console.log(arr.indexOf("d")); // -1

// 实际应用：检查元素是否存在
function hasItem(array, item) {
  return array.indexOf(item) !== -1;
}
```

**includes() - 检查元素是否存在**

> **🎯 解决的问题**：解决了 `indexOf()` 无法正确处理 `NaN` 的问题，提供更可靠的包含检查，避免 `NaN === NaN` 返回 `false` 的陷阱。

```javascript
// 语法：arr.includes(item, start)
// 参数：查找元素, 开始位置
// 返回值：布尔值
// 改变原数组：否

const arr = [1, 2, 3, NaN];
console.log(arr.includes(2)); // true
console.log(arr.includes(2, 2)); // false
console.log(arr.includes(NaN)); // true (indexOf无法找到NaN)

// 实际应用：权限检查
function hasPermission(user, permission) {
  return user.permissions.includes(permission);
}
```

**find() - 查找第一个匹配元素**

```javascript
// 语法：arr.find(callback)
// 参数：回调函数 (item, index, array) => boolean
// 返回值：找到的元素或undefined
// 改变原数组：否

const users = [
  { id: 1, name: "张三", age: 25 },
  { id: 2, name: "李四", age: 30 },
  { id: 3, name: "王五", age: 35 },
];

const user = users.find((u) => u.age > 28);
console.log(user); // { id: 2, name: '李四', age: 30 }

// 实际应用：查找用户
function findUser(users, userId) {
  return users.find((user) => user.id === userId);
}
```

**findIndex() - 查找第一个匹配元素的索引**

```javascript
// 语法：arr.findIndex(callback)
// 参数：回调函数 (item, index, array) => boolean
// 返回值：找到的索引或-1
// 改变原数组：否

const users = [
  { id: 1, name: "张三", age: 25 },
  { id: 2, name: "李四", age: 30 },
  { id: 3, name: "王五", age: 35 },
];

const index = users.findIndex((u) => u.name === "李四");
console.log(index); // 1

// 实际应用：更新用户信息
function updateUser(users, userId, updates) {
  const index = users.findIndex((user) => user.id === userId);
  if (index !== -1) {
    users[index] = { ...users[index], ...updates };
  }
  return users;
}
```

**lastIndexOf() - 查找最后一个匹配元素的索引，从右往左搜索**

```javascript
// 语法：arr.lastIndexOf(item, start)
// 参数：查找元素, 开始位置
// 返回值：索引或-1
// 改变原数组：否

const arr = ["a", "b", "c", "b", "a"];
console.log(arr.lastIndexOf("b")); // 3
console.log(arr.lastIndexOf("b", 2)); // 1
console.log(arr.lastIndexOf("d")); // -1

// 实际应用：查找最后一个匹配项
function findLastMatch(array, item) {
  return array.lastIndexOf(item);
}
```

**sort() - 数组排序**

```javascript
// 语法：arr.sort(compareFunction)
// 参数：比较函数
// 返回值：排序后的数组
// 改变原数组：是

const numbers = [3, 1, 4, 1, 5];
numbers.sort((a, b) => a - b);
console.log(numbers); // [1, 1, 3, 4, 5]

// 实际应用：对象数组排序
const users = [
  { name: "张三", age: 25 },
  { name: "李四", age: 30 },
  { name: "王五", age: 20 },
];
users.sort((a, b) => a.age - b.age);
console.log(users); // 按年龄排序
```

**reverse() - 数组反转**

```javascript
// 语法：arr.reverse()
// 参数：无
// 返回值：反转后的数组
// 改变原数组：是

const arr = [1, 2, 3, 4, 5];
arr.reverse();
console.log(arr); // [5, 4, 3, 2, 1]

// 实际应用：反转字符串
function reverseString(str) {
  return str.split("").reverse().join("");
}
```

**join() - 数组连接**

```javascript
// 语法：arr.join(separator)
// 参数：分隔符
// 返回值：字符串
// 改变原数组：否

const arr = [1, 2, 3, 4, 5];
console.log(arr.join()); // '1,2,3,4,5'
console.log(arr.join("-")); // '1-2-3-4-5'
console.log(arr.join("")); // '12345'

// 实际应用：构建查询字符串
function buildQueryString(params) {
  return Object.entries(params)
    .map(([key, value]) => `${key}=${value}`)
    .join("&");
}
```

**toString() - 数组转字符串**

```javascript
// 语法：arr.toString()
// 参数：无
// 返回值：字符串
// 改变原数组：否

const arr = [1, 2, 3, 4, 5];
console.log(arr.toString()); // '1,2,3,4,5'

// 实际应用：数组序列化
function serializeArray(array) {
  return array.toString();
}
```

---

## ES5 时代（2009 年）

> **🎯 解决的问题**：ES5 主要解决了函数式编程的需求，提供了更强大的数组遍历和操作方法，让开发者能够更优雅地处理数组数据，避免使用传统的 for 循环。

### 📝 ES5 数组方法总览

| 功能分类 | 方法          | 语法                                 | 参数            | 返回值    | 改变原数组 | 用途           |
| -------- | ------------- | ------------------------------------ | --------------- | --------- | ---------- | -------------- |
| **查询** | forEach       | `arr.forEach(callback)`              | 回调函数        | undefined | ❌         | 遍历执行       |
| **转换** | map           | `arr.map(callback)`                  | 回调函数        | 新数组    | ❌         | 数据转换       |
| **查询** | filter        | `arr.filter(callback)`               | 回调函数        | 新数组    | ❌         | 数据筛选       |
| **转换** | reduce        | `arr.reduce(callback, initial)`      | 回调函数,初始值 | 累积值    | ❌         | 数据聚合       |
| **查询** | some          | `arr.some(callback)`                 | 回调函数        | 布尔值    | ❌         | 存在性检查     |
| **查询** | every         | `arr.every(callback)`                | 回调函数        | 布尔值    | ❌         | 全部性检查     |
| **转换** | reduceRight   | `arr.reduceRight(callback, initial)` | 回调函数,初始值 | 累积值    | ❌         | 从右聚合       |
| **静态** | Array.isArray | `Array.isArray(value)`               | 要检查的值      | 布尔值    | ❌         | 检查是否为数组 |

### 📝 ES5 字符串方法总览

| 功能分类 | 方法                | 语法                            | 参数       | 返回值   | 改变原字符串 | 用途           |
| -------- | ------------------- | ------------------------------- | ---------- | -------- | ------------ | -------------- |
| **修改** | trim                | `str.trim()`                    | 无         | 新字符串 | ❌           | 去除首尾空格   |
| **静态** | String.fromCharCode | `String.fromCharCode(...codes)` | 字符码列表 | 字符串   | ❌           | 字符码转字符串 |

### 🔧 ES5 详细方法说明

#### 数组迭代方法

**forEach() - 遍历执行**

> **🎯 解决的问题**：替代传统的 for 循环，提供更简洁的数组遍历方式，避免手动管理索引，减少出错概率。

```javascript
// 语法：arr.forEach(callback)
// 参数：回调函数 (item, index, array) => void
// 返回值：undefined
// 改变原数组：否

const arr = [1, 2, 3, 4, 5];
arr.forEach((item, index) => {
  console.log(`索引${index}: ${item}`);
});

// 实际应用：DOM操作
function renderList(items, container) {
  container.innerHTML = "";
  items.forEach((item) => {
    const li = document.createElement("li");
    li.textContent = item.name;
    container.appendChild(li);
  });
}
```

**map() - 数据转换**

> **🎯 解决的问题**：提供函数式的数据转换方式，避免手动创建新数组和循环，让数据映射操作更加简洁和可读。

```javascript
// 语法：arr.map(callback)
// 参数：回调函数 (item, index, array) => newItem
// 返回值：新数组
// 改变原数组：否

const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((n) => n * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// 实际应用：数据格式化
function formatUsers(users) {
  return users.map((user) => ({
    ...user,
    displayName: `${user.firstName} ${user.lastName}`,
    isAdult: user.age >= 18,
  }));
}
```

**filter() - 数据筛选**

> **🎯 解决的问题**：提供声明式的数据过滤方式，避免手动循环和条件判断，让数据筛选逻辑更加清晰和可维护。

```javascript
// 语法：arr.filter(callback)
// 参数：回调函数 (item, index, array) => boolean
// 返回值：新数组
// 改变原数组：否

const numbers = [1, 2, 3, 4, 5, 6];
const evens = numbers.filter((n) => n % 2 === 0);
console.log(evens); // [2, 4, 6]

// 实际应用：数据过滤
function getActiveUsers(users) {
  return users.filter(
    (user) =>
      user.isActive && user.lastLogin > Date.now() - 7 * 24 * 60 * 60 * 1000
  );
}
```

**reduce() - 数据聚合**

```javascript
// 语法：arr.reduce(callback, initialValue)
// 参数：回调函数 (accumulator, item, index, array) => newAccumulator, 初始值
// 返回值：累积值
// 改变原数组：否

const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum); // 15

// 实际应用：数据统计
function getStats(orders) {
  return orders.reduce(
    (stats, order) => {
      stats.total += order.amount;
      stats.count++;
      stats.average = stats.total / stats.count;
      return stats;
    },
    { total: 0, count: 0, average: 0 }
  );
}
```

**some() - 存在性检查**

```javascript
// 语法：arr.some(callback)
// 参数：回调函数 (item, index, array) => boolean
// 返回值：布尔值
// 改变原数组：否

const numbers = [1, 2, 3, 4, 5];
const hasEven = numbers.some((n) => n % 2 === 0);
console.log(hasEven); // true

// 实际应用：权限检查
function hasAnyPermission(user, permissions) {
  return permissions.some((permission) =>
    user.permissions.includes(permission)
  );
}
```

**every() - 全部性检查**

```javascript
// 语法：arr.every(callback)
// 参数：回调函数 (item, index, array) => boolean
// 返回值：布尔值
// 改变原数组：否

const numbers = [2, 4, 6, 8];
const allEven = numbers.every((n) => n % 2 === 0);
console.log(allEven); // true

// 实际应用：表单验证
function validateForm(formData) {
  const requiredFields = ["name", "email", "phone"];
  return requiredFields.every(
    (field) => formData[field] && formData[field].trim() !== ""
  );
}
```

**reduceRight() - 从右到左数据聚合**

```javascript
// 语法：arr.reduceRight(callback, initialValue)
// 参数：回调函数 (accumulator, item, index, array) => newAccumulator, 初始值
// 返回值：累积值
// 改变原数组：否

const numbers = [1, 2, 3, 4, 5];
const result = numbers.reduceRight((acc, n) => acc - n, 0);
console.log(result); // -15 (0-5-4-3-2-1)

// 实际应用：从右到左处理数据
function processFromRight(array) {
  return array.reduceRight((acc, item) => {
    acc.push(item * 2);
    return acc;
  }, []);
}
```

#### 数组静态方法

**Array.isArray() - 检查是否为数组**

```javascript
// 语法：Array.isArray(value)
// 参数：要检查的值
// 返回值：布尔值

console.log(Array.isArray([1, 2, 3])); // true
console.log(Array.isArray("hello")); // false
console.log(Array.isArray(null)); // false
console.log(Array.isArray(undefined)); // false

// 实际应用：类型检查
function processData(data) {
  if (Array.isArray(data)) {
    return data.map((item) => item * 2);
  }
  return [data];
}
```

#### 字符串方法

**trim() - 去除首尾空格**

```javascript
// 语法：str.trim()
// 参数：无
// 返回值：新字符串
// 改变原字符串：否

const str = "  Hello World  ";
const trimmed = str.trim();
console.log(trimmed); // 'Hello World'

// 实际应用：表单数据清理
function cleanFormData(data) {
  return Object.keys(data).reduce((cleaned, key) => {
    cleaned[key] = data[key].trim();
    return cleaned;
  }, {});
}
```

**String.fromCharCode() - 字符码转字符串**

```javascript
// 语法：String.fromCharCode(...codes)
// 参数：字符码列表
// 返回值：字符串

console.log(String.fromCharCode(65, 66, 67)); // 'ABC'
console.log(String.fromCharCode(97, 98, 99)); // 'abc'
console.log(String.fromCharCode(8364)); // '€'

// 实际应用：生成随机字符串
function generateRandomString(length) {
  let result = "";
  for (let i = 0; i < length; i++) {
    const randomCode = Math.floor(Math.random() * 26) + 97; // a-z
    result += String.fromCharCode(randomCode);
  }
  return result;
}
```

---

## ES2015/ES6 时代（2015 年）

> **🎯 解决的问题**：ES6 是 JavaScript 的重大更新，解决了模块化、异步编程、类型安全等问题。新增的数组和字符串方法让代码更简洁、更易读，同时提供了更好的性能。

### 📝 ES6 数组方法总览

| 功能分类 | 方法       | 语法                                 | 参数                       | 返回值                 | 改变原数组 | 用途                   |
| -------- | ---------- | ------------------------------------ | -------------------------- | ---------------------- | ---------- | ---------------------- |
| **静态** | Array.from | `Array.from(arrayLike, mapFn)`       | 类数组对象,映射函数        | 新数组                 | ❌         | 类数组转数组           |
| **静态** | Array.of   | `Array.of(...elements)`              | 元素列表                   | 新数组                 | ❌         | 创建数组               |
| **修改** | fill       | `arr.fill(value, start, end)`        | 填充值,开始位置,结束位置   | 填充后的数组           | ✅         | 填充数组               |
| **修改** | copyWithin | `arr.copyWithin(target, start, end)` | 目标位置,开始位置,结束位置 | 复制后的数组           | ✅         | 内部复制               |
| **查询** | keys       | `arr.keys()`                         | 无                         | 迭代器                 | ❌         | 索引迭代器             |
| **查询** | values     | `arr.values()`                       | 无                         | 迭代器                 | ❌         | 值迭代器               |
| **查询** | entries    | `arr.entries()`                      | 无                         | 迭代器                 | ❌         | 键值对迭代器           |
| **查询** | find       | `arr.find(callback)`                 | 回调函数                   | 找到的元素或 undefined | ❌         | 查找第一个匹配元素     |
| **查询** | findIndex  | `arr.findIndex(callback)`            | 回调函数                   | 找到的索引或-1         | ❌         | 查找第一个匹配元素索引 |

### 📝 ES6 字符串方法总览

| 功能分类 | 方法                 | 语法                                     | 参数              | 返回值   | 兼容性 | 用途         |
| -------- | -------------------- | ---------------------------------------- | ----------------- | -------- | ------ | ------------ |
| **修改** | 模板字符串           | `` `string ${expr}` ``                   | 表达式            | 新字符串 | ES2015 | 字符串插值   |
| **查询** | startsWith           | `str.startsWith(substring, start)`       | 子字符串,开始位置 | 布尔值   | ES2015 | 开头检查     |
| **查询** | endsWith             | `str.endsWith(substring, end)`           | 子字符串,结束位置 | 布尔值   | ES2015 | 结尾检查     |
| **修改** | repeat               | `str.repeat(count)`                      | 重复次数          | 新字符串 | ES2015 | 重复字符串   |
| **静态** | String.fromCodePoint | `String.fromCodePoint(...codes)`         | 码点列表          | 字符串   | ES2015 | 码点转字符串 |
| **静态** | String.raw           | `String.raw(template, ...substitutions)` | 模板,替换值       | 字符串   | ES2015 | 原始字符串   |

### 🔧 ES6 详细方法说明

#### 数组静态方法

**Array.from() - 类数组转数组**

> **🎯 解决的问题**：解决了类数组对象（如 NodeList、arguments）无法使用数组方法的问题，让 DOM 操作和函数参数处理更加便捷。

```javascript
// 语法：Array.from(arrayLike, mapFn)
// 参数：类数组对象, 映射函数
// 返回值：新数组
// 改变原数组：否

const nodeList = document.querySelectorAll("div");
const divArray = Array.from(nodeList);
console.log(divArray); // [div, div, div, ...]

// 实际应用：转换Set/Map
const set = new Set([1, 2, 3, 4, 5]);
const array = Array.from(set);
console.log(array); // [1, 2, 3, 4, 5]

// 带映射函数
const doubled = Array.from([1, 2, 3], (x) => x * 2);
console.log(doubled); // [2, 4, 6]
```

**Array.of() - 创建数组**

```javascript
// 语法：Array.of(...elements)
// 参数：元素列表
// 返回值：新数组
// 改变原数组：否

const arr1 = Array.of(1, 2, 3);
console.log(arr1); // [1, 2, 3]

const arr2 = Array.of(7);
console.log(arr2); // [7] (不是长度为7的数组)

// 实际应用：避免Array构造函数的陷阱
const bad = new Array(3); // [empty × 3]
const good = Array.of(3); // [3]
```

#### 数组实例方法

**fill() - 填充数组**

```javascript
// 语法：arr.fill(value, start, end)
// 参数：填充值, 开始位置, 结束位置
// 返回值：填充后的数组
// 改变原数组：是

const arr = [1, 2, 3, 4, 5];
arr.fill(0, 1, 3);
console.log(arr); // [1, 0, 0, 4, 5]

// 实际应用：初始化数组
function createMatrix(rows, cols, defaultValue = 0) {
  return Array(rows)
    .fill()
    .map(() => Array(cols).fill(defaultValue));
}
```

**copyWithin() - 内部复制**

```javascript
// 语法：arr.copyWithin(target, start, end)
// 参数：目标位置, 开始位置, 结束位置
// 返回值：复制后的数组
// 改变原数组：是

const arr = [1, 2, 3, 4, 5];
arr.copyWithin(0, 3, 5);
console.log(arr); // [4, 5, 3, 4, 5]

// 实际应用：数组重排
function shiftArray(arr, positions) {
  const result = [...arr];
  return result.copyWithin(0, positions);
}
```

#### 字符串方法

**模板字符串 - 字符串插值**

```javascript
// 语法：`string ${expression}`
// 参数：表达式
// 返回值：新字符串

const name = "张三";
const age = 25;
const message = `你好，我是${name}，今年${age}岁`;
console.log(message); // '你好，我是张三，今年25岁'

// 实际应用：HTML模板
function createUserCard(user) {
  return `
    <div class="user-card">
      <h3>${user.name}</h3>
      <p>年龄: ${user.age}</p>
      <p>邮箱: ${user.email}</p>
    </div>
  `;
}
```

**startsWith() - 开头检查**

```javascript
// 语法：str.startsWith(substring, start)
// 参数：子字符串,开始位置
// 返回值：布尔值

const str = "Hello World";
console.log(str.startsWith("Hello")); // true
console.log(str.startsWith("World", 6)); // true

// 实际应用：URL检查
function isSecureUrl(url) {
  return url.startsWith("https://");
}
```

**endsWith() - 结尾检查**

```javascript
// 语法：str.endsWith(substring, end)
// 参数：子字符串,结束位置
// 返回值：布尔值

const str = "Hello World";
console.log(str.endsWith("World")); // true
console.log(str.endsWith("Hello", 5)); // true

// 实际应用：文件类型检查
function isImageFile(filename) {
  return (
    filename.toLowerCase().endsWith(".jpg") ||
    filename.toLowerCase().endsWith(".png")
  );
}
```

**repeat() - 重复字符串**

```javascript
// 语法：str.repeat(count)
// 参数：重复次数
// 返回值：新字符串

const str = "Hello";
console.log(str.repeat(3)); // 'HelloHelloHello'

// 实际应用：生成分隔线
function createSeparator(char = "-", length = 20) {
  return char.repeat(length);
}
```

**String.fromCodePoint() - 码点转字符串**

```javascript
// 语法：String.fromCodePoint(...codes)
// 参数：码点列表
// 返回值：字符串

console.log(String.fromCodePoint(65, 66, 67)); // 'ABC'
console.log(String.fromCodePoint(0x1f600)); // '😀'
console.log(String.fromCodePoint(0x1f601, 0x1f602)); // '😁😂'

// 实际应用：处理Unicode字符
function getEmoji(codePoint) {
  return String.fromCodePoint(codePoint);
}
```

**String.raw() - 原始字符串**

```javascript
// 语法：String.raw(template, ...substitutions)
// 参数：模板, 替换值
// 返回值：字符串

const path = String.raw`C:\Users\Documents\file.txt`;
console.log(path); // 'C:\Users\Documents\file.txt'

// 实际应用：处理正则表达式
function createRegex(pattern) {
  return new RegExp(String.raw`${pattern}`);
}
```

---

## ES2016 时代（2016 年）

> **🎯 解决的问题**：ES2016 引入了 `includes()` 方法，解决了 `indexOf()` 无法正确处理 `NaN` 的问题，让数组和字符串的包含检查更加可靠。

### 📝 ES2016 数组方法总览

| 功能分类 | 方法     | 语法                        | 参数              | 返回值 | 改变原数组 | 用途         |
| -------- | -------- | --------------------------- | ----------------- | ------ | ---------- | ------------ |
| **查询** | includes | `arr.includes(item, start)` | 查找元素,开始位置 | 布尔值 | ❌         | 检查元素存在 |

### 🔧 ES2016 详细方法说明

**includes() - 检查元素是否存在**

```javascript
// 语法：arr.includes(item, start)
// 参数：查找元素,开始位置
// 返回值：布尔值
// 改变原数组：否

const arr = [1, 2, 3, NaN];
console.log(arr.includes(2)); // true
console.log(arr.includes(2, 2)); // false
console.log(arr.includes(NaN)); // true (indexOf无法找到NaN)

// 实际应用：权限检查
function hasPermission(user, permission) {
  return user.permissions.includes(permission);
}
```

---

## ES2017 时代（2017 年）

> **🎯 解决的问题**：ES2017 引入了字符串填充方法 `padStart()` 和 `padEnd()`，解决了字符串格式化的问题，让数字、时间等数据的显示更加统一和美观。

### 📝 ES2017 字符串方法总览

| 功能分类 | 方法     | 语法                              | 参数            | 返回值   | 改变原字符串 | 用途   |
| -------- | -------- | --------------------------------- | --------------- | -------- | ------------ | ------ |
| **修改** | padStart | `str.padStart(length, padString)` | 长度,填充字符串 | 新字符串 | ❌           | 前填充 |
| **修改** | padEnd   | `str.padEnd(length, padString)`   | 长度,填充字符串 | 新字符串 | ❌           | 后填充 |

### 🔧 ES2017 详细方法说明

**padStart() - 前填充**

```javascript
// 语法：str.padStart(length, padString)
// 参数：长度,填充字符串
// 返回值：新字符串
// 改变原字符串：否

const str = "5";
console.log(str.padStart(3, "0")); // '005'

// 实际应用：格式化数字
function formatNumber(num, digits = 3) {
  return num.toString().padStart(digits, "0");
}
```

**padEnd() - 后填充**

```javascript
// 语法：str.padEnd(length, padString)
// 参数：长度,填充字符串
// 返回值：新字符串
// 改变原字符串：否

const str = "Hello";
console.log(str.padEnd(10, "*")); // 'Hello*****'

// 实际应用：对齐文本
function alignText(texts, width) {
  return texts.map((text) => text.padEnd(width, " "));
}
```

---

## ES2019 时代（2019 年）

> **🎯 解决的问题**：ES2019 引入了 `flat()` 和 `flatMap()` 方法，解决了嵌套数组处理的痛点，让数组扁平化操作更加简洁，避免了复杂的递归实现。

### 📝 ES2019 数组方法总览

| 功能分类 | 方法    | 语法                    | 参数     | 返回值     | 改变原数组 | 用途         |
| -------- | ------- | ----------------------- | -------- | ---------- | ---------- | ------------ |
| **转换** | flat    | `arr.flat(depth)`       | 深度     | 扁平化数组 | ❌         | 数组扁平化   |
| **转换** | flatMap | `arr.flatMap(callback)` | 回调函数 | 新数组     | ❌         | 映射后扁平化 |

### 🔧 ES2019 详细方法说明

**flat() - 数组扁平化**

> **🎯 解决的问题**：解决了嵌套数组处理的痛点，避免了复杂的递归实现，让数组扁平化操作更加简洁和高效。

```javascript
// 语法：arr.flat(depth)
// 参数：深度（默认1）
// 返回值：扁平化数组
// 改变原数组：否

const nested = [1, [2, 3], [4, [5, 6]]];
console.log(nested.flat()); // [1, 2, 3, 4, [5, 6]]
console.log(nested.flat(2)); // [1, 2, 3, 4, 5, 6]
console.log(nested.flat(Infinity)); // [1, 2, 3, 4, 5, 6]

// 实际应用：处理嵌套数据
function flattenData(data) {
  return data.flat(Infinity);
}
```

**flatMap() - 映射后扁平化**

```javascript
// 语法：arr.flatMap(callback)
// 参数：回调函数
// 返回值：新数组
// 改变原数组：否

const words = ["hello world", "javascript is awesome"];
const letters = words.flatMap((word) => word.split(" "));
console.log(letters); // ['hello', 'world', 'javascript', 'is', 'awesome']

// 实际应用：处理嵌套数组
const numbers = [1, 2, 3, 4];
const doubled = numbers.flatMap((n) => [n, n * 2]);
console.log(doubled); // [1, 2, 2, 4, 3, 6, 4, 8]
```

---

## ES2021 时代（2021 年）

> **🎯 解决的问题**：ES2021 引入了 `replaceAll()` 方法，解决了 `replace()` 只能替换第一个匹配项的问题，让全局字符串替换更加简洁，避免了使用正则表达式的复杂性。

### 📝 ES2021 字符串方法总览

| 功能分类 | 方法       | 语法                              | 参数          | 返回值   | 改变原字符串 | 用途     |
| -------- | ---------- | --------------------------------- | ------------- | -------- | ------------ | -------- |
| **修改** | replaceAll | `str.replaceAll(search, replace)` | 查找值,替换值 | 新字符串 | ❌           | 全局替换 |

### 🔧 ES2021 详细方法说明

**replaceAll() - 全局替换**

```javascript
// 语法：str.replaceAll(search, replace)
// 参数：查找值,替换值
// 返回值：新字符串
// 改变原字符串：否

const str = "Hello World, Hello JavaScript";
const replaced = str.replaceAll("Hello", "Hi");
console.log(replaced); // 'Hi World, Hi JavaScript'

// 实际应用：文本清理
function cleanText(text) {
  return text
    .replaceAll("\n", " ")
    .replaceAll("\t", " ")
    .replaceAll(/\s+/g, " ")
    .trim();
}
```

---

## ES2022 时代（2022 年）

> **🎯 解决的问题**：ES2022 引入了 `at()` 方法和不可变操作方法（`toReversed`、`toSorted` 等），解决了负索引访问和函数式编程中避免修改原数组的问题，让代码更加安全和可预测。

### 📝 ES2022 数组方法总览

| 功能分类 | 方法       | 语法                                          | 参数                       | 返回值 | 改变原数组 | 用途     |
| -------- | ---------- | --------------------------------------------- | -------------------------- | ------ | ---------- | -------- |
| **查询** | at         | `arr.at(index)`                               | 索引                       | 元素   | ❌         | 索引访问 |
| **排序** | toReversed | `arr.toReversed()`                            | 无                         | 新数组 | ❌         | 反转副本 |
| **排序** | toSorted   | `arr.toSorted(compareFn)`                     | 比较函数                   | 新数组 | ❌         | 排序副本 |
| **修改** | toSpliced  | `arr.toSpliced(start, deleteCount, ...items)` | 开始位置,删除数量,插入元素 | 新数组 | ❌         | 拼接副本 |
| **修改** | with       | `arr.with(index, value)`                      | 索引,新值                  | 新数组 | ❌         | 替换副本 |

### 📝 ES2022 字符串方法总览

| 功能分类 | 方法 | 语法            | 参数 | 返回值 | 改变原字符串 | 用途     |
| -------- | ---- | --------------- | ---- | ------ | ------------ | -------- |
| **查询** | at   | `str.at(index)` | 索引 | 字符   | ❌           | 字符访问 |

### 🔧 ES2022 详细方法说明

#### 数组方法

**at() - 索引访问**

> **🎯 解决的问题**：解决了负索引访问的痛点，让获取数组最后一个元素更加简洁，避免了 `arr[arr.length - 1]` 的冗长写法。

```javascript
// 语法：arr.at(index)
// 参数：索引（支持负数）
// 返回值：元素
// 改变原数组：否

const arr = [1, 2, 3, 4, 5];
console.log(arr.at(0)); // 1
console.log(arr.at(-1)); // 5
console.log(arr.at(-2)); // 4

// 实际应用：获取最后一个元素
function getLastItem(array) {
  return array.at(-1);
}
```

**toReversed() - 反转副本**

```javascript
// 语法：arr.toReversed()
// 参数：无
// 返回值：新数组
// 改变原数组：否

const original = [1, 2, 3, 4, 5];
const reversed = original.toReversed();
console.log(original); // [1, 2, 3, 4, 5] (原数组不变)
console.log(reversed); // [5, 4, 3, 2, 1]

// 实际应用：不改变原数组的反转
function reverseArray(array) {
  return array.toReversed();
}
```

**toSorted() - 排序副本**

```javascript
// 语法：arr.toSorted(compareFn)
// 参数：比较函数
// 返回值：新数组
// 改变原数组：否

const original = [3, 1, 4, 1, 5];
const sorted = original.toSorted();
console.log(original); // [3, 1, 4, 1, 5] (原数组不变)
console.log(sorted); // [1, 1, 3, 4, 5]

// 实际应用：不改变原数组的排序
function sortArray(array) {
  return array.toSorted((a, b) => a - b);
}
```

**toSpliced() - 拼接副本**

```javascript
// 语法：arr.toSpliced(start, deleteCount, ...items)
// 参数：开始位置, 删除数量, 插入元素
// 返回值：新数组
// 改变原数组：否

const original = [1, 2, 3, 4, 5];
const spliced = original.toSpliced(1, 2, "a", "b");
console.log(original); // [1, 2, 3, 4, 5] (原数组不变)
console.log(spliced); // [1, 'a', 'b', 4, 5]

// 实际应用：不改变原数组的拼接
function spliceArray(array, start, deleteCount, ...items) {
  return array.toSpliced(start, deleteCount, ...items);
}
```

**with() - 替换副本**

```javascript
// 语法：arr.with(index, value)
// 参数：索引, 新值
// 返回值：新数组
// 改变原数组：否

const original = [1, 2, 3, 4, 5];
const modified = original.with(2, "three");
console.log(original); // [1, 2, 3, 4, 5] (原数组不变)
console.log(modified); // [1, 2, 'three', 4, 5]

// 实际应用：不改变原数组的替换
function updateArray(array, index, value) {
  return array.with(index, value);
}
```

#### 字符串方法

**at() - 字符访问**

```javascript
// 语法：str.at(index)
// 参数：索引（支持负数）
// 返回值：字符
// 改变原字符串：否

const str = "Hello World";
console.log(str.at(0)); // 'H'
console.log(str.at(-1)); // 'd'
console.log(str.at(-2)); // 'l'

// 实际应用：获取最后一个字符
function getLastChar(str) {
  return str.at(-1);
}
```

## 实际应用场景

### 1. 数据处理场景

**用户数据筛选和排序**

```javascript
const users = [
  { id: 1, name: "张三", age: 25, city: "北京", salary: 8000 },
  { id: 2, name: "李四", age: 30, city: "上海", salary: 12000 },
  { id: 3, name: "王五", age: 28, city: "北京", salary: 10000 },
  { id: 4, name: "赵六", age: 35, city: "广州", salary: 15000 },
  { id: 5, name: "钱七", age: 22, city: "上海", salary: 6000 },
];

// 场景1：筛选北京用户并按年龄排序
const beijingUsers = users
  .filter((user) => user.city === "北京")
  .sort((a, b) => a.age - b.age);

// 场景2：计算平均薪资
const averageSalary =
  users.reduce((sum, user) => sum + user.salary, 0) / users.length;

// 场景3：按城市分组
const usersByCity = users.reduce((groups, user) => {
  const city = user.city;
  if (!groups[city]) {
    groups[city] = [];
  }
  groups[city].push(user);
  return groups;
}, {});
```

### 2. 表单数据处理

**表单验证和数据清理**

```javascript
const formData = {
  username: "  user123  ",
  email: "USER@EXAMPLE.COM",
  phone: "138-1234-5678",
  age: "25",
  hobbies: ["reading", "swimming", "coding"],
};

// 数据清理函数
function cleanFormData(data) {
  return {
    username: data.username.trim().toLowerCase(),
    email: data.email.trim().toLowerCase(),
    phone: data.phone.replace(/-/g, ""),
    age: parseInt(data.age),
    hobbies: data.hobbies.map((hobby) => hobby.trim().toLowerCase()),
  };
}

// 表单验证
function validateForm(data) {
  const errors = [];

  if (!data.username || data.username.length < 3) {
    errors.push("用户名至少3个字符");
  }

  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(data.email)) {
    errors.push("邮箱格式不正确");
  }

  const phoneRegex = /^1[3-9]\d{9}$/;
  if (!phoneRegex.test(data.phone)) {
    errors.push("手机号格式不正确");
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}
```

### 3. 搜索和过滤功能

**实时搜索实现**

```javascript
const articles = [
  {
    id: 1,
    title: "JavaScript基础教程",
    content: "学习JavaScript的基本语法...",
    tags: ["javascript", "基础"],
  },
  {
    id: 2,
    title: "React开发指南",
    content: "React框架的使用方法...",
    tags: ["react", "前端"],
  },
  {
    id: 3,
    title: "Node.js后端开发",
    content: "使用Node.js构建后端服务...",
    tags: ["nodejs", "后端"],
  },
];

// 搜索函数
function searchArticles(articles, keyword) {
  if (!keyword.trim()) return articles;

  const lowerKeyword = keyword.toLowerCase();

  return articles.filter(
    (article) =>
      article.title.toLowerCase().includes(lowerKeyword) ||
      article.content.toLowerCase().includes(lowerKeyword) ||
      article.tags.some((tag) => tag.toLowerCase().includes(lowerKeyword))
  );
}

// 高级搜索：多条件筛选
function advancedSearch(articles, filters) {
  return articles.filter((article) => {
    if (filters.keyword) {
      const keyword = filters.keyword.toLowerCase();
      const matchesKeyword =
        article.title.toLowerCase().includes(keyword) ||
        article.content.toLowerCase().includes(keyword) ||
        article.tags.some((tag) => tag.toLowerCase().includes(keyword));

      if (!matchesKeyword) return false;
    }

    if (filters.tags && filters.tags.length > 0) {
      const hasMatchingTag = filters.tags.some((tag) =>
        article.tags.includes(tag)
      );
      if (!hasMatchingTag) return false;
    }

    return true;
  });
}
```

---

## 性能对比与最佳实践

### 1. 数组遍历性能对比

**性能测试结果（基于 10000 个元素的数组）：**

```javascript
// 性能测试函数
function performanceTest(name, fn, iterations = 1000) {
  const start = performance.now();
  for (let i = 0; i < iterations; i++) {
    fn();
  }
  const end = performance.now();
  console.log(`${name}: ${(end - start).toFixed(2)}ms`);
}

const testArray = Array.from({ length: 10000 }, (_, i) => i);

// 测试各种遍历方法
performanceTest("for循环", () => {
  for (let i = 0; i < testArray.length; i++) {
    testArray[i] * 2;
  }
});

performanceTest("for...of", () => {
  for (const item of testArray) {
    item * 2;
  }
});

performanceTest("forEach", () => {
  testArray.forEach((item) => item * 2);
});

performanceTest("map", () => {
  testArray.map((item) => item * 2);
});

// 典型结果（相对性能）：
// for循环: 最快
// for...of: 较快
// forEach: 中等
// map: 较慢（因为创建新数组）
```

### 2. 最佳实践建议

**数组操作最佳实践：**

```javascript
// ✅ 推荐：使用 for 循环进行简单遍历
const numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i]);
}

// ✅ 推荐：使用 for...of 进行值遍历
for (const number of numbers) {
  console.log(number);
}

// ✅ 推荐：使用 map 进行数据转换
const doubled = numbers.map((n) => n * 2);

// ✅ 推荐：使用 filter 进行数据筛选
const evens = numbers.filter((n) => n % 2 === 0);

// ✅ 推荐：使用 reduce 进行数据聚合
const sum = numbers.reduce((acc, n) => acc + n, 0);

// ❌ 避免：在循环中创建函数
// 不好的做法
const badExample = [];
for (let i = 0; i < numbers.length; i++) {
  badExample.push(function () {
    return numbers[i];
  });
}

// ✅ 好的做法
const goodExample = numbers.map((n) => () => n);
```

**字符串操作最佳实践：**

```javascript
// ✅ 推荐：使用模板字符串进行字符串拼接
const name = "张三";
const age = 25;
const message = `你好，我是${name}，今年${age}岁`;

// ✅ 推荐：大量字符串拼接使用数组join()
function buildLargeString(parts) {
  const result = [];
  for (const part of parts) {
    result.push(part);
  }
  return result.join("");
}

// ✅ 推荐：使用 includes 进行字符串包含检查
if (text.includes("keyword")) {
  // 处理逻辑
}

// ❌ 避免：频繁的字符串拼接
// 不好的做法
let badString = "";
for (let i = 0; i < 1000; i++) {
  badString += "a";
}

// ✅ 好的做法
const goodString = "a".repeat(1000);
```

---

## 面试常考算法

### 1. 数组去重方法对比

```javascript
// 方法1：使用 Set
function unique1(arr) {
  return [...new Set(arr)];
}

// 方法2：使用 filter + indexOf
function unique2(arr) {
  return arr.filter((item, index) => arr.indexOf(item) === index);
}

// 方法3：使用 reduce
function unique3(arr) {
  return arr.reduce((acc, current) => {
    if (!acc.includes(current)) {
      acc.push(current);
    }
    return acc;
  }, []);
}

// 方法4：使用 Map
function unique4(arr) {
  const map = new Map();
  return arr.filter((item) => {
    if (map.has(item)) {
      return false;
    }
    map.set(item, true);
    return true;
  });
}

// 性能测试
const testArray = Array.from({ length: 10000 }, () =>
  Math.floor(Math.random() * 1000)
);

console.time("Set方法");
unique1(testArray);
console.timeEnd("Set方法");

console.time("filter方法");
unique2(testArray);
console.timeEnd("filter方法");

console.time("reduce方法");
unique3(testArray);
console.timeEnd("reduce方法");

console.time("Map方法");
unique4(testArray);
console.timeEnd("Map方法");

// 典型结果：Set方法 > Map方法 > filter方法 > reduce方法
```

### 2. 数组扁平化实现

```javascript
// 方法1：使用 flat()
function flatten1(arr) {
  return arr.flat(Infinity);
}

// 方法2：使用递归
function flatten2(arr) {
  const result = [];
  for (const item of arr) {
    if (Array.isArray(item)) {
      result.push(...flatten2(item));
    } else {
      result.push(item);
    }
  }
  return result;
}

// 方法3：使用 reduce
function flatten3(arr) {
  return arr.reduce((acc, current) => {
    return acc.concat(Array.isArray(current) ? flatten3(current) : current);
  }, []);
}

// 方法4：使用 while 循环
function flatten4(arr) {
  let result = [...arr];
  while (result.some((item) => Array.isArray(item))) {
    result = [].concat(...result);
  }
  return result;
}

// 测试
const nestedArray = [1, [2, [3, [4, 5]]], 6, [7, 8]];
console.log(flatten1(nestedArray)); // [1, 2, 3, 4, 5, 6, 7, 8]
console.log(flatten2(nestedArray)); // [1, 2, 3, 4, 5, 6, 7, 8]
console.log(flatten3(nestedArray)); // [1, 2, 3, 4, 5, 6, 7, 8]
console.log(flatten4(nestedArray)); // [1, 2, 3, 4, 5, 6, 7, 8]
```

### 3. 深拷贝实现

```javascript
// 方法1：使用 JSON（有限制）
function deepClone1(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// 方法2：递归实现
function deepClone2(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }

  if (obj instanceof Array) {
    return obj.map((item) => deepClone2(item));
  }

  if (typeof obj === "object") {
    const cloned = {};
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        cloned[key] = deepClone2(obj[key]);
      }
    }
    return cloned;
  }
}

// 方法3：使用 Map 处理循环引用
function deepClone3(obj, map = new Map()) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }

  if (map.has(obj)) {
    return map.get(obj);
  }

  const cloned = Array.isArray(obj) ? [] : {};
  map.set(obj, cloned);

  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloned[key] = deepClone3(obj[key], map);
    }
  }

  return cloned;
}

// 测试
const original = {
  name: "张三",
  age: 25,
  hobbies: ["读书", "游泳"],
  address: {
    city: "北京",
    district: "朝阳区",
  },
  birthday: new Date("1998-01-01"),
};

const cloned = deepClone3(original);
console.log(cloned);
console.log(cloned !== original); // true
console.log(cloned.hobbies !== original.hobbies); // true
```

---

## 📋 总结

### 记忆技巧

1. **分类记忆**：按功能分类（增删改查）
2. **对比记忆**：相似方法的区别（slice vs splice）
3. **参数记忆**：参数顺序和含义
4. **返回值记忆**：返回什么类型的数据
5. **副作用记忆**：是否改变原数组/字符串

### 使用建议

1. **优先使用 ES6+方法**：更简洁、更安全
2. **注意性能差异**：大数据量时选择合适的方法
3. **链式调用**：合理组合多个方法
4. **错误处理**：注意边界情况和异常处理
5. **代码可读性**：选择语义明确的方法名

## 数组和字符串同名方法对比

### 1. **concat() - 拼接方法**

**数组 concat()**

```javascript
const arr1 = [1, 2];
const arr2 = [3, 4];
const result = arr1.concat(arr2); // [1, 2, 3, 4]
// 参数：要拼接的元素（数组会被展开）
// 返回值：新数组
```

**字符串 concat()**

```javascript
const str1 = "Hello";
const str2 = "World";
const result = str1.concat(" ", str2); // "Hello World"
// 参数：要拼接的字符串
// 返回值：新字符串
```

### 2. **slice() - 截取方法**

**数组 slice()**

```javascript
const arr = [1, 2, 3, 4, 5];
const result = arr.slice(1, 3); // [2, 3]
// 参数：开始位置, 结束位置（不包含）
// 返回值：新数组
```

**字符串 slice()**

```javascript
const str = "Hello World";
const result = str.slice(0, 5); // "Hello"
// 参数：开始位置, 结束位置（不包含）
// 返回值：新字符串
```

### 3. **indexOf() - 查找方法**

**数组 indexOf()**

```javascript
const arr = ["a", "b", "c", "b"];
const index = arr.indexOf("b"); // 1
// 参数：查找元素, 开始位置
// 返回值：索引或-1
```

**字符串 indexOf()**

```javascript
const str = "Hello World";
const index = str.indexOf("World"); // 6
// 参数：子字符串, 开始位置
// 返回值：索引或-1
```

### 4. **lastIndexOf() - 最后查找方法**

**数组 lastIndexOf()**

```javascript
const arr = ["a", "b", "c", "b"];
const index = arr.lastIndexOf("b"); // 3
// 参数：查找元素, 开始位置
// 返回值：索引或-1
```

**字符串 lastIndexOf()**

```javascript
const str = "Hello World, Hello JavaScript";
const index = str.lastIndexOf("Hello"); // 13
// 参数：子字符串, 开始位置
// 返回值：索引或-1
```

### 5. **includes() - 包含检查方法**

**数组 includes()**

```javascript
const arr = [1, 2, 3, NaN];
const has = arr.includes(2); // true
const hasNaN = arr.includes(NaN); // true
// 参数：查找元素, 开始位置
// 返回值：布尔值
```

**字符串 includes()**

```javascript
const str = "Hello World";
const has = str.includes("World"); // true
// 参数：子字符串, 开始位置
// 返回值：布尔值
```

### 6. **toString() - 转字符串方法**

**数组 toString()**

```javascript
const arr = [1, 2, 3, 4, 5];
const str = arr.toString(); // "1,2,3,4,5"
// 参数：无
// 返回值：字符串（用逗号分隔）
```

**字符串 toString()**

```javascript
const str = "Hello World";
const result = str.toString(); // "Hello World"
// 参数：无
// 返回值：字符串（原字符串）
```

### 7. **at() - 索引访问方法（ES2022）**

**数组 at()**

```javascript
const arr = [1, 2, 3, 4, 5];
const item = arr.at(-1); // 5
// 参数：索引（支持负数）
// 返回值：元素
```

**字符串 at()**

```javascript
const str = "Hello World";
const char = str.at(-1); // "d"
// 参数：索引（支持负数）
// 返回值：字符
```
