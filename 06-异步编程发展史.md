# 异步编程发展史

## 📚 目录

- [回调函数时代（ES1-ES5）](#回调函数时代es1-es5)
- [Promise 时代（ES6）](#promise时代es6)
- [Generator 时代（ES6）](#generator时代es6)
- [async/await 时代（ES2017）](#asyncawait时代es2017)
- [现代异步模式（ES2018+）](#现代异步模式es2018)
- [实际应用场景](#实际应用场景)
- [性能对比与最佳实践](#性能对比与最佳实践)
- [面试常考问题](#面试常考问题)

---

## 回调函数时代（ES1-ES5）

### 📝 回调函数特性

| 特性               | 语法                     | 示例                                          | 用途      |
| ------------------ | ------------------------ | --------------------------------------------- | --------- |
| **回调函数**       | `function(callback)`     | `setTimeout(callback, 1000)`                  | 异步执行  |
| **事件监听**       | `addEventListener`       | `element.addEventListener('click', callback)` | 事件处理  |
| **XMLHttpRequest** | `xhr.onreadystatechange` | `xhr.onreadystatechange = callback`           | AJAX 请求 |

### 🔧 详细说明

**回调函数 - 基础异步**

> **🎯 解决的问题**：解决了 JavaScript 单线程执行的问题，让程序能够处理异步操作。

```javascript
// 基础回调函数
function fetchData(callback) {
  setTimeout(() => {
    const data = { name: "张三", age: 25 };
    callback(data);
  }, 1000);
}

fetchData((data) => {
  console.log("获取到数据:", data);
});

// 实际应用：文件读取
function readFile(filename, callback) {
  // 模拟文件读取
  setTimeout(() => {
    const content = `文件内容: ${filename}`;
    callback(null, content);
  }, 500);
}

readFile("test.txt", (error, content) => {
  if (error) {
    console.error("读取失败:", error);
  } else {
    console.log("文件内容:", content);
  }
});
```

**回调地狱问题**

```javascript
// 回调地狱示例
function getUserData(userId, callback) {
  // 第一步：获取用户信息
  getUser(userId, (user) => {
    // 第二步：获取用户权限
    getPermissions(user.id, (permissions) => {
      // 第三步：获取用户设置
      getSettings(user.id, (settings) => {
        // 第四步：获取用户偏好
        getPreferences(user.id, (preferences) => {
          // 最终回调
          callback({
            user,
            permissions,
            settings,
            preferences,
          });
        });
      });
    });
  });
}

// 问题：
// 1. 代码嵌套过深
// 2. 错误处理困难
// 3. 代码可读性差
// 4. 难以维护和测试
```

---

## Promise 时代（ES6）

> **🎯 解决的问题**：解决了回调地狱的问题，提供了更优雅的异步编程方案，让异步代码更加清晰和可维护。

### 📝 Promise 特性

| 特性             | 语法                | 示例                                    | 用途         |
| ---------------- | ------------------- | --------------------------------------- | ------------ |
| **Promise 构造** | `new Promise()`     | `new Promise((resolve, reject) => {})`  | 创建 Promise |
| **then**         | `promise.then()`    | `promise.then(onFulfilled, onRejected)` | 处理结果     |
| **catch**        | `promise.catch()`   | `promise.catch(onRejected)`             | 错误处理     |
| **finally**      | `promise.finally()` | `promise.finally(onFinally)`            | 最终处理     |
| **静态方法**     | `Promise.all()`     | `Promise.all([p1, p2])`                 | 并发处理     |
| **静态方法**     | `Promise.race()`    | `Promise.race([p1, p2])`                | 竞速处理     |

### 🔧 详细说明

**Promise 基础 - 异步封装**

```javascript
// 基础Promise
function fetchUserData(userId) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (userId) {
        resolve({ id: userId, name: "张三", age: 25 });
      } else {
        reject(new Error("用户ID不能为空"));
      }
    }, 1000);
  });
}

// 使用Promise
fetchUserData(123)
  .then((user) => {
    console.log("用户信息:", user);
    return user.id;
  })
  .then((userId) => {
    console.log("用户ID:", userId);
  })
  .catch((error) => {
    console.error("错误:", error);
  })
  .finally(() => {
    console.log("请求完成");
  });
```

**Promise 链式调用 - 解决回调地狱**

```javascript
// 使用Promise重构回调地狱
function getUserData(userId) {
  return getUser(userId)
    .then((user) => {
      return getPermissions(user.id).then((permissions) => ({
        user,
        permissions,
      }));
    })
    .then(({ user, permissions }) => {
      return getSettings(user.id).then((settings) => ({
        user,
        permissions,
        settings,
      }));
    })
    .then(({ user, permissions, settings }) => {
      return getPreferences(user.id).then((preferences) => ({
        user,
        permissions,
        settings,
        preferences,
      }));
    });
}

// 更优雅的写法
function getUserData(userId) {
  return getUser(userId)
    .then((user) =>
      Promise.all([
        getPermissions(user.id),
        getSettings(user.id),
        getPreferences(user.id),
      ])
    )
    .then(([permissions, settings, preferences]) => ({
      user,
      permissions,
      settings,
      preferences,
    }));
}
```

**Promise 静态方法 - 并发控制**

```javascript
// Promise.all - 等待所有Promise完成
function fetchAllData() {
  return Promise.all([fetchUserData(1), fetchUserData(2), fetchUserData(3)]);
}

fetchAllData()
  .then((users) => {
    console.log("所有用户:", users);
  })
  .catch((error) => {
    console.error("获取失败:", error);
  });

// Promise.race - 竞速执行
function fetchWithTimeout(url, timeout = 5000) {
  const fetchPromise = fetch(url);
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error("请求超时")), timeout);
  });

  return Promise.race([fetchPromise, timeoutPromise]);
}

// Promise.allSettled - 等待所有Promise完成（无论成功失败）
function fetchAllDataSettled() {
  return Promise.allSettled([
    fetchUserData(1),
    fetchUserData(2),
    fetchUserData(3),
  ]);
}

fetchAllDataSettled().then((results) => {
  results.forEach((result, index) => {
    if (result.status === "fulfilled") {
      console.log(`用户${index + 1}:`, result.value);
    } else {
      console.error(`用户${index + 1}错误:`, result.reason);
    }
  });
});
```

---

## Generator 时代（ES6）

> **🎯 解决的问题**：解决了 Promise 链式调用的问题，提供了更直观的异步编程方式，让异步代码看起来像同步代码。

### 📝 Generator 特性

| 特性           | 语法                  | 示例                       | 用途       |
| -------------- | --------------------- | -------------------------- | ---------- |
| **function\*** | `function* name() {}` | `function* generator() {}` | 生成器函数 |
| **yield**      | `yield value`         | `yield 1`                  | 产出值     |
| **yield\***    | `yield* iterable`     | `yield* [1, 2, 3]`         | 委托生成器 |
| **next()**     | `generator.next()`    | `gen.next()`               | 执行生成器 |
| **throw()**    | `generator.throw()`   | `gen.throw(error)`         | 抛出错误   |
| **return()**   | `generator.return()`  | `gen.return(value)`        | 返回值     |

### 🔧 详细说明

**Generator 基础 - 状态机**

```javascript
// 基础Generator
function* numberGenerator() {
  yield 1;
  yield 2;
  yield 3;
}

const gen = numberGenerator();
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
console.log(gen.next().done); // true

// 实际应用：异步Generator
function* asyncGenerator() {
  try {
    const user = yield fetchUser(1);
    console.log("用户:", user);

    const posts = yield fetchPosts(user.id);
    console.log("文章:", posts);

    const comments = yield fetchComments(posts[0].id);
    console.log("评论:", comments);
  } catch (error) {
    console.error("错误:", error);
  }
}

// 执行异步Generator
function runAsyncGenerator(generator) {
  const gen = generator();

  function handle(result) {
    if (result.done) return result.value;

    return Promise.resolve(result.value)
      .then((res) => handle(gen.next(res)))
      .catch((err) => handle(gen.throw(err)));
  }

  return handle(gen.next());
}

runAsyncGenerator(asyncGenerator);
```

**Generator + Promise - 异步编程**

```javascript
// 使用Generator处理异步操作
function* fetchUserData(userId) {
  try {
    const user = yield fetchUser(userId);
    const permissions = yield fetchPermissions(user.id);
    const settings = yield fetchSettings(user.id);

    return {
      user,
      permissions,
      settings,
    };
  } catch (error) {
    console.error("获取用户数据失败:", error);
    throw error;
  }
}

// 执行器函数
function runGenerator(generator) {
  const gen = generator();

  function handle(result) {
    if (result.done) {
      return result.value;
    }

    return Promise.resolve(result.value)
      .then((value) => handle(gen.next(value)))
      .catch((error) => handle(gen.throw(error)));
  }

  return handle(gen.next());
}

// 使用
runGenerator(() => fetchUserData(123))
  .then((data) => {
    console.log("用户数据:", data);
  })
  .catch((error) => {
    console.error("错误:", error);
  });
```

---

## async/await 时代（ES2017）

> **🎯 解决的问题**：解决了 Generator 执行器的问题，提供了更简洁的异步编程语法，让异步代码看起来像同步代码。

### 📝 async/await 特性

| 特性         | 语法                  | 示例                                 | 用途         |
| ------------ | --------------------- | ------------------------------------ | ------------ |
| **async**    | `async function() {}` | `async function fetchData() {}`      | 异步函数     |
| **await**    | `await promise`       | `const result = await fetchData()`   | 等待 Promise |
| **错误处理** | `try/catch`           | `try { await fetchData() } catch {}` | 错误处理     |
| **并发执行** | `Promise.all`         | `await Promise.all([p1, p2])`        | 并发处理     |

### 🔧 详细说明

**async/await 基础 - 同步语法**

```javascript
// 基础async/await
async function fetchUserData(userId) {
  try {
    const user = await fetchUser(userId);
    const permissions = await fetchPermissions(user.id);
    const settings = await fetchSettings(user.id);

    return {
      user,
      permissions,
      settings,
    };
  } catch (error) {
    console.error("获取用户数据失败:", error);
    throw error;
  }
}

// 使用async/await
async function main() {
  try {
    const userData = await fetchUserData(123);
    console.log("用户数据:", userData);
  } catch (error) {
    console.error("错误:", error);
  }
}

main();
```

**async/await 并发 - 性能优化**

```javascript
// 串行执行（慢）
async function fetchUserDataSerial(userId) {
  const user = await fetchUser(userId);
  const permissions = await fetchPermissions(user.id);
  const settings = await fetchSettings(user.id);

  return { user, permissions, settings };
}

// 并发执行（快）
async function fetchUserDataParallel(userId) {
  const user = await fetchUser(userId);

  // 并发执行
  const [permissions, settings] = await Promise.all([
    fetchPermissions(user.id),
    fetchSettings(user.id),
  ]);

  return { user, permissions, settings };
}

// 实际应用：批量处理
async function fetchMultipleUsers(userIds) {
  const promises = userIds.map((id) => fetchUserData(id));
  const users = await Promise.all(promises);
  return users;
}

// 实际应用：错误处理
async function fetchUserWithFallback(userId) {
  try {
    return await fetchUser(userId);
  } catch (error) {
    console.warn("主数据源失败，尝试备用数据源");
    return await fetchUserFromBackup(userId);
  }
}
```

**async/await 高级用法**

```javascript
// 异步迭代器
async function* asyncGenerator() {
  for (let i = 0; i < 5; i++) {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    yield i;
  }
}

async function consumeAsyncGenerator() {
  for await (const value of asyncGenerator()) {
    console.log(value);
  }
}

// 异步函数表达式
const fetchData = async (url) => {
  const response = await fetch(url);
  return response.json();
};

// 异步箭头函数
const processData = async (data) => {
  const processed = await processAsync(data);
  return processed;
};

// 异步类方法
class ApiService {
  async fetchUser(id) {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  }

  async createUser(userData) {
    const response = await fetch("/api/users", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(userData),
    });
    return response.json();
  }
}
```

---

## 现代异步模式（ES2018+）

### 📝 现代异步特性

| 特性                   | 语法                   | 示例                                      | 用途         |
| ---------------------- | ---------------------- | ----------------------------------------- | ------------ |
| **异步迭代器**         | `for await...of`       | `for await (const item of asyncIterable)` | 异步迭代     |
| **异步生成器**         | `async function*`      | `async function* asyncGen() {}`           | 异步生成器   |
| **Promise.finally**    | `promise.finally()`    | `promise.finally(() => {})`               | 最终处理     |
| **Promise.allSettled** | `Promise.allSettled()` | `Promise.allSettled([p1, p2])`            | 等待所有完成 |

### 🔧 详细说明

**异步迭代器 - 流式处理**

> **🎯 解决的问题**：解决了大量数据流式处理的问题，让异步数据流处理更加优雅。

```javascript
// 异步迭代器
async function* fetchUsers() {
  let page = 1;
  while (true) {
    const response = await fetch(`/api/users?page=${page}`);
    const data = await response.json();

    if (data.users.length === 0) break;

    for (const user of data.users) {
      yield user;
    }

    page++;
  }
}

// 使用异步迭代器
async function processUsers() {
  for await (const user of fetchUsers()) {
    console.log("处理用户:", user.name);
    await processUser(user);
  }
}

// 实际应用：文件流处理
async function* readFileLines(filename) {
  const file = await openFile(filename);

  try {
    while (!file.eof) {
      const line = await file.readLine();
      yield line;
    }
  } finally {
    await file.close();
  }
}
```

**Promise.allSettled - 容错处理**

```javascript
// Promise.allSettled - 等待所有Promise完成
async function fetchAllDataSafely(urls) {
  const promises = urls.map((url) => fetch(url));
  const results = await Promise.allSettled(promises);

  const successful = [];
  const failed = [];

  results.forEach((result, index) => {
    if (result.status === "fulfilled") {
      successful.push({
        url: urls[index],
        data: result.value,
      });
    } else {
      failed.push({
        url: urls[index],
        error: result.reason,
      });
    }
  });

  return { successful, failed };
}

// 实际应用：批量API调用
async function fetchUserData(userIds) {
  const promises = userIds.map((id) => fetchUser(id));
  const results = await Promise.allSettled(promises);

  return results
    .filter((result) => result.status === "fulfilled")
    .map((result) => result.value);
}
```

---

## 实际应用场景

### 1. 现代前端应用

**React Hooks + async/await**

```javascript
import React, { useState, useEffect } from "react";

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function fetchUser() {
      try {
        setLoading(true);
        const userData = await fetchUserData(userId);
        setUser(userData);
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }

    fetchUser();
  }, [userId]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>User not found</div>;

  return (
    <div>
      <h1>{user.name}</h1>
      <p>Age: {user.age}</p>
      <p>Email: {user.email}</p>
    </div>
  );
}
```

### 2. Node.js 后端应用

**Express + async/await**

```javascript
const express = require("express");
const app = express();

// 异步路由处理
app.get("/api/users/:id", async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const permissions = await Permission.findByUserId(user.id);
    const settings = await Settings.findByUserId(user.id);

    res.json({
      user,
      permissions,
      settings,
    });
  } catch (error) {
    console.error("Error fetching user:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// 批量处理
app.post("/api/users/batch", async (req, res) => {
  try {
    const { userIds } = req.body;

    // 并发处理
    const users = await Promise.all(userIds.map((id) => User.findById(id)));

    // 过滤掉null值
    const validUsers = users.filter((user) => user !== null);

    res.json({ users: validUsers });
  } catch (error) {
    console.error("Error fetching users:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});
```

### 3. 数据流处理

**流式数据处理**

```javascript
// 异步生成器处理大数据流
async function* processLargeDataset(dataset) {
  for (const item of dataset) {
    // 模拟异步处理
    const processed = await processItem(item);
    yield processed;
  }
}

// 使用流式处理
async function handleLargeDataset(dataset) {
  const results = [];

  for await (const processed of processLargeDataset(dataset)) {
    results.push(processed);

    // 每处理100个就保存一次
    if (results.length % 100 === 0) {
      await saveResults(results);
      results.length = 0; // 清空数组
    }
  }

  // 保存剩余结果
  if (results.length > 0) {
    await saveResults(results);
  }
}
```

---

## 性能对比与最佳实践

### 1. 性能对比

```javascript
// 性能测试
async function performanceTest() {
  const iterations = 1000;

  // 回调函数性能
  console.time("回调函数");
  for (let i = 0; i < iterations; i++) {
    await new Promise((resolve) => {
      setTimeout(resolve, 1);
    });
  }
  console.timeEnd("回调函数");

  // Promise性能
  console.time("Promise");
  for (let i = 0; i < iterations; i++) {
    await new Promise((resolve) => {
      setTimeout(resolve, 1);
    });
  }
  console.timeEnd("Promise");

  // async/await性能
  console.time("async/await");
  for (let i = 0; i < iterations; i++) {
    await new Promise((resolve) => {
      setTimeout(resolve, 1);
    });
  }
  console.timeEnd("async/await");
}

// 典型结果：async/await ≈ Promise > 回调函数
```

### 2. 最佳实践建议

**异步编程最佳实践：**

```javascript
// ✅ 推荐：使用async/await
async function fetchData() {
  try {
    const response = await fetch("/api/data");
    return await response.json();
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

// ✅ 推荐：并发执行
async function fetchMultipleData() {
  const [users, posts, comments] = await Promise.all([
    fetchUsers(),
    fetchPosts(),
    fetchComments(),
  ]);

  return { users, posts, comments };
}

// ✅ 推荐：错误处理
async function safeFetch(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error("Fetch error:", error);
    return null;
  }
}

// ✅ 推荐：超时处理
async function fetchWithTimeout(url, timeout = 5000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await fetch(url, {
      signal: controller.signal,
    });
    clearTimeout(timeoutId);
    return await response.json();
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === "AbortError") {
      throw new Error("Request timeout");
    }
    throw error;
  }
}

// ❌ 避免：回调地狱
// function badFetch(callback) {
//   fetchUser(1, (user) => {
//     fetchPosts(user.id, (posts) => {
//       fetchComments(posts[0].id, (comments) => {
//         callback({user, posts, comments});
//       });
//     });
//   });
// }

// ✅ 好的做法
async function goodFetch() {
  const user = await fetchUser(1);
  const posts = await fetchPosts(user.id);
  const comments = await fetchComments(posts[0].id);
  return { user, posts, comments };
}
```

---

## 面试常考问题

### 1. 事件循环和异步执行

```javascript
// 问题：解释以下代码的输出顺序
console.log("1");

setTimeout(() => console.log("2"), 0);

Promise.resolve().then(() => console.log("3"));

console.log("4");

// 输出顺序：1, 4, 3, 2
// 解释：
// 1. 同步代码先执行
// 2. Promise微任务优先于setTimeout宏任务
// 3. 事件循环：同步 -> 微任务 -> 宏任务
```

### 2. Promise 状态和链式调用

```javascript
// 问题：解释以下代码的输出
Promise.resolve(1)
  .then((x) => x + 1)
  .then((x) => Promise.resolve(x + 1))
  .then((x) => {
    throw new Error("Error");
  })
  .catch((error) => {
    console.log("Caught:", error.message);
    return 10;
  })
  .then((x) => console.log("Final:", x));

// 输出：
// Caught: Error
// Final: 10
```

### 3. async/await 错误处理

```javascript
// 问题：解释以下代码的错误处理
async function test() {
  try {
    const result = await Promise.reject("Error");
    console.log("Success:", result);
  } catch (error) {
    console.log("Caught:", error);
  }
}

test();

// 输出：Caught: Error
// 解释：async/await中的错误会被try/catch捕获
```

### 4. 并发控制

```javascript
// 问题：实现一个并发限制函数
async function limitConcurrency(tasks, limit = 3) {
  const results = [];
  const executing = [];

  for (const task of tasks) {
    const promise = task().then((result) => {
      executing.splice(executing.indexOf(promise), 1);
      return result;
    });

    results.push(promise);
    executing.push(promise);

    if (executing.length >= limit) {
      await Promise.race(executing);
    }
  }

  return Promise.all(results);
}

// 使用示例
const tasks = Array.from(
  { length: 10 },
  (_, i) => () => fetch(`/api/data/${i}`)
);

limitConcurrency(tasks, 3).then((results) => console.log("All done:", results));
```

---

## 📋 总结

### 记忆技巧

1. **时间线记忆**：回调函数 → Promise → Generator → async/await
2. **问题记忆**：每个阶段解决的主要问题
3. **语法记忆**：关键语法和用法
4. **性能记忆**：各种方式的性能特点
5. **应用记忆**：实际应用场景

### 使用建议

1. **优先使用 async/await**：更简洁、更易读
2. **注意错误处理**：使用 try/catch
3. **合理使用并发**：Promise.all 提高性能
4. **避免回调地狱**：使用现代异步语法
5. **注意性能影响**：选择合适的方式
