## 原型链的关系

- 构造函数是使用了 new 关键字的函数，用来创建对象，**所有函数都是 Function()的实例**
- 原型对象是用来存放实例对象的共享属性和方法的一个公共对象，**所有原型对象都是 Object()的实例**
- 原型链又叫隐式原型链，是由**__proto__**属性串联起来，原型链的尽头是 Object.prototype。**proto**已经废弃了，可以用 Object.getPrototypeOf()

---

## 1. 构造函数（Constructor）

- 任何函数，只要通过 `new` 调用，就是一个构造函数。

  ```js
  function Person(name) {
    this.name = name;
  }
  const p1 = new Person("Tom");
  ```

- 在 JavaScript 中，所有函数本质上都是 `Function` 的实例。

  ```js
  console.log(Person instanceof Function); // true
  ```

---

## 2. 原型对象（prototype）

- 每一个函数（构造函数）都会有一个 **prototype 属性**，它指向一个对象，这个对象专门用来存放由该构造函数创建的实例的 **共享属性和方法**。
- 例如：

  ```js
  Person.prototype.sayHi = function () {
    console.log("Hi, I'm " + this.name);
  };
  p1.sayHi(); // Hi, I'm Tom
  ```

- 所有原型对象本身都是 `Object` 的实例。

  ```js
  console.log(Person.prototype instanceof Object); // true
  ```

---

## 3. 原型链（Prototype Chain）

- 每个对象都有一个 **隐式原型（**proto**）**，它指向其构造函数的 `prototype`。

  ```js
  console.log(p1.__proto__ === Person.prototype); // true
  ```

- 当访问一个属性时，会先在对象自身查找，如果找不到，就会沿着 `__proto__` 继续往上查找，直到 `Object.prototype` 为止。
- `Object.prototype.__proto__` 为 `null`，表示原型链的尽头。

---

## 4. **proto** 与标准方式

- `__proto__` 只是浏览器早期暴露出来的属性，**已被废弃**，但目前大部分环境仍然支持。
- 推荐使用：

  - `Object.getPrototypeOf(obj)` 获取原型
  - `Object.setPrototypeOf(obj, proto)` 修改原型

---

## 5. 一张简化的关系图

```
p1 --> Person.prototype --> Object.prototype --> null
       ^
       |
   Person (构造函数)
```

---

✅ 总结：

- **构造函数**用来创建对象。
- **原型对象**存放共享属性方法。
- **原型链**通过 `__proto__`（或标准 API）层层向上，最终指向 `Object.prototype`，形成继承关系。

