## 工程篇

### 模块

模块就是从逻辑上将系统分解为更细微的部分， 分而治之， 复杂问题拆解为若干简单问题， 逐个解决。

**耦合主要描述模块之间的关系， 内聚主要描述模块内部**。 模块的粒度可大可小， 可以是函数， 类， 功能块等等。

**耦合**

模块之间存在依赖， 导致改动可能会互相影响， 关系越紧密， 耦合越强， 模块独立性越差。

比如模块 A 直接操作了模块 B 中数据， 则视为强耦合， 若 A 只是通过数据与模块 B 交互， 则视为弱耦合。

独立的模块便于扩展， 维护， 写单元测试， 如果模块之间重重依赖， 会极大降低开发效率。

**内聚**

模块内部的元素， 关联性越强， 则内聚越高， 模块单一性更强。 一个模块应当尽可能独立完成某个功能，

如果有各种场景需要被引入到当前模块， 代码质量将变得非常脆弱， 这种情况建议拆分为多个模块。

低内聚的模块代码， 不管是维护， 扩展还是重构都相当麻烦， 难以下手

**因此模块之间的高内聚与低耦合最好**

### ES6

导出：export 单独导出，export default 默认导出

```ts
// 单独导出变量
export let a = 1;

// 批量导出对象
let b = 2;
let c = 3;
export { b, c };

// 导出接口
export interface P {
  x: number;
  y: number;
}

// 导出函数
export function f() {
  console.log("fff");
}

// 导出时起别名
function g() {}
export { g as G };

// 默认导出，无需函数名（默认导出即使起了名字也是无效的）
export default function () {
  console.log("I'm default");
}

// 引入外部模块，重新导出
export { str as hello } from "./b";
```

- 导入:import

  ```ts
  import { a, b, c } from "./a"; // 批量导入
  import { P } from "./a"; // 导入接口
  import { f as F } from "./a"; // 导入时起别名
  import * as All from "./a"; // 导入模块中的所有成员，绑定在 All 上
  import myFunction from "./a"; // 不加{ }，导入默认

  // c.ts导入了a.ts可以说c.ts依赖了a.ts    依赖可以理解导入

  console.log(a, b, c);

  let p: P = {
    x: 1,
    y: 1,
  };

  F();

  console.log(All);

  myFunction();
  ```

### Commonjs

- 导出：次级导出 exports、顶级导出 module.exports

  ```ts
  // 整体导出
  // module.exports = {}

  // 导出多个变量
  exports.c = 3;
  exports.d = 4;
  ```

  **如果同时存在次级导出和顶级导出，则会只生效顶级导出；次级导出不生效**

- 导入：require

  ```ts
  let c1 = require("./a.node");
  ```

### 为什么不在浏览器也是用 CommonJS

CommonJS 的 `require` 语法是**同步**的，当我们使用`require` 加载一个模块的时候，必须要等这个模块加载完后，才会执行后面的代码。如果知道这个事实，那我们的问题也就很容易回答了。**NodeJS** 是服务端，使用 `require` 语法加载模块，一般是一个文件，只需要从本地硬盘中读取文件，它的速度是比较快的。但是在浏览器端就不一样了，文件一般存放在服务器或者 CDN 上，如果使用同步的方式加载一个模块还需要由网络来决定快慢，可能时间会很长，这样浏览器很容易进入“假死状态”。所以才有了后面的**AMD**和**CMD**模块化方案，它们都是异步加载的，比较适合在浏览器端使用。

### 循环加载

**循环加载**指的是`a`脚本依赖了`b`脚本，而`b`脚本的执行又依赖了`a`脚本。在一个大型的项目中，一般依赖关系比较复杂，很容易出现循环依赖的情况，所以对于一个模块化方案，需要考虑这种情况。

#### CommonJS 的循环加载

想要搞清楚 CommonJS 的循环加载问题，首先我们要先大概了解下它的加载原理。CommonJS 的一个模块，一般就是一个文件，使用`reqiure`第一次加载一个模块的时候，就会在内存中生成一个对象。大概长这个样子：

```js
{
  id: '...',
  exports: { ... },
  loaded: true,
  ...
}
```

上面的例子我们只列出了关键的几个属性，`id`就是模块名，`exports`是模块输出的各个接口，`loaded`属性表示模块是否执行完毕。以后再用到这个模块的时候，会直接从这个对象的`exports`属性里面取值。即使多次执行一个模块的`require`命令，它都只会在第一次加载时运行一次，后面都会从缓存中读取，除非[手动清除缓存](https://link.juejin.cn?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F23685930%2Fclearing-require-cache)。

**CommonJS 模块的特性就是加载时执行**，当脚本被`reqiure`的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。我们看一个官方的例子，首先定义`a.js`如下：

```js
exports.done = false;
var b = require("./b.js");
console.log("在 a.js 之中，b.done = %j", b.done);
exports.done = true;
console.log("a.js 执行完毕");
```

上面的代码，首先输出一个`done`变量，然后开始加载`b.js`。注意，此时`a.js`就会停在这里，等待`b.js`执行完，才会继续执行后面的代码。

再定义`b.js`代码：

```js
exports.done = false;
var a = require("./a.js");
console.log("在 b.js 之中，a.done = %j", a.done);
exports.done = true;
console.log("b.js 执行完毕");
复制代码;
```

跟`a.js`类似，`b.js`导出一个变量后，在第二行就开始加载`a.js`，发生了循环依赖。然后系统就会去内存对象的`exports` 中取`done`变量的值，可是因为`a.js`没有执行完，所以只取到刚开始输出的值`false`。接着`b.js`继续执行后面的代码，执行完毕后，再把执行权交还给`a.js` ，执行完后面剩下的代码。为了验证这个过程，新建一个`main.js`：

```js
var a = require("./a.js");
var b = require("./b.js");
console.log("在 main.js 之中, a.done=%j, b.done=%j", a.done, b.done);
复制代码;
```

最后执行`main.js`结果为：

```js
在 b.js 之中，a.done = false
b.js 执行完毕
在 a.js 之中，b.done = true
a.js 执行完毕
在 main.js 之中, a.done=true, b.done=true
```

由于 **CommonJS 模块遇到循环加载时，输出的是当前已经执行那部分的值**，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。

#### ES6 中的循环加载

ES6 模块是动态引用，如果使用`import`加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值

### common.js 和 es6 中模块引入的区别？

#### 编译时输出接口 VS 运行时加载

在循环引用这个场景，对比 CommonJS 模块规范，就可以轻松地理解 ES6 module 的编译时加载。

先来看下面 CommonJS 的代码

```javascript
// index.js
const { log } = require("./lib.js");
module.exports = {
  name: "index",
};
log();

// lib.js
const { name } = require("./index.js");
module.exports = {
  log: function () {
    console.log(name);
  },
};
```

执行 index.js：`node index.js`结果会打印"undefined"。

这里 index 模块和 lib 相互依赖，形成了循环引用。

![esm1.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8f34a82ea0e4101b578d17745ee8405~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?)

整个过程模块都是运行时加载，代码依次执行，所以很容易分析出执行结果。

而 ES6 module 有所不同，接下来看一个 es6 module 的例子。代码内容和上面一样，只是把模块规范从 CommonJS 换成 es6 module。

```javascript
// index.mjs
import { log } from "./lib.mjs";
export const name = "index";
log();

// lib.mjs
import { name } from "./index.mjs";
export const log = () => {
  console.log(name);
};
```

执行 index.js：`node index.js`结果会打印"index"

![esm2.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15f6fc747dc5490c867fd878cd328128~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?)

es6 module 虽然模块未初始化好时候就被 lib 导入，但因为获取的是导出的接口（接口编译阶段就已经输出了），等初始化好之后就能使用了

我们知道 CommonJS 其实加载的是一个对象，这个对象只有在脚本运行时才会生成，而且只会生成一次。但是 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成，这样我们就可以使用各种工具对 JS 模块进行依赖分析，优化代码，而 Webpack 中的 `tree shaking` 和 `scope hoisting` 实际上就是依赖 ES6 模块化。

#### 引用 VS 值拷贝

案例 1

CommonJS 输出的是值的拷贝，换句话说就是，一旦输出了某个值，如果模块内部后续的变化，影响不了外部对这个值的使用

```javascript
// index.js
const { name } = require("./lib.js");
setTimeout(() => {
  console.log(name); // 'Sam'
}, 1000);

// lib.js
const lib = {
  name: "Sam",
};

setTimeout(() => {
  lib.name = "Bob"; // lib.js中name的变化不会影响到index.js中的name变化
}, 500);

module.exports = lib;
```

lib.js 中 name 的变化不会影响到 index.js 中的 name 变化

ES6 模块运行机制完全不一样，JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行的时候，再根据这个只读引用，到被加载的那个模块里去取值。

```javascript
// index.mjs
import { name } from "./lib.mjs";

console.log(name); // 'Sam'
setTimeout(() => {
  console.log(name); // 'Bob'
}, 1000);

// lib.mjs
export let name = "Sam";
setTimeout(() => {
  name = "Bob"; // lib.js中name的变化会影响到index.js中的name变化
}, 500);
```

这里 index 模块中的 name 是 lib 导出的 name 的引用，因此 lib 中 name 变化会同步到 index 中。

案例 2

CommonJS 输出的是值的拷贝，换句话说就是，一旦输出了某个值，如果模块内部后续的变化，影响不了外部对这个值的使用。具体例子：

```javascript
// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
};
```

然后我们在其它文件中使用这个模块：

```js
var mod = require("./lib");
console.log(mod.counter); // 3
mod.incCounter();
console.log(mod.counter); // 3
```

上面的例子充分说明了如果我们对外输出了`counter` 变量，就算后续调用模块内部的`incCounter` 方法去修改它的值，它的值依旧没有变化。

ES6 模块运行机制完全不一样，JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。等到脚本真正执行的时候，再根据这个只读引用，到被加载的那个模块里去取值。

```js
// lib.js
export let counter = 3;
export function incCounter() {
  counter++;
}

// main.js
import { counter, incCounter } from "./lib";
console.log(counter); // 3
incCounter();
console.log(counter); // 4
```

上面代码说明，ES6 模块`import`的变量`counter`是可变的，完全反应其所在模块`lib.js`内部的变化。

#### 静态 VS 动态

ES6 module 静态语法和 CommonJS 的动态语法是很重要的区别，

CommonJS 的动态性体现在两个方面

1. 可以根据条件判断是否加载模块

```scss
if (condition) {
    require('./lib');
}
```

2. require 的模块参数可以是一个变量

```javascript
require(`./${template}/index.js`);
```

这种动态性导致依赖关系不好分析，打包工具在静态代码分析阶段不容易知道模块是否需要被加载、模块的哪些部分需要被加载，哪些不会被用到。

相应地，ES6 module 的静态性体现在

1. import 必须在顶层
2. import 的模块参数只能是字符串，不能是变量
   所以打包工具能够静态分析出依赖关系，并确定知道哪些模块需要被加载、模块的哪些部分被用到。

所以 ES6 module 静态语法支持打包 tree-shaking，而 CommonJS 不行。

#### 只读 VS 可变

CommonJS 导入的模块和普通变量没有区别，ES6 module 导入的模块则不同，import 导入的模块是只读的。

```js
// demo-commonjs.js
let path = require('path');
path = 1;

// demo-esm.js
import path from 'path';Assignment to constant variable.
path = 1; // Error: Cannot assign to 'path' because it is an import
```

#### 异步 VS 同步

ES6 module 支持异步加载，浏览器中会用到该特性，而 Commonjs 是不支持异步的，因为服务器端不需要异步加载。所以 CommonJS 不可替代 ES6 module，ES6 module 可以替代 CommonJS。

#### 总结

ES6 module 和 CommonJS 的区别主要有 5 点 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

1. ES6 module 是编译时输出接口，CommonJS 是运行时加载。

   > **CommonJS**遇到循环依赖的时候，**只会输出已经执行的部分**，后续的输出或者变化，是不会影响已经输出的变量。而 ES6 模块相反，使用`import`加载一个变量，变量不会被缓存，真正取值的时候就能取到最终的值；

2. ES6 module 输出的值的引用，CommonJS 输出的是一个值的拷贝。

3. ES6 module 语法是静态的，CommonJS 语法是动态的。

4. ES6 module 导入模块的是只读的引用，CommonJS 导入的是可变的，是一个普通的变量。

5. ES6 module 支持异步，CommonJS 不支持异步。

6. CommonJs 的 this 是当前模块，ES6 Module 的 this 是 undefined

7. 关于两个模块互相引用的问题，在 ES6 模块当中，是支持加载**CommonJS**模块的。但是反过来，**CommonJS**并不能`require`ES6 模块，在 NodeJS 中，两种模块方案是分开处理的。

ES6 module 作为新的规范，可以替代之前的 AMD、CMD、CommonJS 作为浏览器和服务端的通用模块方案。NodeJS 在 13.2.0 版本后已经开始完全支持 ES6 module，ES6 module 在未来也会实际的模块化标准。
