## 赢 X 科技

### 1. 块状元素和行内元素的区别 🔥

**一句话回答**
块状元素独占一行，可设置宽高；行内元素不换行，宽高不生效。

**要点**

- 块级元素（block）：`div`、`p`、`ul`，独占一行。
- 行内元素（inline）：`span`、`a`、`strong`，不换行。
- inline-block：结合两者，既能设置宽高，又不独占一行。
- display 属性可在三者间切换。
- 对 margin/padding 的支持：block 完整支持，inline 仅左右生效。

**详细回答**
块级元素常用作布局容器，行内元素适合文本修饰。比如 `<div>` 常用于结构化布局，而 `<span>` 常用于文字高亮。`inline-block` 结合了两者的优势，是兼容性较好的布局方式。

**扩展/对比**

- **面试深挖点**：
  - 为什么 `<img>` 是 inline-block？👉 它既能和文字同行显示，又能有宽高。
  - 行内元素能设置 line-height 控制垂直对齐，而块级元素主要依赖 margin/padding。
- **现代对比**：Flex/Grid 出现后，开发者更少依赖 inline-block 做布局，但在兼容性和简单场景下依然常用。

---

### 2. 750px 设计稿如何计算 rem 🔥

**一句话回答**
通过设置 `html` 的基准 font-size，把设计稿尺寸换算成 rem 值。

**要点**

- rem 相对 `html` 根元素 font-size 缩放。
- 设计稿常约定：`html{font-size: 750/10 = 75px}`。
- 换算公式：元素尺寸 ÷ 基准值 = rem。
- 适合移动端多屏适配。
- 实现方式：lib-flexible、postcss-pxtorem、VW 替代方案。

**详细回答**
在移动端，通常把设计稿宽度等分成 10 份，即 `1rem = 75px`。100px → `100/75=1.33rem`。运行时通过 JS 动态调整根元素大小（比如随屏幕宽度变化），从而实现响应式。

**扩展/对比**

- **rem vs em**：rem 相对根元素，em 相对父元素，rem 更稳定。
- **rem vs vw**：vw 更直观（1vw=1%视口宽度），但低版本浏览器兼容性差。
- **面试常问**：京东为何推 vw，而淘宝常用 rem？👉 因为京东走自研方案更倾向 vw 的简洁，淘宝生态历史遗留多，rem 兼容性更好。

---

### 3. 水平居中的方法 🔥

**一句话回答**
水平居中常用 Flex、Grid、absolute+transform、line-height、margin: auto。

**要点**

- **文本居中**：`text-align:center`。
- **块级居中**：`margin: auto`（需定宽）。
- **现代首选**：Flex（`justify-content:center`）、Grid（`place-items:center`）。
- **传统兼容**：absolute + transform(-50%)。
- **特殊场景**：line-height 垂直居中文本、table-cell 居中。

**详细回答**

- Flex/Grid 更适合现代开发，语义清晰。
- margin: auto 简单，但需要宽度固定。
- absolute + transform 适合兼容旧环境。
- table-cell 是早期 hack，用得少。

**扩展/对比**

- **常见面试追问**：如何实现“水平+垂直居中”？👉 Flex/Grid 是一行搞定的现代解法。
- **性能角度**：Flex/Grid 渲染性能更优，absolute+transform 涉及额外计算。

---

### 4. 响应式布局的方法 🔥

**一句话回答**
响应式布局依赖媒体查询、弹性布局、流式布局、自适应单位。

**要点**

- 流式布局：百分比宽度，简单直观。
- 媒体查询：断点（如 768px、1024px）。
- 弹性布局：Flex、Grid 适配不同内容。
- 自适应单位：rem/vw/vh。
- 容器查询：CSS 新特性，更细粒度。

**详细回答**

- PC 常用断点（如 bootstrap：sm/md/lg/xl）。
- 移动端常用 rem/vw 配合。
- Flex/Grid 布局能更好应对多种屏幕大小。

**扩展/对比**

- **rem vs vw**：rem 更精细控制，vw 更轻量。
- **响应式 vs 自适应**：响应式是“一套代码多屏幕”，自适应是“不同设备用不同方案”。
- **面试追问**：如果页面很复杂，你会怎么选？👉 移动端优先（Mobile First）+ Flex/Grid + 媒体查询。

---

### 5. 闭包 🔥

**一句话回答**
闭包是函数+外部作用域的组合，可能导致内存泄漏。

**要点**

- 本质：作用域链未释放。
- 应用场景：私有变量、函数柯里化、回调。
- 问题：变量长期驻留 → 内存泄漏。
- 解决：及时解除引用，弱引用（WeakMap）。
- 与垃圾回收（GC）关系：引用链存在时不释放。

**详细回答**
闭包让函数记住外部作用域，哪怕外部函数执行完毕。
典型场景：防抖/节流函数、模块封装、工厂函数。
风险：滥用闭包可能导致变量常驻内存。

**扩展/对比**

- **面试追问**：闭包和高阶函数的区别？👉 闭包是“作用域+函数”，高阶函数是“函数操作函数”。
- **工程实践**：ES6 模块天然具备私有作用域，很多场景已替代闭包。

---

### 6. 事件委托 🔥

**一句话回答**
事件委托利用事件冒泡，把子元素事件交给父元素处理。

**要点**

- 原理：事件冒泡。
- 好处：减少绑定、提升性能。
- 使用：父级绑定 → `e.target` 判断目标。
- 常见场景：列表点击、动态元素（如新增的 li）。
- 注意事项：冒泡需开启，阻止冒泡会影响委托。

**详细回答**
在父级元素绑定事件，当子元素触发时冒泡到父级，由父级统一处理。
能避免每个子元素都绑定事件。

**扩展/对比**

- **性能角度**：几百个子元素监听 vs 父级一个监听，差异明显。
- **局限性**：focus/blur 不冒泡，不能委托。
- **面试追问**：如果一个事件要阻止冒泡，怎么兼顾事件委托？👉 用捕获阶段或父级条件判断。

---

### 7. 浅拷贝（Shallow Copy） 🔥

**一句话回答**
浅拷贝只复制对象的第一层，引用类型属性仍指向同一内存地址。

**要点**

- 常用方法：`Object.assign({}, obj)`、展开运算符 `{...obj}`、`Array.prototype.slice()`。
- 只复制一层基本类型。
- 引用类型（对象/数组）仍然共享。

**详细回答**
浅拷贝在复制时，只会将对象的**第一层属性值**复制过来：

- 如果是 **基本类型**，直接拷贝值；
- 如果是 **引用类型**，复制的是引用地址，指向同一块内存。

因此修改深层对象会相互影响。

**代码示例**

```js
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { ...obj1 };
obj2.b.c = 99;

console.log(obj1.b.c); // 99，共享引用
```

**扩展/对比**

- 浅拷贝适合**扁平对象**，性能更好。
- React 的 `setState` 内部就是浅拷贝（只替换新引用）。

---

### 8. 深拷贝（Deep Copy） 🔥

**一句话回答**
深拷贝会递归复制所有层级，确保新对象与原对象完全独立。

**要点**

- 常见方法：`structuredClone(obj)`（现代浏览器原生支持）。
- 旧方案：`JSON.parse(JSON.stringify(obj)`。
- 手写递归函数。
- 第三方库：`lodash.cloneDeep`。

**详细回答**
深拷贝会递归遍历对象的每个属性，新建内存，保证修改副本不会影响原对象。
但不同实现方式有差异：

- `JSON` 方法简单，但丢失函数、Symbol、`undefined`、循环引用。
- `structuredClone` 支持 `Date`、`Map`、`Set`、循环引用，但旧浏览器兼容性差。
- `lodash.cloneDeep` 功能最全，企业项目常用。

**代码示例**

```js
// 现代浏览器推荐
const obj1 = { a: 1, b: { c: 2 }, d: new Date() };
const obj2 = structuredClone(obj1);

obj2.b.c = 99;
console.log(obj1.b.c); // 2，已独立
```

**手写递归版**

```js
function deepClone(target, map = new WeakMap()) {
  if (typeof target !== "object" || target === null) return target;
  if (map.has(target)) return map.get(target);

  const result = Array.isArray(target) ? [] : {};
  map.set(target, result);

  for (const key in target) {
    if (target.hasOwnProperty(key)) {
      result[key] = deepClone(target[key], map);
    }
  }
  return result;
}
```

**扩展/对比**

- **浅拷贝 vs 深拷贝**

  - 浅拷贝：复制首层，深层共享 → 性能好。
  - 深拷贝：完全独立 → 安全，但性能开销大。

- **项目经验答法**

  - “在业务里，大多数时候浅拷贝足够；但处理深层嵌套或状态管理（Redux、Zustand）时，需要深拷贝保证不互相污染。”

---

### 9. 项目开发的开支 & Git 管理 🔥

**一句话回答**
项目开支主要是人力、时间、质量；代码通常通过 Git 分支管理。

**要点**

- 开支：人力成本、测试/质量成本、时间/机会成本、运维成本。
- Git 管理：分支模型（main、dev、feature、release、hotfix）。
- 代码评审：Pull Request / Merge Request。
- 工具：GitHub/GitLab + CI/CD 流程。

**详细回答**
项目开发不仅是人力，还包括测试、维护、发布。
代码通过 Git 管理，使用分支策略，确保开发与上线有序。

**扩展/对比**

- **面试追问**：怎么保证分支稳定性？👉 代码评审 + CI 测试。
- **实践对比**：Git Flow（复杂）、GitHub Flow（轻量）、Trunk Based（持续集成快节奏）。

---

### 10. Git Flow 🔥

**一句话回答**
Git Flow 是分支管理模型，包括主分支、开发分支、特性分支、发布分支、热修复分支。

**要点**

- master/main：线上版本。
- develop：开发中版本。
- feature：新功能分支。
- release：预发布测试。
- hotfix：线上紧急修复。

**详细回答**
Git Flow 适合多人协作和版本管理，流程清晰但略显复杂。

**扩展/对比**

- GitHub Flow：main+feature，简洁，常用于持续交付。
- GitLab Flow：结合 CI/CD，支持环境分支。
- **面试追问**：你们团队用哪种？👉 可答“我们根据团队规模选 GitHub Flow，简单高效”。

---

### 11. rebase vs merge 🔥

**一句话回答**
merge 保留完整历史，rebase 让历史线性但会改写提交。

**要点**

- merge：保留分支点，生成合并提交。
- rebase：把提交“搬运”到目标分支顶端。
- rebase 更干净，但会改写历史。
- 常见实践：公共分支用 merge，个人分支用 rebase。

**详细回答**
merge 用于多人协作，安全。
rebase 适合本地整理提交历史，让记录更简洁。

**扩展/对比**

- **面试追问**：什么时候不能 rebase？👉 已 push 的公共分支。
- **实践**：团队常用“squash merge” → 提交历史干净。

---

### 12. 缓存 🔥

**一句话回答**
缓存分为浏览器存储（cookie、storage、indexedDB）和网络缓存（强缓存、协商缓存、DNS）。

**要点**

- Cookie：小容量，随请求，常用于鉴权。
- localStorage/sessionStorage：前端存储，容量 ~5MB。
- IndexedDB：适合离线大数据。
- 强缓存：Cache-Control/Expires。
- 协商缓存：ETag/Last-Modified。
- DNS 缓存：减少解析时间。

**详细回答**
缓存能减少请求、提升性能。浏览器存储和网络缓存结合，形成多层级的性能优化体系。

**扩展/对比**

- **面试追问**：token 放哪？👉 cookie + HttpOnly 更安全；localStorage 方便但易被 XSS 窃取。
- **实践**：CDN 缓存 vs 浏览器缓存，前者减轻服务端压力，后者优化用户体验。

---



## X付科技

### 1. 有什么是只能类组件才能做的；有什么是只有 Hook 才能做的？

**一句话回答**
 类组件独有错误边界和快照生命周期，Hook 独有逻辑复用、并发调度与更细粒度的性能控制。

**要点**

- 类组件特有：
  - 错误边界（`componentDidCatch`、`getDerivedStateFromError`）。
  - `getSnapshotBeforeUpdate` 获取 DOM 快照。
- Hook 特有：
  - 自定义 Hook（逻辑复用、状态组合）。
  - 并发渲染能力（`useTransition`、`useDeferredValue`）。
  - 与外部 store 对齐（`useSyncExternalStore`）。

**详细回答**

- 类组件的“保留地”：
  - **错误边界**：目前只能用类组件捕获子树渲染异常，用于降级 UI。
  - **快照生命周期**：在 DOM 更新前捕获状态（如滚动位置）。
- Hook 带来的能力：
  - **逻辑复用**：自定义 Hook 避免 HOC/render props 的嵌套地狱。
  - **并发渲染友好**：React 18 引入的并发特性（`useTransition`、`useDeferredValue`），让函数组件在数据量大时仍能保持交互流畅。
  - **外部状态管理**：`useSyncExternalStore` 提供与第三方 store 的一致性保障，这是类组件时代很难优雅做到的。

**扩展/对比**

- 过去逻辑复用依赖 HOC，但会导致「层层包裹」→ 调试困难；Hook 让逻辑更加直观。
- 错误边界是目前函数组件做不到的 → 未来可能会被新 API 替代。

------

### 2. 封装一个组件需要注意什么？

**一句话回答**
 关注“输入稳定、输出清晰、性能可控、样式隔离、可测试”。

**要点**

- API 设计：语义化 props，合理默认值，受控/非受控明确。
- 可扩展性：透传属性、支持 children/slots、forwardRef。
- 性能优化：memo、useMemo/useCallback、懒加载。
- 样式隔离：CSS Modules/Tailwind，避免全局污染。
- 可测试性：逻辑与渲染解耦。

**详细回答**

- **输入稳定**：不要每次都传匿名函数/对象，保持引用稳定，减少子组件渲染。
- **受控 vs 非受控**：明确区分 `<Input value/onChange>` 与 `<Input defaultValue ref>`。
- **透传属性**：通过 `...restProps` 保证可扩展。
- **性能考虑**：对复杂组件做拆分，必要时用虚拟列表/懒加载。
- **样式治理**：避免全局样式冲突，推荐 CSS Modules、Tailwind；通用组件可支持 className 覆写。
- **可测试**：将复杂逻辑抽离到 Hook 或工具函数，组件保持渲染职责。

**扩展/对比**

- UI 库（如 antd、MUI）封装强调一致的 API 设计、可定制主题；内部系统则更强调业务解耦。
- 面试官可能追问：“你们团队如何做组件库？” → 答：文档化（Storybook）、测试覆盖、设计规范统一。

------

### 3. React.memo 的概念，子组件使用了 memo，为什么父组件刷新了，子组件也刷新了？

**一句话回答**
 React.memo 用浅比较缓存子组件渲染结果；父组件刷新时仍会触发对子组件 props 的比较，若引用变化或 context 变更，子组件会重新渲染。

**要点**

- React.memo：浅比较 props。
- 父更新 → 子组件进入“对比阶段”，决定是否跳过 commit。
- 子组件仍会刷新的情况：
  - props 引用变化（对象/函数）。
  - 子组件使用的 context 改变。
  - 子组件自身状态更新。
  - key 变化导致卸载重建。

**详细回答**

- 父组件更新时，React 会递归检查子组件。
- 被 React.memo 包裹的子组件会触发「props 比较」。
- 如果 props 没变 → 跳过渲染，复用上次结果。
- 如果 props 是新建对象/函数 → 浅比较认为不相等 → 触发重新渲染。
- context 变化不受 memo 影响，子组件会强制更新。

**扩展/对比**

- React.memo 类似于类组件的 PureComponent。
- 实战中推荐搭配 useCallback/useMemo 保证 props 稳定。
- 面试官可能问：“如何避免无意义渲染？” → 答：优化 props 引用、减少 context 粒度、用 selector。

------

### 4. React.memo 是浅比较，那么如何实现深比较呢？

**一句话回答**
 在 React.memo 第二参数里实现自定义比较函数（如 lodash.isEqual），即可做深比较，但性能开销大，实际项目更推荐稳定引用。

**要点**

- React.memo 默认：浅比较（只比较 props 引用）。
- 深比较方法：
  - 手写递归对比。
  - 使用 lodash.isEqual 等库。
  - 用 JSON.stringify（性能差）。
- 风险：性能消耗，尤其是大对象/频繁更新时。
- 更优策略：保持 props 扁平化 + 稳定引用。

**详细回答**

```tsx
import isEqual from "lodash/isEqual";

const Comp = React.memo(
  (props) => <div>{props.data.value}</div>,
  (prev, next) => isEqual(prev, next) // 深比较
);
```

深比较能避免「对象引用变了但内容没变」导致的无效渲染。但每次渲染都要遍历对象，可能引入比重渲染更严重的性能瓶颈。
 因此，深比较仅适合**对象小、更新频率低**的场景（如配置表、静态 props）。

**扩展/对比**

- 浅比较：O(1) 快速，但依赖引用稳定。
- 深比较：O(n) 或更高，成本随数据规模线性上升。
- 实战方案：用 useMemo/useCallback 保证引用稳定，而不是深比较 props。
- 面试官常问：“为什么 React 默认浅比较？” → 因为深比较成本不可控。

------

### 5. React.memo 的第二参数是什么？

**一句话回答**
 React.memo 的第二参数是自定义 props 对比函数 `(prevProps, nextProps) => boolean`，返回 true 表示跳过渲染。

**要点**

- 函数签名：`areEqual(prevProps, nextProps)`。
- 返回 true → 认为 props 相等 → 跳过渲染。
- 返回 false → 认为 props 变化 → 重新渲染。
- 仅比较 props，不影响 state/context。

**详细回答**
 默认 React.memo 使用浅比较。如果想自定义，可以传入第二个函数：

```tsx
const Child = React.memo(
  (props) => <div>{props.count}</div>,
  (prev, next) => prev.count === next.count // 只比较 count
);
```

- 可用于：只关心部分字段、特殊比较规则。
- 不要在里面做副作用或复杂逻辑，这里只应该是「对比」。

**扩展/对比**

- 类似类组件中的 `shouldComponentUpdate(nextProps, nextState)`，但这里只管 props。
- 推荐“白名单式”比较（只比较关键字段），比“深比较”更高效。
- 面试官可能追问：“能不能用它优化大表格渲染？” → 答：可以对比 row.id/row.version，只在变化时渲染。

------

### 6. 父组件可以使用子组件身上的方法吗？这是考虑暴露组件的方法吗？

**一句话回答**
 可以，函数组件用 `forwardRef + useImperativeHandle` 暴露方法，类组件用 ref 调实例方法，但要谨慎使用，避免破坏声明式数据流。

**要点**

- 函数组件：
  - forwardRef 转发 ref。
  - useImperativeHandle 限制暴露的 API。
- 类组件：ref 直接访问实例方法。
- 适用场景：focus、scroll、reset、手动校验等命令式操作。
- 原则：能用 props 驱动就用 props，ref 作为兜底手段。

**详细回答**

```tsx
const InputEx = React.forwardRef((props, ref) => {
  const inputRef = React.useRef<HTMLInputElement>(null);

  React.useImperativeHandle(ref, () => ({
    focus: () => inputRef.current?.focus(),
    value: () => inputRef.current?.value ?? "",
  }));

  return <input ref={inputRef} {...props} />;
});

// 父组件
const ref = useRef();
<InputEx ref={ref} />;
ref.current.focus();
```

- 父组件得到的是一组受控的 API，而不是整个子组件实例。
- 好处：避免暴露内部实现细节，只提供父组件需要的能力。

**扩展/对比**

- 类组件 ref → `childRef.current.method()`。
- 函数组件 → 不能直接 ref，必须配合 forwardRef/useImperativeHandle。
- React 官方推荐：优先声明式（props 控制），只有在 DOM 操作/命令式场景下才用 ref。
- 面试官常问：“什么时候需要用 useImperativeHandle？” → 答：封装表单、视频播放器、复杂 UI 控件时，需要暴露一些操作方法给父组件。

------

### 7. 类数组有哪些形式：DOM 元素，Set 对象，arguments，还有其他类数组吗？

### **一句话回答**

 类数组是“长得像数组”的对象，常见的有 `arguments`、NodeList、HTMLCollection、DOMTokenList、TypedArray、字符串等，但 Set/Map 不是类数组。

**要点**

- 特征：有 `length`，可用索引访问。
- 典型：`arguments`、NodeList、HTMLCollection、DOMTokenList、FileList、TypedArray。
- 特殊：字符串（不可变，索引访问）。
- 非类数组：Set/Map（可迭代，但没有 length）。
- 转换方式：`Array.from()`、`[...obj]`。

**详细回答**

- **类数组判定条件**：必须有 length 属性，且索引连续或可访问。
- **常见场景**：
  - DOM API 返回：`document.querySelectorAll` → NodeList。
  - 函数参数：`arguments`。
  - 文件上传：`FileList`。
  - 二进制：`Uint8Array` 等 TypedArray。
  - 字符串：`"abc"[1] === "b"`。
- Set/Map 虽然可迭代，但没有 length，故不是类数组。

**扩展/对比**

- `Array.isArray(arguments)` → false。
- 转换数组常用：`Array.from(arguments)` 或 `[...arguments]`。
- 面试常问：“Set 是类数组吗？” → 答：不是，是可迭代对象。

------

### 8. 一个函数 2 个参数（数组+数量），如何实现并发最大数量？

**一句话回答**
 实现一个任务调度器：保持运行任务 ≤ limit，完成一个任务立即补充下一个，直到所有完成。

**要点**

- 目标：并发控制（限制最大并发数）。
- 思路：
  - running 计数器。
  - 队列保存剩余任务。
  - settle（完成/失败）后递归启动下一个。
- 返回结果需保证顺序。

**详细回答**

```js
function scheduler(tasks, limit) {
  let i = 0, running = 0, results = [];
  return new Promise((resolve) => {
    function run() {
      if (i === tasks.length && running === 0) return resolve(results);
      while (running < limit && i < tasks.length) {
        const cur = i++;
        running++;
        Promise.resolve(tasks[cur]())
          .then(res => results[cur] = res)
          .catch(err => results[cur] = err)
          .finally(() => {
            running--;
            run();
          });
      }
    }
    run();
  });
}
```

- **核心机制**：运行 ≤ limit，任务完成后立刻补充一个新任务。
- **优势**：可应用于接口请求、文件上传。

**扩展/对比**

- 类似 p-limit 库。
- 若需要可取消，可结合 AbortController。
- 面试官可能会变种考题：实现 Promise.all 并发控制。

------

### 9. Async 函数中 await 在等待什么？

**一句话回答**
 await 等待一个 Promise 的结果，如果是普通值会被包装成 `Promise.resolve(value)`。

**要点**

- async 函数返回值一定是 Promise。
- await 表达式：
  - Promise → 等待状态 settled。
  - 普通值 → 包装成 Promise.resolve。
- 异常：reject 会抛出异常，需 try/catch。

**详细回答**

```js
async function f() {
  const a = await 42; // 等价 Promise.resolve(42)
  const b = await fetch('/api');
  return b.json();
}
```

- `await` 的本质：挂起当前 async 函数，把后续逻辑排进微任务队列。
- 普通值 → 立即 resolved。
- Promise → 等待状态确定。

**扩展/对比**

- 面试常问：“await 会阻塞线程吗？” → 不会，只阻塞当前函数逻辑。
- async/await 是 Generator + Promise 的语法糖。

------

### 10. `await 1` 会发生什么？

**一句话回答**
 `await 1` 会被包装成 `Promise.resolve(1)`，后续逻辑进入微任务队列。

**要点**

- await 会强制异步化。
- `await 1` = `await Promise.resolve(1)`。
- 输出顺序考题：同步 → 微任务 → 宏任务。

**详细回答**

```js
async function fn() {
  console.log(1);
  await 1;
  console.log(2);
}
fn();
console.log(3);
// 输出：1, 3, 2
```

- `await 1` 并不会立即执行后续，而是将后续放到微任务队列。
- 所以执行顺序体现了 async/await 的“异步边界”。

**扩展/对比**

- `Promise.resolve().then(...)` 与 `await` 的执行时机一致（微任务）。
- 面试官可能加问：“await 会不会阻塞 UI 渲染？” → 不会，渲染属于浏览器线程，JS 的 await 只是挂起函数。

------

### 11. 事件处理机制：宏任务和微任务，在处理宏任务中又遇到了微任务呢？

**一句话回答**
 事件循环机制规定：执行完一个宏任务后，会立即清空微任务队列，所以宏任务里创建的微任务会在当前宏任务结束前执行。

**要点**

- JS 单线程，事件循环调度。
- 宏任务：setTimeout、setInterval、I/O、UI 渲染。
- 微任务：Promise.then、queueMicrotask、MutationObserver。
- 执行规则：
  1. 执行一个宏任务。
  2. 清空微任务队列。
  3. 进入下一个宏任务。

**详细回答**

```js
setTimeout(() => {
  console.log("宏1开始");
  Promise.resolve().then(() => console.log("微任务 in 宏1"));
  console.log("宏1结束");
});
```

执行顺序：

- `宏1开始` → 注册微任务 → `宏1结束` → 清空微任务 → 输出 `微任务 in 宏1`。
   说明：宏任务中遇到的微任务，会在该宏任务完成后立刻执行，而不是拖到下一个宏任务。

**扩展/对比**

- 浏览器 vs Node.js：Node 有额外阶段（timers、poll、check）。
- 面试官常考“输出顺序题”。记口诀：**宏观调度，微观先行**。

------

### 12. 一个下拉列表，输入 1、2、3，但是数据回来后只渲染了 2 的数据，分别有什么可能，如何解决？

**一句话回答**
 这是请求竞态问题，后发请求先返回覆盖了最新输入；解决方法是请求取消、结果比对或请求序号校验。

**要点**

- 可能原因：
  - 异步请求无序（后发先至）。
  - 状态更新覆盖（未比对输入值）。
  - 缓存/防抖策略错误。
- 解决方案：
  - AbortController 取消旧请求。
  - 比对输入值/请求序号，只保留最新。
  - 防抖/节流，减少无效请求。

**详细回答**

- **原因**：用户快速输入时会触发多个请求，可能是输入 3 的请求比输入 2 慢，结果返回时覆盖了输入 3 的 UI。
- **解决**：
  1. 每次发请求前取消上一个请求（AbortController）。
  2. 记录请求序号/时间戳，只更新最后一次的结果。
  3. 对输入加防抖，减少竞态概率。

**扩展/对比**

- React 18 的 `useTransition` 可以在 UI 更新上避免卡顿，但不能直接解决请求竞态。
- 面试官常追问：“你用过 AbortController 吗？” → 要答能用 `fetch(url, { signal })`。

------

### 13. React 如果说没有传入 key，那么它的 key 会是什么？

**一句话回答**
 默认情况下 React 会使用元素的索引作为 key。

**要点**

- key 用于同层 diff。
- 不传 key → 默认 index。
- 索引 key：列表增删时可能引起错误复用。

**详细回答**

- React diff 算法依赖 key 来判断子节点是否复用。
- 如果没有传 key，React 会退化为用数组下标。
- 但这样会导致：
  - 删除/插入时，后续节点错误复用，导致 UI 状态错乱。
  - 比如输入框值被错位复用。

**扩展/对比**

- index key 适合：静态列表、不增删场景。
- 业务 id key 适合：动态增删、更新频繁的场景。
- SSR 场景下 index key 更容易引发 hydration mismatch。

------

### 14. React 的 key 你了解多少？

**一句话回答**
 key 是 React diff 的核心，必须是唯一稳定的标识，避免 diff 误判导致状态错乱。

**要点**

- 作用：优化 diff，标识唯一节点。
- 特性：同层唯一、稳定不变。
- 风险：用 index 会导致错位复用。
- 最佳实践：用业务 id。

**详细回答**

- React diff 会比较新旧子节点的 key。
- 相同 key → 复用节点；不同 key → 卸载/新建。
- 如果 key 不稳定（如用 index），可能导致 UI 状态错误复用。
- 正确做法：
  - 列表数据用唯一 id。
  - 避免使用随机 key（导致每次都重建）。

**扩展/对比**

- key 并不会传给组件作为 props。
- 面试官常问：“为什么不用 index 当 key？” → 答：因为删除/插入会错位复用。

------

好👌 那我把第 15 题重新定义为你说的完整语义，并展开四段式（**一句话回答 → 要点 → 详细回答 → 扩展/对比**）。

------

### 15) 使用 Hook 去模拟 componentDidUpdate，是使用 useEffect 和 ref 去实现吗？使用普通变量或者是 state 可以吗？以及普通变量放到组件外面呢？

**一句话回答**
 在函数组件里可以用 `useEffect` 搭配 `useRef` 模拟 `componentDidUpdate`；`state` 也能实现但会引起额外渲染，普通变量在组件内会重置，在组件外会丢失组件隔离性，因此最佳实践是 `useRef`。

------

**要点**

- **useEffect + ref** → 推荐，跳过首渲染，后续依赖变化时执行，模拟 `componentDidUpdate`。
- **state** → 可以，但会导致额外渲染。
- **普通变量（组件内）** → 每次渲染都会重置，失效。
- **普通变量（组件外）** → 可以记住，但全局共享，破坏组件实例隔离，且不安全。
- **useLayoutEffect** → 用于 DOM 同步更新的场景，相当于 `getSnapshotBeforeUpdate`。

------

**详细回答**
 在类组件中，`componentDidUpdate` 会在组件更新后执行。
 函数组件中可以这样模拟：

```tsx
function Demo({ value }) {
  const isFirst = useRef(true);

  useEffect(() => {
    if (isFirst.current) {
      isFirst.current = false; // 跳过首次
      return;
    }
    console.log("更新阶段，value:", value);
  }, [value]);

  return <div>{value}</div>;
}
```

- **useEffect**：在依赖变化后执行副作用。
- **useRef**：存储一个“是否首次”的标志，跨渲染保持不变，不会触发渲染。
- **state**：也能存储“是否首次”，但 `setState(false)` 会导致额外渲染一次，不够优雅。
- **普通变量（组件内）**：函数重新执行时会重置，永远无法保存状态。
- **普通变量（组件外）**：可以保存，但多个组件实例会共享这一个值，导致状态串扰（第一个 Demo 改了 isFirst，第二个 Demo 就错乱了）。

------

**扩展/对比**

- ✅ 推荐：`useEffect + useRef` → 高效、隔离、无额外渲染。
- ⚠️ `state` → 能实现，但会额外渲染一次。
- ❌ 普通变量（组件内）→ 每次重置，根本无效。
- ❌ 普通变量（组件外）→ 全局共享，破坏组件隔离，Concurrent Mode 下更危险。
- **面试加分答法**：
  - “我会用 `useRef` 来存储跨渲染的标志，因为它不会触发渲染，同时保证每个组件实例独立。普通变量放组件外虽然能记住，但所有实例会共用，破坏了 React 的组件封装性。”

------

### 16) 你知道 useReducer 吗？如何使用？参数的含义

**一句话回答**
 `useReducer` 是 `useState` 的替代方案，适合复杂状态逻辑，参数包含 reducer 函数、初始状态、可选的初始化函数。

**要点**

- 用法：`const [state, dispatch] = useReducer(reducer, initialState, initFn)`。
- 参数：
  - `reducer(state, action)`：状态更新逻辑。
  - `initialState`：初始状态。
  - `initFn`（可选）：惰性初始化函数。
- 返回值：
  - `state`：当前状态。
  - `dispatch(action)`：分发 action。

**详细回答**
 `useReducer` 与 Redux 原理一致：接收一个 reducer 函数和初始状态，返回 `[state, dispatch]`。

```tsx
function reducer(state, action) {
  switch (action.type) {
    case 'increment': return { count: state.count + 1 };
    case 'decrement': return { count: state.count - 1 };
    default: return state;
  }
}

const [state, dispatch] = useReducer(reducer, { count: 0 });

<button onClick={() => dispatch({ type: 'increment' })}>+</button>
```

- **`initFn`**：如果初始状态需要昂贵计算，可以传递一个函数懒初始化：

  ```tsx
  const [state, dispatch] = useReducer(reducer, 0, (init) => init + 10);
  ```

**扩展/对比**

- 对比 `useState`：
  - `useState` 适合简单状态。
  - `useReducer` 适合复杂逻辑、多个子状态组合。
- 对比 Redux：
  - `useReducer` 是局部状态，不具备全局共享能力。
  - Redux 提供全局状态管理 + middleware。

------

### 17) useEffect 和 useLayoutEffect 的区别

**一句话回答**
 `useEffect` 在渲染提交后异步执行，不阻塞浏览器绘制；`useLayoutEffect` 在 DOM 更新后、绘制前同步执行。

**要点**

- **useEffect**：异步，延后执行，不阻塞渲染。
- **useLayoutEffect**：同步，DOM 更新后立即执行，阻塞渲染。
- 使用场景：
  - useEffect：数据请求、订阅、日志。
  - useLayoutEffect：DOM 测量、同步样式修改。

**详细回答**

- **useEffect**：更常用，浏览器绘制完成后再运行，不会导致闪烁。

- **useLayoutEffect**：类似于类组件的 `componentDidMount` / `componentDidUpdate`，但会在绘制前运行，保证 DOM 已更新但未呈现，适合 DOM 操作：

  ```tsx
  useLayoutEffect(() => {
    const height = ref.current.offsetHeight;
    setHeight(height); // 保证测量值和渲染一致
  });
  ```

**扩展/对比**

- SSR 环境中 `useLayoutEffect` 会报警告（因为没有 DOM），通常需降级为 `useEffect`。
- 面试高分点：“如果只需要副作用，不依赖布局 → 用 useEffect；若要测量 DOM 或避免闪烁 → 用 useLayoutEffect。”

------

### 18) useEffect 可以模拟多少种生命周期

**一句话回答**
 useEffect 可以模拟 `componentDidMount`、`componentDidUpdate`、`componentWillUnmount` 三种生命周期。

**要点**

- 挂载（Mount）：`useEffect(() => {...}, [])`。
- 更新（Update）：`useEffect(() => {...}, [deps])`。
- 卸载（Unmount）：`useEffect(() => { return () => {...} }, [])`。

**详细回答**

- **挂载**：传空依赖数组，只在首次渲染后执行一次。
- **更新**：依赖变化时执行，可以用 ref 跳过首次渲染。
- **卸载**：在 effect 返回的清理函数中执行。

```tsx
useEffect(() => {
  console.log("挂载或更新");
  return () => console.log("卸载"); 
}, [dep]);
```

**扩展/对比**

- 类组件的生命周期被拆分进 useEffect，不再是单一函数。
- 面试官可能追问：“能模拟 shouldComponentUpdate 吗？” → 答：不能，函数组件用 `React.memo`。

------

### 19) useCallback 和 useMemo 什么时候使用，什么时候不用呢？

**一句话回答**
 `useCallback` 缓存函数，`useMemo` 缓存计算结果；在避免子组件重复渲染或避免昂贵计算时使用，轻量逻辑不要滥用。

**要点**

- **useCallback(fn, deps)**：返回 memoized 函数。
- **useMemo(factory, deps)**：返回 memoized 值。
- 使用场景：
  - 函数/对象作为 props 传递给 memoized 子组件。
  - 复杂计算结果缓存。
- 不适用：轻量逻辑或不涉及子组件优化。

**详细回答**

```tsx
const memoizedFn = useCallback(() => doSomething(a, b), [a, b]);
const memoizedValue = useMemo(() => expensiveCalc(data), [data]);
```

- **useCallback** 避免父组件每次渲染都生成新函数。
- **useMemo** 避免重复计算。
- 滥用反而增加依赖追踪成本。

**扩展/对比**

- 面试官常问：“useCallback 一定能提升性能吗？” → 答：不一定，如果子组件没用 React.memo，缓存函数没意义。
- 推荐思路：**先写直白逻辑 → 确认性能瓶颈 → 再加 useMemo/useCallback 优化。**

------

### 20) useContext 的用法

**一句话回答**
 useContext 用于获取最近一层 Context.Provider 提供的值，避免层层 props 传递。

**要点**

- 创建 Context：`const Ctx = React.createContext(defaultValue)`。
- 提供值：`<Ctx.Provider value={xxx}>`。
- 消费值：`const value = useContext(Ctx)`。
- 特点：组件更新时，所有消费该 context 的子组件都会重新渲染。

**详细回答**

```tsx
const ThemeContext = React.createContext("light");

function Child() {
  const theme = useContext(ThemeContext);
  return <div>{theme}</div>;
}

<ThemeContext.Provider value="dark">
  <Child />
</ThemeContext.Provider>
```

- useContext 返回最近的 Provider 值。
- 如果没有 Provider，则使用默认值。

**扩展/对比**

- 缺点：所有消费组件都会重新渲染 → 大 context 更新成本大。
- 优化：可用 context selector 模式（如 use-context-selector 库）或拆分多个小 context。
- 面试加分点：“useContext 本身不做优化，配合 memo/context selector 才能避免全量刷新。”

------

### 21) 在 Node.js 环境有一个无限递归自己的函数在执行，控制台会输出什么？此时应该如何做？如果说想让它保持呢？

**一句话回答**
 无限递归会触发 `RangeError: Maximum call stack size exceeded`，要么改成异步调度（setTimeout/nextTick/尾递归优化），要么用循环保持。

**要点**

- JS 没有尾递归优化 → 无限递归直接爆栈。
- Node.js 会报错 `RangeError`。
- 替代方法：
  - 异步调度：`setImmediate`、`process.nextTick`、`setTimeout`。
  - 替代递归：循环结构。
- 如果要“保持执行” → 用循环/定时器/事件轮询，而不是直接递归。

**详细回答**

```js
function f() {
  console.log("hi");
  f(); // 无限递归
}
f();
// ❌ 报错：RangeError: Maximum call stack size exceeded
```

- Node.js 没有尾递归优化，调用栈会不断累积。
- 解决：改为**异步递归**，利用事件循环清空栈。

```js
function f() {
  console.log("hi");
  setImmediate(f); // 或 setTimeout(f, 0)
}
f(); // ✅ 无限保持而不会爆栈
```

**扩展/对比**

- `process.nextTick` 更快于 `setTimeout`，但可能阻塞事件循环，慎用。
- 面试官可能问：“为什么无限 while(true) {} 不行？” → 因为会阻塞线程，CPU 飙高。
- 答案关键词：**爆栈 / 异步调度 / 事件循环**。

------

### 22) 像 mobx、redux、zustand 这些变量的 state 它们是存储在什么地方里？

**一句话回答**
 它们的 state 本质上存储在 **内存中的普通 JS 对象**，不同库提供了代理、订阅机制或全局 store 管理。

**要点**

- Redux：state 存在 store（单一 JS 对象），通过 dispatch 更新。
- MobX：使用可观察对象（Proxy/getter setter）追踪依赖。
- Zustand：基于 hooks + store 的轻量状态库，state 存在闭包里。
- 都是在内存中，刷新后会丢失，需持久化（localStorage/IndexedDB）。

**详细回答**

- **Redux**：state 是不可变的 JS 对象，由 reducer 更新，store 在内存里。
- **MobX**：用 Proxy/Observable 包装对象，修改时自动触发订阅的组件。
- **Zustand**：每个 store 是一个闭包，内部保存 state，更新时触发订阅。

**扩展/对比**

- 都是“内存存储”，和数据库无关。
- 持久化需要插件（如 redux-persist）或手动存 localStorage。
- 面试官可能问：“刷新页面后 state 还在吗？” → 答：不在，因为存在 JS 内存里，刷新会重置。

------

### 23) TS 新增了哪些 JS 没有的类型？还有哪些呢？

**一句话回答**
 TS 在 JS 基础上新增了静态类型系统，包括枚举、接口、泛型、联合、交叉、字面量、元组、类型守卫等。

**要点**

- **基础扩展**：enum、tuple、any、unknown、never、void。
- **组合类型**：union、intersection。
- **类型系统增强**：interface、type alias、泛型。
- **工具类型**：Partial、Pick、Omit、Record。

**详细回答**

- **enum**：枚举类型。
- **tuple**：固定长度、类型顺序的数组。
- **any/unknown/never**：更精细的类型。
- **联合/交叉**：灵活表达复杂结构。
- **interface/type**：抽象对象形状。
- **泛型**：让函数/类在多类型场景下保持复用性。

```ts
enum Color { Red, Green, Blue }
type Point = [number, number];
function id<T>(x: T): T { return x; }
```

**扩展/对比**

- JS 是动态类型，TS 是静态类型增强。
- 面试官常追问：“any 和 unknown 有什么区别？” → `any` 可以随意用，`unknown` 需先缩小类型才能用。

------

### 24) 你是如何理解水合问题的，如何避免和处理

**一句话回答**
 水合问题是指 SSR 生成的 HTML 与客户端渲染结果不一致导致报错，可以通过保证首屏一致、条件渲染时机控制、suppressHydrationWarning 避免。

**要点**

- **水合 (hydration)**：SSR HTML + 客户端绑定事件。
- **问题**：内容不一致 → 报 Hydration Error。
- **原因**：
  - 非确定性内容（时间戳、随机数）。
  - 条件渲染导致差异。
  - key 不稳定。
- **解决**：
  - 保证首屏一致。
  - 用 `suppressHydrationWarning` 忽略警告。
  - 条件逻辑放到 `useEffect`。

**详细回答**

- SSR 会先生成 HTML，再由客户端 React 绑定事件。
- 如果两边 DOM 结构不同，React 会警告或丢弃 DOM。
- 常见场景：服务端渲染的时间戳 vs 客户端当前时间不同。

```tsx
<div suppressHydrationWarning>{new Date().toString()}</div>
```

**扩展/对比**

- Next.js 常见水合错误：key 不一致、动态内容在 SSR 输出。
- 面试官可能追问：“如何调试水合错误？” → 答：检查 SSR 输出和 CSR 渲染是否一致，console.log HTML。

------

### 25) 你封装过什么 hooks，封装 hooks 需要注意什么？

**一句话回答**
 封装 hooks 用于复用逻辑，需要注意命名规范、副作用清理、依赖管理和可组合性。

**要点**

- 命名必须以 `use` 开头。
- 不可在循环/条件中调用。
- 注意副作用清理（返回函数）。
- 尽量通用、可组合。
- 类型定义（TS）清晰。

**详细回答**
 常见自定义 hooks：

- **useDebounce**：防抖输入。
- **useFetch**：封装数据请求逻辑。
- **usePrevious**：记录上一次值。
- **useToggle**：布尔值切换。

注意事项：

- 确保在每次渲染中调用顺序一致。
- 清理副作用，避免内存泄漏。
- 依赖项写全，避免闭包陷阱。

**扩展/对比**

- 普通函数 vs hooks：普通函数不能使用 React hooks，不能保存 state/context。
- 面试官可能追问：“为什么要封装？” → 答：减少重复逻辑、提升复用性和可维护性。

------

### 26) 为什么使用 hooks 封装，直接使用函数去实现不行吗？普通函数与 hooks 有什么区别。

**一句话回答**
 普通函数无法使用 React 的状态/生命周期机制，而自定义 Hook 可以复用逻辑同时与 React 渲染机制绑定。

**要点**

- **普通函数**：只是执行逻辑，不能存储状态或使用 hooks。
- **自定义 Hook**：以 `use` 开头，可以调用其他 Hook（useState/useEffect/useContext）。
- **优势**：逻辑复用、状态独立、天然和渲染绑定。

**详细回答**

- 普通函数运行完就结束，不会保存状态。
- Hook 利用 React 内部的 hook 调用链表，能跨渲染保存状态和副作用。
- 比如写一个 `useDebounce` Hook 可以在不同组件中保持各自独立的防抖状态，而普通函数做不到。

**扩展/对比**

- 普通函数更像工具方法；自定义 Hook 是与 React 生命周期绑定的逻辑单元。
- 面试加分答法：“Hook 是对状态逻辑的抽象，普通函数是纯逻辑的抽象。”

------

### 27) hooks 为什么不能在循环或者条件中使用

**一句话回答**
 因为 React 依赖 hook 调用顺序来管理状态，循环或条件会破坏顺序，导致状态错乱。

**要点**

- React 内部用链表按调用顺序存储 hook。
- 每次渲染必须保持顺序一致。
- 在循环/条件里调用可能导致某些 hook 少调用或多调用，错乱状态链。

**详细回答**

```tsx
if (flag) {
  useState(0); // ❌ 可能有时不执行
}
```

- 如果 flag 在不同渲染时变化，就会导致 Hook 链表错位，React 读错状态。
- 正确做法：始终在函数顶层调用 hooks，用条件/循环包裹 hook 内部逻辑。

**扩展/对比**

- ESLint 插件 `react-hooks/rules-of-hooks` 会强制检测。
- 面试官追问：“那该怎么写？” → 把条件放到 hook 内部，而不是包裹 hook。

------

### 28) 场景题：两个按钮控制同一个弹窗组件，第一个按钮打开后，发送请求，请求没有回来就关闭了，然后使用第二个按钮去打开弹窗显示的是第一个的内容，为什么？有多少种场景？分别如何修复。

**一句话回答**
 这是异步请求竞态或状态未清理导致的数据错乱，需在关闭时取消请求或在打开时重置内容。

**要点**

- 可能原因：
  - 请求未取消 → 旧请求结果覆盖新弹窗。
  - 弹窗状态没清理 → 复用上次数据。
  - 请求时序问题 → 后发请求比先发慢。
- 解决：
  - 关闭时取消请求（AbortController）。
  - 打开时重置状态。
  - 请求加唯一标识/序号校验。

**详细回答**

- 场景 1：**请求没取消**
  - 第一次请求在关闭后才返回，覆盖了第二次请求的数据。
  - ✅ 解决：在关闭弹窗时 `abort()`。
- 场景 2：**状态没重置**
  - 弹窗关闭后仍保留上次数据，导致再次打开时直接显示旧内容。
  - ✅ 解决：每次打开弹窗时重置内容为空/loading。
- 场景 3：**竞态条件**
  - 第二次请求先发出，但第一次请求返回得更快，覆盖了第二次结果。
  - ✅ 解决：在结果中对比请求 id 或时间戳，只应用最后一次的。

**扩展/对比**

- React 18 提供 `useTransition` 避免 UI 卡顿，但本质上仍需业务逻辑保证数据一致。
- 面试加分答法：“我会用 AbortController 或请求序号校验，保证 UI 始终和用户最新操作保持一致。”

------

### 29) ref 有哪些使用场景

**一句话回答**
 ref 用于获取 DOM、存储跨渲染的值、暴露子组件方法、缓存实例。

**要点**

- 获取 DOM：`ref.current` 指向 DOM 节点。
- 保存跨渲染数据：不会触发渲染。
- 暴露子组件方法：`forwardRef + useImperativeHandle`。
- 控制第三方库实例：canvas、图表、播放器。

**详细回答**

- **DOM 操作**：聚焦 input，滚动到某元素。
- **存储值**：记录上一次 props/state，不触发渲染。
- **子组件方法**：父组件调用子组件的 play()/reset()。
- **外部实例**：保存 chart.js/three.js 对象。

**扩展/对比**

- ref vs state：ref 改变不会触发渲染；state 改变会。
- 面试加分答法：“我更多把 ref 当成 React 的 escape hatch，适合命令式场景。”

------

### 30) CORS 是什么，跨域的手段有多少种

**一句话回答**
 CORS（跨域资源共享）通过设置响应头允许不同源访问资源，其他手段包括 JSONP、代理、postMessage、iframe、WebSocket。

**要点**

- **CORS**：服务端设置 `Access-Control-Allow-Origin`。
- **其他方案**：
  - JSONP（老方案，仅限 GET）。
  - 反向代理（nginx、webpack devServer）。
  - postMessage（跨域窗口通信）。
  - WebSocket（不受同源限制）。
  - document.domain（老 IE 技巧）。

**详细回答**

- **CORS 工作原理**：浏览器在跨域请求时检查响应头是否包含允许的域。
- **预检请求**：复杂请求会先发 OPTIONS。
- **其他方式**：
  - JSONP：script 标签 src 跨域。
  - 代理：由同源服务转发请求。
  - postMessage：iframe/跨窗口通信。

**扩展/对比**

- 面试官追问：“CORS 是前端解决还是后端解决？” → 答：本质是后端配置响应头。
- 加分答：“开发环境常用代理解决，生产环境必须配置后端 CORS。”

------

### 31) 一个对象有几个属性，我想复制对象，但是我想排除掉某个属性应该如何做呢？

**一句话回答**
 可以通过对象解构、`delete`、lodash/omit 等方式实现。

**要点**

- 解构 + 剩余运算符：`const {exclude, ...rest} = obj`。
- delete：`const copy = {...obj}; delete copy.key`。
- lodash：`_.omit(obj, 'key')`。

**详细回答**

```js
const obj = {a:1, b:2, c:3};

// 解构
const {b, ...rest} = obj; // {a:1, c:3}

// delete
const copy = {...obj};
delete copy.b; // {a:1, c:3}

// lodash
const rest2 = _.omit(obj, 'b');
```

**扩展/对比**

- 推荐解构 + 剩余运算符 → 简洁、无副作用。
- delete 会修改对象（性能差，适合少量 key）。
- lodash 适合复杂场景（多个 key）。

------



## X火科技

------

### 1) Tailwind CSS 的 tokens 派生你是否了解过？

**一句话回答**
 用“**基础设计值（基 tokens）** + **语义别名（semantic tokens）**”管理样式，在 `tailwind.config.js` 里统一派生颜色/间距/圆角/字体等，并以 CSS 变量承载，组件只用语义 token。

**要点**

- 基 tokens：如 `--brand-500`、`--space-2`、`--radius-md`。
- 语义 tokens：如 `--btn-bg`、`--card-bg`、`--text-muted` 绑定到基 tokens。
- Tailwind 派生：在 `theme.extend` 下用 `colors/spacing/borderRadius`，可指向 `var(--x)`。
- 好处：一处改品牌/主题，全站联动；可支持暗色/多主题。

**详细回答**

- 在 `globals.css` 定义基础变量与语义变量，并在 `:root`/`.dark` 覆写：

  ```css
  :root{
    --brand-500:#6b5cff; --brand-600:#5847ff;
    --text:#0a0a0a; --text-muted:#6b7280;
    --radius-md:12px; --space-2:0.5rem; --space-4:1rem;
    /* 语义变量 */
    --btn-bg:var(--brand-600);
    --card-bg:#fff;
  }
  .dark{
    --text:#e5e7eb; --text-muted:#9ca3af;
    --card-bg:#0b0b0b;
  }
  ```

- 在 `tailwind.config.js` 派生到 Tailwind 的设计系统：

  ```js
  // tailwind.config.js
  export default {
    theme: {
      extend: {
        colors: {
          brand: { 500: 'var(--brand-500)', 600:'var(--brand-600)'},
          text: { DEFAULT:'var(--text)', muted:'var(--text-muted)'},
          card: { bg:'var(--card-bg)' }
        },
        spacing: { 2:'var(--space-2)', 4:'var(--space-4)' },
        borderRadius: { md:'var(--radius-md)' }
      }
    }
  }
  ```

- 组件里只写 `bg-card-bg text-text` / `bg-brand-600` 等语义类名，主题切换时只改变量。

**扩展/对比**

- 可用“**语义类 + 状态类**”（如 `btn-primary` 里拼 `bg-brand-600 text-white hover:bg-brand-500`）。
- 大厂常见做法：Figma Tokens → JSON → 脚本生成 CSS 变量 + 更新 `tailwind.config`。

------

### 2) 弱网络访问页面如何优化体验？（从 Next.js 角度）

**一句话回答**
 **能静态就静态、能缓存就缓存、能流就流**：RSC/Streaming + 部分预渲染（ISR/SSG）+ 细粒度缓存 + 渐进加载骨架/占位 + 资源预链接与压缩。

**要点（Next.js 15/14 App Router）**

- **渲染策略**：`generateStaticParams`/SSG、ISR（`revalidate`），对不常变的路由静态化。
- **缓存**：`fetch(url, { next: { revalidate: 60 } })`、`force-cache`、`no-store` 分层控制；CDN 边缘缓存。
- **流式传输**：RSC + `loading.tsx` 占位、`Suspense`/分段 `Segment`，优先送上骨架。
- **资源**：`next/image`（自动懒加载/自适应/格式转换）、`priority` 给首图；`next/font`（可用 `display:swap`）；`preconnect/dns-prefetch` 提前建链。
- **网络优化**：HTTP/2/3、Gzip/Brotli、分包/按需加载、Route Group 拆分。
- **离线兜底**：PWA + Service Worker 缓存关键壳层。

**详细回答（落地清单）**

- 路由级：对于列表/详情等可缓存页面 → SSG/ISR：

  ```ts
  // app/page.tsx
  export const revalidate = 60; // ISR 60s
  ```

- 请求级：

  ```ts
  // RSC 内
  await fetch(api, { next: { revalidate: 60 } }); // 命中 Next 的数据缓存
  ```

- 流式/占位：

  - `app/xxx/loading.tsx`：首屏出骨架。
  - 子块用 `<Suspense fallback={<Skeleton/>}>` 包裹慢块。

- 图片与字体：

  ```tsx
  <Image src={hero} alt="" priority sizes="100vw" />
  // next/font
  const inter = Inter({ subsets: ['latin'], display:'swap' })
  ```

- Head 优化：

  ```tsx
  // app/layout.tsx
  export const metadata = { /* ... */ }
  // 在 <head> 自定义：
  <link rel="preconnect" href="https://cdn.example.com" />
  <link rel="dns-prefetch" href="https://api.example.com" />
  ```

- 其它：Skeleton/Optimistic UI、分页/增量加载、禁用无意义的客户端组件、压缩 + 去除大 polyfill。

**扩展/对比**

- 慢网强调“**先可用再完备**”：先把可交互壳层+文字出来，图/次要块延迟。
- Vitals 关注：**LCP/INP/CLS**；慢网尤其要压低 LCP（见第 6 题）。

------

### 3) TS：基于 `interface Demo { a:1; b:2; c:3 }`

**场景 1：生成一个新接口但不要 b；场景 2：该接口“所有 value 的类型”统一成某种类型**

**一句话回答**
 用 **内置工具类型**：`Omit` 去掉 `b`；用 **映射类型** 把所有 value 映射成统一类型。

**要点**

- 去掉 b：`Omit<Demo, 'b'>`。
- 也可提取 value 联合：`Demo[keyof Demo]`。

**详细回答**

```ts
interface Demo { a: 1; b: 2; c: 3 }

// 1) 去掉 b
type WithoutB = Omit<Demo, 'b'>   // { a:1; c:3 }

// 2) 提取所有 value 的联合类型（1 | 2 | 3）
type DemoValueUnion = Demo[keyof Demo];
```

**扩展/对比**

- 还可用 `Pick<Demo, 'a'|'c'>` 与 `Omit` 对偶搭配。
- 若 key 需变更可用 **key remap**：`{ [K in keyof T as NewName<K>]: ... }`。

------

### 4) 你是否有了解过缓存，有几种，有什么表现吗？

**一句话回答**
 分 **浏览器缓存（强/协商）**、**HTTP 缓存**、**Service Worker/CacheStorage**、**CDN 缓存**、**应用内缓存（内存/LRU）**；表现为命中后减少请求/更快返回。

**要点**

- **HTTP 强缓存**：`Cache-Control: max-age, s-maxage, immutable`。
- **协商缓存**：`ETag/If-None-Match`、`Last-Modified/If-Modified-Since`（304）。
- **SW 缓存**：离线/预缓存关键资源。
- **CDN**：边缘就近命中，`s-maxage`。
- **应用内**：进程内 Map/LRU、Next 的 RSC 数据缓存。

**详细回答**

- 强缓存命中：状态码 200（from disk/memory/ServiceWorker），不与服务器交互。
- 协商缓存命中：返回 304，体积小。
- Next：`revalidate`/`fetch cache` 控制数据层缓存策略。
- SW：`workbox` 可实现 `stale-while-revalidate` 体验。

**扩展/对比**

- 资源型建议：`immutable` + 文件名哈希。
- API 建议：`stale-while-revalidate`，弱网更顺滑。
- 注意与鉴权/隐私冲突（`private` vs `public`）。

------

### 5) 图片懒加载指的是什么？

**一句话回答**
 图片在进入视口前不加载，等快出现时再请求，减少首屏带宽与渲染压力。

**要点**

- 原生：`loading="lazy"`。
- Next：`next/image` 默认懒加载（非 `priority`）。
- IntersectionObserver 可做更精细控制。
- 占位：模糊/颜色占位（LQIP）。

**详细回答**

```tsx
// Next
<Image src="/img/xxx.jpg" alt="" placeholder="blur" blurDataURL="data:image..." />
// 原生
<img src="..." loading="lazy" alt="" />
```

- 懒加载配合 `sizes`/`width/height`，避免 CLS。
- 对首屏 LCP 图禁止懒加载（加 `priority`），否则拖慢 LCP。

**扩展/对比**

- 懒加载 ≠ 低清晰度加载；可叠加 LQIP/渐进 JPEG/AVIF+Brotli。

------

### 6) LCP 的问题出现在哪里？要如何处理？

**一句话回答**
 LCP（最大内容绘制）通常发生在 **首屏最大块元素**（多为首图/大标题/首屏卡片）；优化要点是**尽快首图可见、减少阻塞、提前建链**，目标 < 2.5s。

**要点**

- 典型瓶颈：
  - 首图文件大、懒加载误配、CDN 慢。
  - 渲染阻塞：大 CSS/JS、字体阻塞。
  - 首字节慢：后端慢/无缓存。
- 优化抓手：
  - **首图**：`next/image` + 合理尺寸/格式（WebP/AVIF）+ `priority` + `preload`。
  - **阻塞**：Critical CSS、分包、去除未用 JS、`font-display:swap`。
  - **建链**：`preconnect`/`dns-prefetch` 到 CDN/API。
  - **渲染**：RSC/SSR/ISR，`loading.tsx` 骨架，尽早可视。

**详细回答**

- 首图：

  ```tsx
  <Image src={hero} alt="" priority sizes="100vw" />
  ```

  配合 CDN、压缩、合适 `sizes`，避免拉超大原图。

- CSS/JS：提取关键 CSS，推迟非关键 JS（仅客户端组件保留）。

- 字体：`next/font` + `display:'swap'`，避免 FOIT。

- 网络：

  ```html
  <link rel="preconnect" href="https://cdn.example.com">
  <link rel="preload" as="image" href="/hero.avif" imagesrcset="..." imagesizes="100vw">
  ```

- 渲染：对首屏内容用 SSG/ISR；接口用 `revalidate`；子块用 `Suspense` 让骨架先上。

**扩展/对比**

- 监测：用 `web-vitals` 上报 LCP 元素与时间，定位是图片还是文本。
- 若是文本成为 LCP：关注字体加载、服务端首字节（TTFB）与 CSS 阻塞。
- 经验：**首图不要懒加载**，否则 LCP 会显著恶化。

------

