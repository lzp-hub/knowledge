## 赢 X 科技

### 1. 块状元素和行内元素的区别 🔥

**一句话回答**
块状元素独占一行，可设置宽高；行内元素不换行，宽高不生效。

**要点**

- 块级元素（block）：`div`、`p`、`ul`，独占一行。
- 行内元素（inline）：`span`、`a`、`strong`，不换行。
- inline-block：结合两者，既能设置宽高，又不独占一行。
- display 属性可在三者间切换。
- 对 margin/padding 的支持：block 完整支持，inline 仅左右生效。

**详细回答**
块级元素常用作布局容器，行内元素适合文本修饰。比如 `<div>` 常用于结构化布局，而 `<span>` 常用于文字高亮。`inline-block` 结合了两者的优势，是兼容性较好的布局方式。

**扩展/对比**

- **面试深挖点**：
  - 为什么 `<img>` 是 inline-block？👉 它既能和文字同行显示，又能有宽高。
  - 行内元素能设置 line-height 控制垂直对齐，而块级元素主要依赖 margin/padding。
- **现代对比**：Flex/Grid 出现后，开发者更少依赖 inline-block 做布局，但在兼容性和简单场景下依然常用。

---

### 2. 750px 设计稿如何计算 rem 🔥

**一句话回答**
通过设置 `html` 的基准 font-size，把设计稿尺寸换算成 rem 值。

**要点**

- rem 相对 `html` 根元素 font-size 缩放。
- 设计稿常约定：`html{font-size: 750/10 = 75px}`。
- 换算公式：元素尺寸 ÷ 基准值 = rem。
- 适合移动端多屏适配。
- 实现方式：lib-flexible、postcss-pxtorem、VW 替代方案。

**详细回答**
在移动端，通常把设计稿宽度等分成 10 份，即 `1rem = 75px`。100px → `100/75=1.33rem`。运行时通过 JS 动态调整根元素大小（比如随屏幕宽度变化），从而实现响应式。

**扩展/对比**

- **rem vs em**：rem 相对根元素，em 相对父元素，rem 更稳定。
- **rem vs vw**：vw 更直观（1vw=1%视口宽度），但低版本浏览器兼容性差。
- **面试常问**：京东为何推 vw，而淘宝常用 rem？👉 因为京东走自研方案更倾向 vw 的简洁，淘宝生态历史遗留多，rem 兼容性更好。

---

### 3. 水平居中的方法 🔥

**一句话回答**
水平居中常用 Flex、Grid、absolute+transform、line-height、margin: auto。

**要点**

- **文本居中**：`text-align:center`。
- **块级居中**：`margin: auto`（需定宽）。
- **现代首选**：Flex（`justify-content:center`）、Grid（`place-items:center`）。
- **传统兼容**：absolute + transform(-50%)。
- **特殊场景**：line-height 垂直居中文本、table-cell 居中。

**详细回答**

- Flex/Grid 更适合现代开发，语义清晰。
- margin: auto 简单，但需要宽度固定。
- absolute + transform 适合兼容旧环境。
- table-cell 是早期 hack，用得少。

**扩展/对比**

- **常见面试追问**：如何实现“水平+垂直居中”？👉 Flex/Grid 是一行搞定的现代解法。
- **性能角度**：Flex/Grid 渲染性能更优，absolute+transform 涉及额外计算。

---

### 4. 响应式布局的方法 🔥

**一句话回答**
响应式布局依赖媒体查询、弹性布局、流式布局、自适应单位。

**要点**

- 流式布局：百分比宽度，简单直观。
- 媒体查询：断点（如 768px、1024px）。
- 弹性布局：Flex、Grid 适配不同内容。
- 自适应单位：rem/vw/vh。
- 容器查询：CSS 新特性，更细粒度。

**详细回答**

- PC 常用断点（如 bootstrap：sm/md/lg/xl）。
- 移动端常用 rem/vw 配合。
- Flex/Grid 布局能更好应对多种屏幕大小。

**扩展/对比**

- **rem vs vw**：rem 更精细控制，vw 更轻量。
- **响应式 vs 自适应**：响应式是“一套代码多屏幕”，自适应是“不同设备用不同方案”。
- **面试追问**：如果页面很复杂，你会怎么选？👉 移动端优先（Mobile First）+ Flex/Grid + 媒体查询。

---

### 5. 闭包 🔥

**一句话回答**
闭包是函数+外部作用域的组合，可能导致内存泄漏。

**要点**

- 本质：作用域链未释放。
- 应用场景：私有变量、函数柯里化、回调。
- 问题：变量长期驻留 → 内存泄漏。
- 解决：及时解除引用，弱引用（WeakMap）。
- 与垃圾回收（GC）关系：引用链存在时不释放。

**详细回答**
闭包让函数记住外部作用域，哪怕外部函数执行完毕。
典型场景：防抖/节流函数、模块封装、工厂函数。
风险：滥用闭包可能导致变量常驻内存。

**扩展/对比**

- **面试追问**：闭包和高阶函数的区别？👉 闭包是“作用域+函数”，高阶函数是“函数操作函数”。
- **工程实践**：ES6 模块天然具备私有作用域，很多场景已替代闭包。

---

### 6. 事件委托 🔥

**一句话回答**
事件委托利用事件冒泡，把子元素事件交给父元素处理。

**要点**

- 原理：事件冒泡。
- 好处：减少绑定、提升性能。
- 使用：父级绑定 → `e.target` 判断目标。
- 常见场景：列表点击、动态元素（如新增的 li）。
- 注意事项：冒泡需开启，阻止冒泡会影响委托。

**详细回答**
在父级元素绑定事件，当子元素触发时冒泡到父级，由父级统一处理。
能避免每个子元素都绑定事件。

**扩展/对比**

- **性能角度**：几百个子元素监听 vs 父级一个监听，差异明显。
- **局限性**：focus/blur 不冒泡，不能委托。
- **面试追问**：如果一个事件要阻止冒泡，怎么兼顾事件委托？👉 用捕获阶段或父级条件判断。

---

### 7. 浅拷贝（Shallow Copy） 🔥

**一句话回答**
浅拷贝只复制对象的第一层，引用类型属性仍指向同一内存地址。

**要点**

- 常用方法：`Object.assign({}, obj)`、展开运算符 `{...obj}`、`Array.prototype.slice()`。
- 只复制一层基本类型。
- 引用类型（对象/数组）仍然共享。

**详细回答**
浅拷贝在复制时，只会将对象的**第一层属性值**复制过来：

- 如果是 **基本类型**，直接拷贝值；
- 如果是 **引用类型**，复制的是引用地址，指向同一块内存。

因此修改深层对象会相互影响。

**代码示例**

```js
const obj1 = { a: 1, b: { c: 2 } };
const obj2 = { ...obj1 };
obj2.b.c = 99;

console.log(obj1.b.c); // 99，共享引用
```

**扩展/对比**

- 浅拷贝适合**扁平对象**，性能更好。
- React 的 `setState` 内部就是浅拷贝（只替换新引用）。

---

### 8. 深拷贝（Deep Copy） 🔥

**一句话回答**
深拷贝会递归复制所有层级，确保新对象与原对象完全独立。

**要点**

- 常见方法：`structuredClone(obj)`（现代浏览器原生支持）。
- 旧方案：`JSON.parse(JSON.stringify(obj)`。
- 手写递归函数。
- 第三方库：`lodash.cloneDeep`。

**详细回答**
深拷贝会递归遍历对象的每个属性，新建内存，保证修改副本不会影响原对象。
但不同实现方式有差异：

- `JSON` 方法简单，但丢失函数、Symbol、`undefined`、循环引用。
- `structuredClone` 支持 `Date`、`Map`、`Set`、循环引用，但旧浏览器兼容性差。
- `lodash.cloneDeep` 功能最全，企业项目常用。

**代码示例**

```js
// 现代浏览器推荐
const obj1 = { a: 1, b: { c: 2 }, d: new Date() };
const obj2 = structuredClone(obj1);

obj2.b.c = 99;
console.log(obj1.b.c); // 2，已独立
```

**手写递归版**

```js
function deepClone(target, map = new WeakMap()) {
  if (typeof target !== "object" || target === null) return target;
  if (map.has(target)) return map.get(target);

  const result = Array.isArray(target) ? [] : {};
  map.set(target, result);

  for (const key in target) {
    if (target.hasOwnProperty(key)) {
      result[key] = deepClone(target[key], map);
    }
  }
  return result;
}
```

**扩展/对比**

- **浅拷贝 vs 深拷贝**

  - 浅拷贝：复制首层，深层共享 → 性能好。
  - 深拷贝：完全独立 → 安全，但性能开销大。

- **项目经验答法**

  - “在业务里，大多数时候浅拷贝足够；但处理深层嵌套或状态管理（Redux、Zustand）时，需要深拷贝保证不互相污染。”

---

### 9. 项目开发的开支 & Git 管理 🔥

**一句话回答**
项目开支主要是人力、时间、质量；代码通常通过 Git 分支管理。

**要点**

- 开支：人力成本、测试/质量成本、时间/机会成本、运维成本。
- Git 管理：分支模型（main、dev、feature、release、hotfix）。
- 代码评审：Pull Request / Merge Request。
- 工具：GitHub/GitLab + CI/CD 流程。

**详细回答**
项目开发不仅是人力，还包括测试、维护、发布。
代码通过 Git 管理，使用分支策略，确保开发与上线有序。

**扩展/对比**

- **面试追问**：怎么保证分支稳定性？👉 代码评审 + CI 测试。
- **实践对比**：Git Flow（复杂）、GitHub Flow（轻量）、Trunk Based（持续集成快节奏）。

---

### 10. Git Flow 🔥

**一句话回答**
Git Flow 是分支管理模型，包括主分支、开发分支、特性分支、发布分支、热修复分支。

**要点**

- master/main：线上版本。
- develop：开发中版本。
- feature：新功能分支。
- release：预发布测试。
- hotfix：线上紧急修复。

**详细回答**
Git Flow 适合多人协作和版本管理，流程清晰但略显复杂。

**扩展/对比**

- GitHub Flow：main+feature，简洁，常用于持续交付。
- GitLab Flow：结合 CI/CD，支持环境分支。
- **面试追问**：你们团队用哪种？👉 可答“我们根据团队规模选 GitHub Flow，简单高效”。

---

### 11. rebase vs merge 🔥

**一句话回答**
merge 保留完整历史，rebase 让历史线性但会改写提交。

**要点**

- merge：保留分支点，生成合并提交。
- rebase：把提交“搬运”到目标分支顶端。
- rebase 更干净，但会改写历史。
- 常见实践：公共分支用 merge，个人分支用 rebase。

**详细回答**
merge 用于多人协作，安全。
rebase 适合本地整理提交历史，让记录更简洁。

**扩展/对比**

- **面试追问**：什么时候不能 rebase？👉 已 push 的公共分支。
- **实践**：团队常用“squash merge” → 提交历史干净。

---

### 12. 缓存 🔥

**一句话回答**
缓存分为浏览器存储（cookie、storage、indexedDB）和网络缓存（强缓存、协商缓存、DNS）。

**要点**

- Cookie：小容量，随请求，常用于鉴权。
- localStorage/sessionStorage：前端存储，容量 ~5MB。
- IndexedDB：适合离线大数据。
- 强缓存：Cache-Control/Expires。
- 协商缓存：ETag/Last-Modified。
- DNS 缓存：减少解析时间。

**详细回答**
缓存能减少请求、提升性能。浏览器存储和网络缓存结合，形成多层级的性能优化体系。

**扩展/对比**

- **面试追问**：token 放哪？👉 cookie + HttpOnly 更安全；localStorage 方便但易被 XSS 窃取。
- **实践**：CDN 缓存 vs 浏览器缓存，前者减轻服务端压力，后者优化用户体验。

---

