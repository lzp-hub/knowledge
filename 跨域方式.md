# 跨域

## 一、什么是跨域？

### 1. 什么是同源策略及其限制内容？

同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"**协议+域名+端口**"三者相同，即便两个不同的域名指向同一个ip地址，也非同源

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/23/1638b3579d9eeb32~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

**同源策略限制内容有：**

- Cookie、LocalStorage、IndexedDB 等存储性内容
- DOM 节点
- AJAX 请求发送后，结果被浏览器拦截了

但是有三个标签是允许跨域加载资源：

- `<img src=XXX>`
- `<link href=XXX>`
- `<script src=XXX>`

### 2. 常见跨域场景

当**协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域**。不同域之间相互请求资源，就算作“跨域”。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/5/23/1638b3579dde630e~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

特别说明两点：

- 第一：如果是协议和端口造成的跨域问题“后端”是无能为力的。
- 第二：在跨域问题上，仅仅是通过“URL的首部”来识别而不会根据域名对应的IP地址是否相同来判断。**“URL的首部”可以理解为“协议, 域名和端口必须匹配”。**

**跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。**你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会?因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。

## 二、跨域解决方案

### JSONP

原理利用 `<script>` 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。**JSONP请求一定需要对方的服务器做支持才可以。**

> + 好处：简单兼容性好，可以向老浏览器或不支持CORS的网站请求数据
>
> + 缺点：仅支持**get**方法具有局限性,不安全可能会遭受**XSS**攻击。

**JSONP的实现流程**

1. **声明一个回调函数，其函数名(如show)当做参数值**，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。
2. **创建一个`<script>`**标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过**问号传参:?callback=show**）。
3. **服务器**接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成**一个字符串**,例如：传递进去的函数名是show，它准备好的数据是`show('我不爱你')`。
4. 最后服务器把准备的数据通过HTTP协议返回给客户端，**客户端再调用执行之前声明的回调函数（show）**，对返回的数据进行操作。

在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。

```js
// index.html
function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) => {
    let script = document.createElement('script')
    window[callback] = function(data) {
      resolve(data)
      document.body.removeChild(script)
    }
    params = { ...params, callback } // wd=b&callback=show
    let arrs = []
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`)
    }
    script.src = `${url}?${arrs.join('&')}`
    document.body.appendChild(script)
  })
}

jsonp({
  url: 'http://localhost:3000/say',
  params: { wd: 'Iloveyou' },
  callback: 'show'
}).then(data => {
  console.log(data)
})
```

上面这段代码相当于向`http://localhost:3000/say?wd=Iloveyou&callback=show`这个地址请求数据，然后后台返回`show('我不爱你')`，最后会运行show()这个函数，打印出'我不爱你'

```js
// server.js
let express = require('express')
let app = express()
app.get('/say', function(req, res) {
  let { wd, callback } = req.query
  console.log(wd) // Iloveyou
  console.log(callback) // show
  res.end(`${callback}('我不爱你')`)
})
app.listen(3000)
```

------

### proxy(node中间代理)

webpack proxy即`webpack`提供的代理服务。基本行为就是接收客户端发送的请求后转发给其他服务器

其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）

想要实现代理首先需要一个中间服务器，`webpack`中提供服务器的工具为`webpack-dev-server`

**webpack-dev-server**

`webpack-dev-server`是 `webpack` 官方推出的一款开发工具，将**自动编译和自动刷新浏览器等一系列**对开发友好的功能全部集成在了一起。目的是为了提高开发者日常的开发效率，**只适用在开发阶段**，

> `devServetr`里面`proxy`则是关于代理的配置，该**属性为对象**的形式，对象中**每一个属性**就是一个代理的规则匹配，即可以配置**多个代理**。
>
> **属性的名称是需要被代理的请求路径前缀**，一般为了辨别都会设置前缀为` /api`，**值**为对应的代理匹配规则，对应如下：
>
> - target：表示的是代理到的目标地址
> - changeOrigin：是否代理跨域
> - pathRewrite：默认情况下，我们的 /api 也会被写入到URL中，如果希望删除，可以使用pathRewrite
> - secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false

我们可以通过`webpack`为我们起一个本地服务器作为请求的代理对象，通过该服务器转发请求至目标服务器，得到结果再转发给前端，但是**最终发布上线时如果web应用和接口服务器不在一起仍会跨域**

+ 如果是通过`vue-cli`脚手架工具搭建项目，在`vue.config.js`文件，新增以下代码
+ 如果是通过自定义，可通过`webpack.config.js`配置文件，新增以下代码

```js
const path = require('path')
module.exports = {
		    // 中间服务器，记得去package.json配置启动服务器的运行命令脚本：webpack-dev-server
  			// ...
    devServer: {
        contentBase: path.join(__dirname, "./public"), // 配置服务器根目录
        port: 8888, // 默认是 8080
        host: "localhost", //主机名， 本地：localhost  127.0.0.1， 真机 0.0.0.0，
        https: false, // 协议
        open: true, // 项目启动时自动打开浏览器
      
        proxy: {
            // '/api'是被代理请求路径前缀标识，用于告诉node，url前面是/api的就是使用代理的
            "/sinaapi": {
                target: "https://m.weibo.cn",// 代理到的目标地址，一般是指后台服务器地址
                changOrigin: true, //是否代理跨域
                pathRewrite: {
                    "^/sinaapi": "" // pathRewrite 的作用是把实际Request Url中的'/api'用""代替
                }
            }
        }
    },		
}

request.get('http://localhost:9900/sinaapi/api/config/list')
// 最后会实现 https://m.weibo.cn/api/config/list
```

可以配合`axios`进行请求，配置**baseURL**请求的根路径，于proxy的路径代理标识相同

```js
import axios from 'axios';
const request = axios.create({
    // 根据不同环境设置 baseURL, 最终发送请求时的URL为: baseURL + 发送请求时写URL ,
    // 比如 get('/test'), 最终发送请求是: /api/test
    baseURL: "/api",
    timeout: 5000, // 请求超时
});

export default request;
```

**`proxy`工作原理实质上是利用`http-proxy-middleware` 这个`http`代理中间件，实现请求转发给其他服务器**

**服务端实现代理请求转发**

在开发阶段，本地地址为`http://localhost:3000`，该浏览器发送一个前缀带有`/api`标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中

```js
const express = require('express');
const proxy = require('http-proxy-middleware');

const app = express();
app.use('/api', proxy({target: 'http://www.example.org', changeOrigin: true}));
app.listen(3000);

// http://localhost:3000/api/foo/bar -> http://www.example.org/api/foo/bar
```

**服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制**

------

### **CORS**

Cross-origin resource sharing（跨来源资源共享）通信过程都是浏览器自动完成，需要浏览器(都支持)和服务器都支持，所以关键在**只要服务器支持，就可以跨域通信**

浏览器将跨域请求分为两类：**简单请求和非简单请求**。

同时满足以下两大条件的，就属于简单请求：

- 请求方法是以下3种之一：

- - GET
  - POST
  - HEAD

- HTTP头信息**不超出**以下字段：

- - Accept
  
  - Accept-Language
  
  - Content-Language
  
  - Last-Event-ID
  
  - Content-Type：值为三者之一： application/x-www-form-urlencoded、multipart/form-data、text/plain
  
    > + application/x-www-form-urlencoded 作为表单提交中默认的类型，其表明数据以标准的编码格式被编码为键值对。 数据被编码成以 '&' 分隔的键-值对, 同时以 '=' 分隔键和值
    >
    > + multipart/form-data：一般用于涉及文件的表单提交，用于post请求
    >
    > + text/plain：文本

需要这些条件是为了兼容表单，因为历史上表单一直可以跨域

凡是不满足以上条件的，就属于非简单请求。如我们常用的json格式请求，由于其Content-Type的值为application/json，因此属于非简单请求。

对于这两种请求，浏览器的处理方式是不一样的

**简单请求**

浏览器采用先请求后判断的方式，即浏览器直接发出CORS请求，即在**请求头中增加Origin**字段，表示请求来源来自哪个域(协议+域名+端口)，**服务器根据这个值决定是否同意请求**。

服务器即使判断该源如果不在自己允许的范围内，也会返回一个正常的HTTP响应。此时**浏览器判断响应头中是否包含Access-Control-Allow-Origin**字段，如果没有，浏览器就知道当前服务器是跨域访问的，就会抛出错误。

如果Origin在服务器允许的范围内，服务器的HTTP**响应**中，就会包含如下字段：

+ Access-Control-Allow-Origin 

  > 它的值要么是请求时Origin字段的值，要么是一个*（表示接受任意域名的请求）。

+ Access-Control-Allow-Credentials 

  > 它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。

+ Access-Control-Allow-Headers 

  > 允许浏览器在CORS中发送的头信息。

+ Access-Control-Allow-Methods  

  > 允许浏览器在CORS中使用的方法。

快速记忆：前缀是Access-Control-Allow-  +  Origin，Credentials，Headers，Methods，

**因此在简单请求中服务器至少需要设置：`Access-Control-Allow-Origin` 字段才可跨域**

**非简单请求**

比如 PUT 或 DELETE 请求，或 Content-Type 为 application/json等等 ，就是非简单请求。

非简单请求，**正式请求前会发一次 OPTIONS 类型的查询请求**，称为`预检请求`，询问服务器是否支持网页所在域名的请求，以及可以使用哪些头信息字段。**只有收到肯定的答复，才会发起正式XMLHttpRequest请求，否则报错**

预检**请求**的方法是**OPTIONS**，它的**请求头**信息中有几个字段

- **Access-Control-AllowOrigin**: 表示请求来自哪个域，这个字段是必须的
- **Access-Control-Request-Method**：列出CORS请求会用到哪些HTTP方法，这个字段是必须的
- **Access-Control-Request-Headers**： 指定CORS请求会额外发送的头信息字段，用逗号隔开

**OPTIONS请求**次数过多也会损耗性能，所以要尽量减少OPTIONS请求，这时可以让服务器在**响应头**部**添加 Access-Control-Max-Age，表示预检请求的返回结果可以被缓存多久，在这个时间范围内再请求就不需要预检了。不过这个缓存**只对完全一样的URL才会生效**

```css
Access-Control-Max-Age: // 数字 单位是秒，例如：3600，即允许缓存该条回应3600秒
```

------

CORS请求**默认不包含Cookie以及HTTP认证信息**，如果需要包含Cookie，需要满足几个条件：

> 1. 前端请求时在`request`对象中配置`"withCredentials": true`；
> 2. 服务端在`response`的`header`中配置`"Access-Control-Allow-Credentials", "true"`
> 3. 服务端在`response`的`header`中配置 `Access-Control-Allow-Origin不要设为*星号`，指定明确的与请求网页一致的域名，这样才不会把其他域名的Cookie上传
> 4. Set-Cookie: **SameSite**=None; Secure

### 跨域时怎么处理 cookie？

1. 前端请求时在`request`对象中配置`"withCredentials": true`；

   **XMLHttpRequest.withCredentials** 属性是一个[`Boolean`](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FBoolean)类型，它指示了是否该使用类似cookies,authorization headers(头部授权)或者TLS客户端证书这一类资格证书来创建一个跨站点访问控制（cross-site `Access-Control`）请求。在同一个站点下使用`withCredentials属性是无效的。`

   如果在发送来自其他域的XMLHttpRequest请求之前，未设置`withCredentials` 为true，那么就不能为它自己的域设置cookie值。**而通过设置`withCredentials` 为true获得的第三方cookies，将会依旧享受同源策略，因此不能被通过document.cookie或者从头部相应请求的脚本等访问。**

   ```js
   // axios方式
   axios({
         withCredentials: true, // ++ 新增
         method: "get",
         url: "http://localhost:8003/anotherService",
       }).then((res) => {
         console.log(res);
       });
   
   // 原生xhr方式
   var xhr = new XMLHttpRequest();
   var url = 'http://bar.other/resources/credentialed-content/';
   
   function callxhr(){
     if(xhr) {
       xhr.open('GET', url, true);
       xhr.withCredentials = true; // 带上cookie
       xhr.onreadystatechange = function () {
         if (xhr.readyState === 4) {
           fn(xhr.responseText);
         };
       xhr.send();
     }
   }
   ```

2. 服务端在`response`的`header`中配置`"Access-Control-Allow-Credentials", "true"`

   ```js
   app.all("*", (req, res, next) => {
     res.header("Access-Control-Allow-Origin", "http://localhost:8000");  // ++ 新增
     res.header("Access-Control-Allow-Credentials", "true"); // ++ 新增
     next();
   });
   
   ```

3. 服务端在`response`的`header`中配置`"Access-Control-Allow-Origin", "http://xxx:${port}"`;

   > `Access-Control-Allow-Origin不要设为*星号`，指定明确的与请求网页一致的域名，这样就不会把其他域名的Cookie上传

4. set-cookie时将cookie的sameSite设置为none；由于将sameSite设置为none时，此时也要将Secure设置上，因为Cookie 只能通过 HTTPS 协议发送;

   > SameSite 属性可用来**限制第三方 Cookie** 。有三个值：
   >
   > - `strict`：严格模式，完全禁止使用Cookie
   > - `lax`：宽松模式，允许部分情况使用Cookie，`跨域的都行`，a标签跳转，link标签，GET提交的表单
   > - `none`：任何情况下都会发送Cookie，但必须同时设置Secure属性，意思是需要安全上下文，Cookie `只能通过https发送`，否则无效
   >
   > Chrome 80之前默认值是none，之后是lax。不过在最新的 `Chrome91` 版本中这个`已经被移除`了，所以在 91之前的版本依然可以使用

   ```css
   // Set-Cookie: SameSite=None; Secure
   response.setHeader("Set-Cookie", "HttpOnly;Secure;SameSite=None")
   ```

------

### postMessage

postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：

- 页面和其打开的新窗口的数据传递
- 多窗口之间消息传递
- 页面与嵌套的iframe消息传递
- 上面三个场景的跨域数据传递

**postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递**。

```js
otherWindow.postMessage(message, targetOrigin, [transfer]);
```

+ message: 将要发送到其他 window的数据。
+ targetOrigin:通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串"*"（表示任意窗口）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。
+ transfer(可选)：是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

接下来我们看个例子： `http://localhost:3000/a.html`页面向`http://localhost:4000/b.html`传递“我爱你”,然后后者传回"我不爱你"。

```html
// a.html
  <iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"></iframe> //等它加载完触发一个事件
  //内嵌在http://localhost:3000/a.html
    <script>
      function load() {
        let frame = document.getElementById('frame')
        frame.contentWindow.postMessage('我爱你', 'http://localhost:4000') //发送数据
        window.onmessage = function(e) { //接受返回数据
          console.log(e.data) //我不爱你
        }
      }
    </script>
```

```html
// b.html
  window.onmessage = function(e) {
    console.log(e.data) //我爱你
    e.source.postMessage('我不爱你', e.origin)
 }
```

------

### WebSocket

WebSocket是HTML5标准中的一种通信协议，以`ws://`(非加密)和`wss://`(加密)作为协议前缀，该协议不实行同源政策，只要服务器支持就行。因为WebSocket请求头信息中有Origin字段，表示请求源来自哪个域，服务器可以根据这个字段判断是否允许本次通信，如果在白名单内，就可以通信

Websocket是HTML5的一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。WebSocket和HTTP都是应用层协议，都基于 TCP 协议。但是 **WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据**。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。

原生WebSocket API使用起来不太方便，我们使用`Socket.io`，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

我们先来看个例子：本地文件socket.html向`localhost:3000`发生数据和接受数据

```html
// socket.html
<script>
    let socket = new WebSocket('ws://localhost:3000');
    socket.onopen = function () {
      socket.send('我爱你');//向服务器发送数据
    }
    socket.onmessage = function (e) {
      console.log(e.data);//接收服务器返回的数据
    }
</script>
```

```js
// server.js
let express = require('express');
let app = express();
let WebSocket = require('ws');//记得安装ws
let wss = new WebSocket.Server({port:3000});
wss.on('connection',function(ws) {
  ws.on('message', function (data) {
    console.log(data);
    ws.send('我不爱你')
  });
})
```

### nginx反向代理

未了解