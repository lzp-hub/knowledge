# 手写代码

### 实现原生的AJAX请求

```js
const ajax = {
    get(url, data, fn) {
     		//	兼容IE7 之前
        const xhr = !!window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHttp")
        // const xhr = new XMLHttpRequest();
      	const dataArr = []
      	for(let key in data){
           dataArr.push(`${key}=${data[key]}`) 
        }
        xhr.open("GET",`${url}${ !!dataArr.length ? '?': ''}${dataArr.join('&')}`, true);
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                fn(xhr.responseText);
            }
        };
        xhr.send();
    },
    post(url, data, fn) {
        const xhr = new XMLHttpRequest();
      	const dataArr = []
      	for(let key in data){
           dataArr.push(`${key}=${data[key]}`) 
        }
        xhr.open("POST", url, true);
        xhr.setRequestHeader("Content-type", "appplication/x-www-form-urlencoded");
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                fn(xhr.responseText);
            }
        };
        xhr.send(dataArr.join('&'));
    },
};
```

------

### JavaScript深入之从原型到原型链

**构造函数、实例原型、和实例之间的关系**

每个函数都有一个 **prototype** 属性，指向了一个对象，这个对象正是调用该构造函数而创建的**实例**的原型，也就是这个例子中的 person

```js
function Person() {
}
var person = new Person();

// 实例与实例原型
console.log(person.__proto__ === Person.prototype); // true
// 顺便学习一个ES5的方法,可以获得对象的原型
console.log(Object.getPrototypeOf(person) === Person.prototype) // true
// 每个原型都有一个 constructor 属性指向关联的构造函数
console.log( Person.prototype.constructor === Person ); // true
```

**实例与原型**

当读取**实例的属性**时，如果找不到，就会查找**与对象关联的原型**中的属性，如果还查不到，就去找**原型的原型**，一直找到最顶层为止。

```js
function Person() {
}

Person.prototype.name = 'Kevin';

var person = new Person();

person.name = 'Daisy';
console.log(person.name) // Daisy

delete person.name;
console.log(person.name) // Kevi
```

在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。

但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 `person.__proto__` ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。

但是万一还没有找到呢？原型的原型又是什么呢? 在这里是

```js
console.log(Person.prototype.__proto__ === Object.prototype) // true
// 或者
console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype)
```

那 Object.prototype 的原型呢？

```js
console.log(Object.prototype.__proto__ === null) // true
// 或者
console.log(Object.getPrototypeOf(Object.prototype) === null)
```

**查找属性的时候查到 Object.prototype 就可以停止查找了**

原型组成的链状结构就是原型链，比如：person >>> Person.prototype >>> Object.prototype >>> null

------

### 手写new的过程

new关键字内部干了如下4件事

> 1. 首先创一个新的空对象。
> 2. 根据原型链，设置空对象的 `__proto__` 为构造函数的 `prototype` 。
> 3. 构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。
> 4. 判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。

+ 方式1，使用 `__proto__`

```js
const MyNew = function (fn) {
    const obj = new Object();
    obj.__proto__ = fn.prototype;
    const result = fn.apply(obj, Array.prototype.slice.call(arguments, 1));
    return result instanceof Object ? result : obj;
};
```

+ 方式2，**Object.setPrototypeOf**（现有对象,原型对象  ) 为现有对象设置原型，返回一个新对象。

```js
function myNew(fn) { 
    const obj = new Object();
    Object.setPrototypeOf(obj, fn.prototype);
    const result = fn.apply(obj, [...arguments].slice(1));
    return result instanceof Object ? result : obj;
}
```

------

### 手写Instanceof的过程

Instanceof实现原理是通过原型链判断的，在instanceof左侧对象的原型链上找到等于右侧原型对象

+ 方式1，使用 `__proto__`

```js
function myInstanceof(obj, Fn) {
    // 获取左边的 __proto__  原型链
    let proto = obj.__proto__;
  	//obj.__proto__往上找不到了就返回false，退出循环，
    while (proto) {
        // 如果原型链和原型对象相等说明在，直接返回true结束函数
        if (proto === Fn.prototype) {
            return true;
        }
        // 往上找，当前找不到就获取上一级的原型对象
        proto = proto.__proto__;
    }
    return false;
}
```

+ 方式2，**Object.getPrototypeOf(obj )** 方法用于获取指定对象的原型对象（也就是`__protp__`的指向）

```js
function myInstanceof(obj, Fn) {
  	if (typeof obj !== "object" || obj === null) return false;
  	if (typeof Fn !== "function") throw new TypeError("Fn must be function");
    // 判断构造函数 Fn 是否出现在 obj 的原型链上
    let proto = Object.getPrototypeOf(obj)
    while (proto) {
      if (proto === Fn.prototype) {
         	return true
      }
      proto = Object.getPrototypeOf(proto)
    }
    return false
  }

function Foo() { }
var f1 = new Foo();
console.log(myInstanceof(f1, Foo)); //true
console.log(myInstanceof(f1, Object)); //true
console.log(myInstanceof(Object, Function)); //true
console.log(myInstanceof(Object, Object)); //true
console.log(myInstanceof(Function, Object)); //true
console.log(myInstanceof(Function, Function)); //true
console.log(myInstanceof(Object, Foo)); //false
```

------

### 手写防抖debounce

搜索框搜索输入、窗口大小 resize 变化后，再重新渲染

```js
const container = document.getElementById("container");
let count = 1;
function getUserAction(event) {
    console.log("event", event, "this", this);
    container.innerHTML = count++;
}
container.onmousemove = debounce(getUserAction, 3000)
```

+ 简单版

```js
function debounce(fun, wait) {
    let timeout = null;
    return function (...args) {
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
            fun.apply(this, args); 
        }, wait);
    };
}
```

+ 我不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。

  想想这个需求也是很有道理的嘛，那我们加个 immediate 参数判断是否是立刻执行。

```js
function debounce(fun, wait,immediate) {
    let timeout = null;
    return function (...args) {
        if (timeout) {
            clearTimeout(timeout)
        }
        if (immediate) {
            // 只有计时结束到，令timeout = null才可触发
            var callNow = !timeout;
            timeout = setTimeout(()=>{
                timeout = null;
            }, wait)
            if (callNow) {
                fun.apply(this, args)
            }
        }else{
            timeout = setTimeout(()=>{
                fun.apply(this, args)
            }, wait);
        }
    }
}
```

------

### 手写节流throttle

onscroll事件 滚动加载更多

```js
const container = document.getElementById("container");
let count = 1;
function getUserAction(event) {
    console.log("event", event, "this", this);
    container.innerHTML = count++;
}
container.onmousemove = throttle(getUserAction, 3000)
```

+ 使用时间戳 ——第一种事件会立刻执行，停止触发后没有办法再执行事件。

  当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。

  > 当鼠标移入的时候，事件立刻执行，每过 3s 会执行一次，如果在 4.2s 停止触发，以后不会再执行事件。

```js
function throttle(func, wait) {
    let pass = 0;
    return function(...args) {
        const now = Date.now();
        if (now - pass > wait) {
            func.apply(this, args);
            pass = now;
        }
    }
}
```

+ 使用**定时器**实现——事件会在 n 秒后第一次执行，停止触发后依然会再执行一次事件。

  当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器

  > 当鼠标移入的时候，事件不会立刻执行，晃了 3s 后终于执行了一次，此后每 3s 执行一次，当数字显示为 3 的时候，立刻移出鼠标，相当于大约 9.2s 的时候停止触发，但是依然会在第 12s 的时候执行一次事件。

```js
function throttle(func, wait) {
    let timeout = null;
    return function(...args) {
        if (!timeout) {
            timeout = setTimeout(()=>{
                func.apply(this, args)
                timeout = null;
            }, wait)
        }
    }
}
```

+ 双剑合璧——鼠标移入能立刻执行，停止触发的时候还能再执行一次！

```js
function throttle(func, wait) {
    let timeout = null;
    let pass = 0;
    return function () {
        const now = +new Date();
        const args = arguments;
        //下次触发 func 剩余的时间
        var remaining = wait - (now - pass);
        // 如果没有剩余的时间了或者你改了系统时间
        if (remaining <= 0 || remaining > wait) {
            // 使用时间戳
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            pass = now;
            func.apply(this, args);
        } else if (!timeout) {
            // 使用定时器方式节流
            timeout = setTimeout(() => {
                pass = +new Date();
                func.apply(this, args);
                timeout = null;
            }, remaining);
        }
    };
}
```

## 深浅拷贝

### 浅拷贝

浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝

如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址

即**浅拷贝是拷贝一层，深层次的引用类型则共享内存地址**

下面手动简单实现一个浅拷贝

```js
function clone(obj) {
    const newObj = {};
    for(let key in obj) {
      	//hasOwnProperty 可以判断一个属性定义在对象本身而不是继承原型链的方法
        if(obj.hasOwnProperty(key)){
            newObj[key] = obj[key];
        }
    }
    return newObj;
}
```

在`JavaScript`中，存在浅拷贝的现象有：

+ _clone( )             lodash工具函数

  ```js
  import { clone } from 'lodash'
  const obj = {
    name: 'lin'
  }
  
  const newObj = clone(obj)
  obj.name = 'xxx'     // 改变原来的对象
  console.log('两者指向同一地址', obj == newObj) // false
  ```

- `Object.assign`

  ```js
  const obj = {
    name: 'lin'
  }
  const newObj = Object.assign({}, obj)
  obj.name = 'xxx' // 改变原来的对象
  console.log(newObj) // { name: 'lin' } 新对象不变（第一层）
  console.log(obj == newObj) // false 两者指向不同地址
  ```

- `Array.prototype.slice()`

  ```js
  const fxArr = ["One", "Two", "Three"]
  const fxArrs = fxArr.slice(0)
  fxArrs[1] = "love";
  console.log(fxArr) // ["One", "Two", "Three"]
  console.log(fxArrs) // ["One", "love", "Three"]
  ```

-  `Array.prototype.concat()`

  ```js
  const fxArr = ["One", "Two", "Three"]
  const fxArrs = fxArr.concat()
  fxArrs[1] = "love";
  console.log(fxArr) // ["One", "Two", "Three"]
  console.log(fxArrs) // ["One", "love", "Three"]
  ```

- 拓展运算符 实现的数组或者对象的浅拷贝

  ```js
  const fxArr = ["One", "Two", "Three"]
  const fxArrs = [...fxArr]
  fxArrs[1] = "love";
  console.log(fxArr) // ["One", "Two", "Three"]
  console.log(fxArrs) // ["One", "love", "Three"]
  
  const obj = {
    name: 'lin'
  }
  const newObj = { ...obj }
  obj.name = 'xxx' // 改变原来的对象
  console.log(newObj) // { name: 'lin' } // 新对象不变
  console.log(obj == newObj) // false 两者指向不同地址
  ```

+ 数组静态方法 Array.from

  ```js
  const arr = ['lin', 'is', 'handsome']
  const newArr = Array.from(arr)
  arr[2] = 'rich' // 改变原来的数组
  console.log(newArr) // ['lin', 'is', 'handsome']
  console.log(arr == newArr) // false 两者指向不同地址
  ```

### 深拷贝

深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性

常见的深拷贝方式有：

-   _.cloneDeep()   		 lodash工具函数

  ```js
  const _ = require('lodash');
  const obj1 = {
      a: 1,
      b: { f: { g: 1 } },
      c: [1, 2, 3]
  };
  const obj2 = _.cloneDeep(obj1);
  console.log(obj1.b.f === obj2.b.f);// false
  ```

- jQuery.extend()

  ```js
  const $ = require('jquery');
  const obj1 = {
      a: 1,
      b: { f: { g: 1 } },
      c: [1, 2, 3]
  };
  const obj2 = $.extend(true, {}, obj1);
  console.log(obj1.b.f === obj2.b.f); // false
  ```

- JSON.parse(JSON.stringify( ))

  首先通过stringify将json序列化(json字符串)，然后在通过parse实现反序列(还原)js对象，序列化的作用是存储和传输，在这个过程中就会开启新的内存空间就会产生和源对象不一样的空间从而实现深拷贝，实际开发中这个用法已经可以解决很多场景了，但是依然有很多弊端。

  > 1. 会忽略`undefined`、`symbol`和`函数`
  >
  > ```js
  > const obj = {
  >   a: undefined,
  >   b: Symbol('b'),
  >   c: function () {}
  > }
  > 
  > const newObj = JSON.parse(JSON.stringify(obj))
  > console.log(newObj) // {} 
  > ```
  >
  > 2. `NaN`、`Infinity`、`-Infinity` 会被序列化为 `null`：
  >
  > ```js
  > const obj = {
  >   a: NaN,
  >   b: Infinity,
  >   c: -Infinity
  > }
  > const newObj = JSON.parse(JSON.stringify(obj))
  > console.log(newObj) // {a: null, b: null, c: null}
  > ```
  >
  > 3. 正则RegExp、Error对象会变为空对象
  >
  > ```js
  > const obj = {
  >   a: /123/
  > }
  > const newObj = JSON.parse(JSON.stringify(obj))
  > console.log(newObj) // {a:{}}
  > ```

- 手写循环递归

  > + 支持对象、数组、日期、正则的拷贝。
  > + 处理 DOM 元素（DOM 元素直接返回，拷贝 DOM 元素没有意义，都是指向页面中同一个）。
  >
  > + 处理原始类型（原始类型直接返回，只有引用类型才有深拷贝这个概念）。
  >
  > + 处理函数（函数直接返回，拷贝函数没有意义，两个对象使用内存中同一个地址的函数，问题不大）。
  >
  > + 额外开辟一个储存空间 WeakMap，解决循环引用递归爆栈问题（引入 WeakMap 的另一个意义，配合垃圾回收机制，防止内存泄漏,因为对象是一组键/值对的集合，其中的键是弱引用的。）
  >
  > ```js
  > function deepClone(obj, map = new WeakMap()) {
  >   if (obj === null) return obj; // 如果是null，不需要深拷贝，直接返回
  >   if (obj instanceof Date) return new Date(obj);
  >   if (obj instanceof RegExp) return new RegExp(obj);
  >   if (obj instanceof HTMLElement) return obj 
  > 	// 处理原始类型和函数 不需要深拷贝，直接返回
  >   if (typeof obj !== "object") return obj;
  > 
  >   if (map.has(obj)) return map.get(obj)
  >   // 创建一个新的克隆对象或克隆数组
  >   let cloneObj = new obj.constructor();
  >   map.set(obj, cloneObj);
  >   for (const key in obj) {
  >     if (obj.hasOwnProperty(key)) {
  >       // 实现一个递归拷贝
  >       cloneObj[key] = deepClone(obj[key], map);
  >     }
  >   }
  >   return cloneObj;
  > }
  > // obj.a = obj
  > ```
  > 
  >1. `new 实例.constructor()`运用在我们的深拷贝函数里，就不用在拷贝时去判断数组或者对象类型了。原对象是对象，就创建一个新的克隆对象，原对象是数组，就创建一个新的克隆数组
  > 
  > ```js
  >    let cloneObj = new obj.constructor();
  > 
  >    console.log([].constructor === Array)  // true
  >    console.log({}.constructor === Object) // true
  > 
  >    console.log(new {}.constructor())  // {}
  >    // 等价于
  >    console.log(new Object()) // {}
  > 
  >    console.log(new [].constructor())  // {}
  >    // 等价于
  >    console.log(new Array()) // []
  >  ```
  > 
  >2. 解决**循环引用**问题，即对象的属性间接或直接的引用了自身的情况，不处理会导致递归进入死循环导致栈内存溢出。
  > 
  > > 我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话就继续拷贝，这样就巧妙化解的循环引用的问题。
  > 
  > ```js
  >    	// obj.obj = obj // 循环引用场景
  > 
  >     const map = new WeakMap()// 额外开辟一个存储空间来存储当前对象和拷贝对象的对应关系
  >    	if (map.has(obj)) { // 当需要拷贝当前对象时，先去存储空间中找，如果有的话直接返回
  >        	return map.get(obj) 
  >      };
  >     	map.set(obj, cloneObj); // (key:value) 如果存储空间中没有就存进存储空间 map 里
  >  ```

**区别：** 下面首先借助两张图，可以更加清晰看到浅拷贝与深拷贝的区别

![](https://static.vue-js.com/d9862c00-69b8-11eb-ab90-d9ae814b240d.png)

从上图发现，浅拷贝和深拷贝都创建出一个新的对象，但在复制对象属性的时候，行为就不一样

浅拷贝只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象

```js
// 浅拷贝
const obj1 = {
    name : 'init',
    arr : [1,[2,3],4],
};
const obj3=clone(obj1) // 一个浅拷贝方法
obj3.name = "update";
obj3.arr[1] = [5,6,7] ; // 新旧对象还是共享同一块内存

console.log('obj1',obj1) // obj1 { name: 'init',  arr: [ 1, [ 5, 6, 7 ], 4 ] }
console.log('obj3',obj3) // obj3 { name: 'update', arr: [ 1, [ 5, 6, 7 ], 4 ] }
```

但深拷贝会另外创造一个一模一样的对象，**新对象跟原对象不共享内存**，修改新对象不会改到原对象

```js
// 深拷贝
const obj1 = {
    name : 'init',
    arr : [1,[2,3],4],
};
const obj4=deepClone(obj1) // 一个深拷贝方法
obj4.name = "update";
obj4.arr[1] = [5,6,7] ; // 新对象跟原对象不共享内存

console.log('obj1',obj1) // obj1 { name: 'init', arr: [ 1, [ 2, 3 ], 4 ] }
console.log('obj4',obj4) // obj4 { name: 'update', arr: [ 1, [ 5, 6, 7 ], 4 ] }
```

前提为拷贝类型为引用类型的情况下：

- **浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址**
- 深拷贝是**递归拷贝深层次**，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址

### object.assign和扩展运算法两者区别是什么？

两者都是**浅拷贝**。

+ Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。源对象所**有可枚举属性都会复制**

+ 扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它**不复制继承的属性或类的属性**，但是它会复制ES6的 symbols 属性。

### 手写call

call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。

实现原理：传递进去的对象添加fn属性，执行完之后再删除该属性

```js
Function.prototype.myCall = function (context, ...args) {
    // 判断调用对象
    if (typeof this !== "function") {
        throw new Error("Type error");
    }
    let result = null;
    // 判断 context 是否传入，如果没有传就设置为 window
    context = context || window;
    // 将被调用的方法(this)设置为 context 的属性fnSymbol,Symbol 来保证属性唯一
    const fnSymbol = Symbol();
    context[fnSymbol] = this;
    // 执行要被调用的方法fn
    result = context[fnSymbol](...args);
    // 删除手动增加的属性方法fn
    delete context[fnSymbol];
    // 将执行结果返回
    return result;
};

const obj = {
    value: "vortesnail",
};
function fn(a, b) {
    console.log(this.value, a, b);
}
fn.myCall(obj, 'lzp', 'hello'); // vortesnail lzp hello
```

### 手写apply

```JS
Function.prototype.myApply = function (context, args) {
    // 判断调用对象
    if (typeof this !== "function" || !Array.isArray(args)) {
        throw new Error("Type error");
    }
    let result = null;
    // 判断 context 是否传入，如果没有传就设置为 window
    context = context || window;
    // 将被调用的方法(this)设置为 context 的属性fnSymbol,Symbol 来保证属性唯一
    const fnSymbol = Symbol();
    context[fnSymbol] = this;
    // 执行要被调用的方法fn
    result = context[fnSymbol](...args);
    // 删除手动增加的属性方法fn
    delete context[fnSymbol];
    // 将执行结果返回
    return result;
};

const obj = {
    value: "vortesnail",
};
function fn(a, b) {
    console.log(this.value, a, b);
}
fn.myApply(obj, ['lzp', 'hello']); // vortesnail lzp hello
```

### 手写bind

`bind()` 方法创建一个新的函数，在 `bind()` 被调用时，这个新函数的 `this` 被指定为 `bind()` 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

`bind` 方法与 `call / apply` 最大的不同就是前者返回一个绑定上下文的**函数**，而后两者是**直接执行**了函数。例如：

```js
let value = 2;
let foo = {
    value: 1
};
function bar(name, age) {
    return {
        value: this.value,
        name: name,
        age: age
    }
};

bar.call(foo, "Jack", 20); // 直接执行了函数
// {value: 1, name: "Jack", age: 20}

let bindFoo1 = bar.bind(foo, "Jack", 20); // 返回一个函数
bindFoo1();
// {value: 1, name: "Jack", age: 20}

let bindFoo2 = bar.bind(foo, "Jack"); // 返回一个函数
bindFoo2(22);
// {value: 1, name: "Jack", age: 22}
```

通过上述代码可以看出 `bind` 有如下特性：

1. 指定 `this`
2. 传入参数
3. 返回一个函数
4. 柯里化

但是还要一个特性：一个**绑定函数也能使用 new 操作符创建对象**：这种行为就像把原函数当成构造器，提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。

``` js
let value = 2;
let foo = {
    value: 1
};
function bar(name, age) {
    this.habit = 'shopping';
    console.log(this.value);
    console.log(name);
    console.log(age);
}
bar.prototype.friend = 'kevin';

let bindFoo = bar.bind(foo, 'Jack');
let obj = new bindFoo(20); // undefined >>> Jack >>> 20

console.log(o.habit); // shopping
console.log(o.friend) // kevin
```

上面例子中，运行结果 `this.value` 输出为 `undefined` ，这不是全局 `value` 也不是 `foo` 对象中的 `value` ，这说明 **`bind` 的 `this` 对象失效了，`new` 的实现中生成一个新的对象**，这个时候的 `this` 指向的是 `obj` 。

**手写实现**

```js
Function.prototype.MyBind = function (context, ...args) {
    // 调用 bind 的不是函数，需要抛出异常
    if (typeof this !== "function") {
        throw new Error("Type error");
    }
    var fn = this;
    const newFn = function (...bindArgs) {
        // 作为构造函数时，this指向实例，所以不用传进来的context
        return fn.call(this instanceof newFn ? this : context, ...args, ...bindArgs);
    }
    // 一些情况下函数没有prototype，比如箭头函数
    if (fn.prototype) {
        // bind 和 Object.create() 都是ES5方法，部分IE浏览器（IE < 9）并不支
        // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
        newFn.prototype = Object.create(fn.prototype);
    }
    return newFn
}
```

### 数据类型

+ 在 JS 中共有 `7` 种基本的数据类型，分别为： `Undefined` 、 `Null` 、 `Boolean` 、 `Number` 、 `String`  、 `Symbol` 、 `BigInt` 。

  > ES6 新增的数据类型
  >
  > - Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。
  > - BigInt 可以表示任意大小的整数。

+ 引用类型：Array、Object、Function

**数据类型的判断**

#### typeof

能判断所有**基本数据类型，函数**。不可对 **null、对象、数组**进行精确判断，因为都返回 `object` 

```js
console.log(typeof undefined); // undefined
console.log(typeof 2); // number
console.log(typeof true); // boolean
console.log(typeof "str"); // string
console.log(typeof Symbol("foo")); // symbol
console.log(typeof 2172141653n); // bigint
console.log(typeof function () {}); // function
// 不能判别
console.log(typeof []); // object
console.log(typeof {}); // object
console.log(typeof null); // object
```

#### instanceof

能判断**对象**类型，不能判断基本数据类型，**其内部运行机制是判断在其原型链中能否找到该类型的原型**。

```js
class People {}
class Student extends People {}
const vortesnail = new Student();

console.log(vortesnail instanceof People); // true
console.log(vortesnail instanceof Student); // true
```

#### Object.prototype.toString.call()

**所有**原始数据类型都是能判断的，还有 **Error 对象，Date 对象**等。

```js
Object.prototype.toString.call(2); // "[object Number]"
Object.prototype.toString.call(""); // "[object String]"
Object.prototype.toString.call(true); // "[object Boolean]"
Object.prototype.toString.call(undefined); // "[object Undefined]"
Object.prototype.toString.call(null); // "[object Null]"
Object.prototype.toString.call(Math); // "[object Math]"
Object.prototype.toString.call({}); // "[object Object]"
Object.prototype.toString.call([]); // "[object Array]"
Object.prototype.toString.call(function () {}); // "[object Function]"
```

### 区分数组和对象

1. 通过 ES6 中的 **Array.isArray** 来识别

```js
console.log(Array.isArray([]))//true
console.log(Array.isArray({}))//false
```

2. 通过 **instanceof** 来识别

```js
console.log([] instanceof Array)//true
console.log({} instanceof Array)//false
```

3. 通过调用 **constructor** 来识别

```js
console.log([].constructor === Array)// true
console.log({}.constructor === Array)// false
```

4. 通过 **Object.prototype.toString.call** 方法来识别。借用Object原型的call或者apply方法，调用toString()是否为[object Array]

```js
console.log(Object.prototype.toString.call([]).slice(8,-1))// Array
console.log(Object.prototype.toString.call({}).slice(8,-1))// Object
```

5. **Object.getPrototypeOf** 方法返回指定对象的**原型**（内部[[Prototype]]属性的值）。

```js
Object.getPrototypeOf([]) === Array.prototype // true
[].__proto__ === Array.prototype // true
```

### 类数组对象

一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。

常见的类数组转换为数组的方法有这样几种：

1. 调用**数组的原型**方法来转换

   > 通过 call 调用数组的 **slice** 方法来实现转换
   >
   > ```css
   > Array.prototype.slice.call(arguments);
   > ```
   >
   > 通过 call 调用数组的 **splice** 方法来实现转换
   >
   > ```css
   > Array.prototype.splice.call(arguments, 0);
   > ```
   >
   > ```js
   > var foo = function(a,b){
   > 	console.log(Array.prototype.slice.call(arguments))
   > }
   > foo(1,2) //(2) [1, 2]
   > ```

2. 使用ES6中的 **Array.from()** 来转换

   `Array.from() ` 方法用于将两类对象转为真正的数组：类似数组的对象和可遍历对象（包括Set和Map）。

   ```js
   var foo = function(a,b){
   var arr = Array.from(arguments);
   		console.log(arr)
   }
   foo(1,2) // (2) [1, 2]
   ```

3. 利用 ES6 中的**扩展运算符** ...restappendChild

   ```js
   var foo = function(...args){
   		console.log(args)
   }
   foo(1,2) // (2) [1, 2]
   ```

4. 使用 for 循环挨个将 arguments 对象中的内容复制给新数组中

   ```js
   function foo(){
       var args = []; 
       for (var i = 0; i < arguments.length; i++) { 
           args.push(arguments[i]); 
       } 
       return args;
   }
   foo(1,2) // (2) [1, 2]
   ```

### 数组去重

1. [...new Set(arr)]

   ```js
   const unique1 = (arr)=> [...new Set(arr)];
   ```

2. filter+indexOf

   ```js
   const unique2 = arr => arr.filter((item, index, array) => array.indexOf(item) === index);
   ```

3. filter+Map，数组对象，基于对象的某个唯一属性去重

   ```js
   function unique3(arr, uniId){
       const res = new Map();
       return arr.filter((item) => !res.has(item[uniId]) && res.set(item[uniId], true));
   }
   ```

   

### 数组扁平化

扁平化就是将多维数组变成一维数组,不存在数组的嵌套

例如：已有多级嵌套数组 : `[1, [2, [3, [4, 5]]], 6]` 将其扁平化处理 输出: `[1,2,3,4,5,6]`

1. es6中的**flat**方法

   ```js
   const flatten = arr => arr.flat(Infinity)
   ```

2. for of + concat 配合递归

   ```js
   function flatten(arr) {
       let result = [];
       for(let item of arr){
           result = result.concat(Array.isArray(item) ? flatten(item) :item );
       }
       return result
   }
   ```

3. reduce 配合递归实现

   ```js
   const flatten = arr => arr.reduce((prev, item) => prev.concat( Array.isArray(item) ? flatten(item)  : item), []);
   ```

### 判断空对象的方法

1. 通过**JSON.stringify**方法来判断

   ```css
   JSON.stringify(obj) === '{}' // true
   ```

2. **for in** 循环判断

   ```js
   function isEmptyObj(obj) {
       for(let item in obj) {
           return true
       }
       return false
   }    
   console.log('对象是否为空：', isEmptyObj({}))
   ```

3. ES6的**Object.keys**方法

   ```css
   Object.keys(obj).length === 0 // true
   ```




### 手写 reduce

```js
Array.prototype.myReduce = function (cb, initialValue) {
  const arr = this;
  let total = initialValue || arr[0];
  // 有初始值的话从0遍历，否则从1遍历
  for (let i = initialValue ? 0 : 1; i < arr.length; i++) {
    total = cb(total, arr[i], i, arr);
  }
  return total;
};
```



### 手写sleep函数

```js
/**
 * 延时: 单位ms
 *
 * @param {number} [time=0]
 * @returns {Promise<undefined>}
 */
function sleep(time = 0) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve(null)
        }, time)
    })
}

(async function (){
    console.log('开始, ' + new Date());
    await sleep(2000)
    console.log('结束, ' + new Date());
})()
```

