# 函数发展史

## 📚 目录

- [ES1 时代（1997 年）](#es1-时代1997年)
- [ES3 时代（1999 年）](#es3-时代1999年)
- [ES5 时代（2009 年）](#es5-时代2009年)
- [ES2015/ES6 时代（2015 年）](#es2015es6-时代2015年)
- [ES2017 时代（2017 年）](#es2017-时代2017年)
- [ES2019 时代（2019 年）](#es2019-时代2019年)
- [实际应用场景](#实际应用场景)
- [性能对比与最佳实践](#性能对比与最佳实践)
- [面试常考算法](#面试常考算法)

---

## ES1 时代（1997 年）

### 📝 ES1 函数基础总览

| 功能分类 | 特性      | 语法                 | 参数     | 返回值 | 用途     |
| -------- | --------- | -------------------- | -------- | ------ | -------- |
| **声明** | function  | `function name() {}` | 无       | 函数   | 函数声明 |
| **调用** | 函数调用  | `functionName()`     | 参数列表 | 任意   | 执行函数 |
| **参数** | arguments | `arguments`          | 无       | 类数组 | 参数对象 |
| **返回** | return    | `return value`       | 任意值   | 任意   | 返回值   |

### 🔧 ES1 详细方法说明

**function 声明 - 基础函数**

```javascript
// 语法：function name(parameters) { body }
// 参数：参数列表
// 返回值：函数

function greet(name) {
  return "Hello, " + name + "!";
}

console.log(greet("张三")); // "Hello, 张三!"

// 实际应用：工具函数
function calculateArea(width, height) {
  return width * height;
}
```

**arguments 对象 - 参数处理**

```javascript
// 语法：arguments
// 参数：无
// 返回值：类数组对象

function sum() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}

console.log(sum(1, 2, 3, 4, 5)); // 15

// 实际应用：可变参数函数
function max() {
  let maxValue = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    if (arguments[i] > maxValue) {
      maxValue = arguments[i];
    }
  }
  return maxValue;
}
```

---

## ES3 时代（1999 年）

> **🎯 解决的问题**：ES3 引入了 Function 构造器，提供了动态创建函数的能力，让函数创建更加灵活。

### 📝 ES3 函数方法总览

| 功能分类 | 方法       | 语法                          | 参数        | 返回值 | 用途         |
| -------- | ---------- | ----------------------------- | ----------- | ------ | ------------ |
| **构造** | Function() | `new Function(...args, body)` | 参数,函数体 | 函数   | 动态创建函数 |

### 🔧 ES3 详细方法说明

**Function() 构造器 - 动态创建函数**

> **🎯 解决的问题**：提供了动态创建函数的能力，让函数创建更加灵活，支持运行时生成函数。

```javascript
// 语法：new Function(...args, body)
// 参数：参数列表, 函数体字符串
// 返回值：函数

const add = new Function("a", "b", "return a + b");
console.log(add(2, 3)); // 5

// 实际应用：动态函数生成
function createValidator(rule) {
  return new Function("value", `return ${rule}`);
}

const isPositive = createValidator("value > 0");
console.log(isPositive(5)); // true
console.log(isPositive(-1)); // false
```

---

## ES5 时代（2009 年）

> **🎯 解决的问题**：ES5 引入了 bind() 方法，解决了 this 绑定问题，让函数调用更加可控。

### 📝 ES5 函数方法总览

| 功能分类 | 方法   | 语法                          | 参数         | 返回值 | 用途             |
| -------- | ------ | ----------------------------- | ------------ | ------ | ---------------- |
| **绑定** | bind() | `func.bind(thisArg, ...args)` | this 值,参数 | 函数   | 绑定 this 和参数 |

### 🔧 ES5 详细方法说明

**bind() - 绑定 this 和参数**

> **🎯 解决的问题**：解决了函数调用时 this 指向不确定的问题，让函数调用更加可控。

```javascript
// 语法：func.bind(thisArg, ...args)
// 参数：this值, 预设参数
// 返回值：新函数

const person = {
  name: "张三",
  greet: function () {
    return "Hello, " + this.name;
  },
};

const boundGreet = person.greet.bind(person);
console.log(boundGreet()); // "Hello, 张三"

// 实际应用：事件处理
function handleClick(event) {
  console.log("Clicked by:", this.name);
}

const button = document.getElementById("myButton");
button.addEventListener("click", handleClick.bind({ name: "用户" }));
```

---

## ES2015/ES6 时代（2015 年）

> **🎯 解决的问题**：ES6 是函数特性的重大更新，引入了箭头函数、默认参数、剩余参数等，解决了函数定义和调用的诸多痛点。

### 📝 ES6 函数特性总览

| 功能分类 | 特性       | 语法                   | 参数     | 返回值 | 用途       |
| -------- | ---------- | ---------------------- | -------- | ------ | ---------- |
| **声明** | 箭头函数   | `() => {}`             | 参数列表 | 任意   | 简洁函数   |
| **参数** | 默认参数   | `function(a = 1) {}`   | 默认值   | 任意   | 参数默认值 |
| **参数** | 剩余参数   | `function(...args) {}` | 参数列表 | 任意   | 收集参数   |
| **参数** | 解构参数   | `function({a, b}) {}`  | 解构对象 | 任意   | 参数解构   |
| **调用** | 展开运算符 | `func(...args)`        | 数组     | 任意   | 展开参数   |

### 🔧 ES6 详细方法说明

**箭头函数 - 简洁函数**

> **🎯 解决的问题**：解决了 this 绑定问题，提供了更简洁的函数语法，让函数定义更加简洁。

```javascript
// 语法：(parameters) => { body }
// 参数：参数列表
// 返回值：函数

// 基础用法
const add = (a, b) => a + b;
console.log(add(2, 3)); // 5

// 实际应用：数组方法
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((n) => n * 2);
console.log(doubled); // [2, 4, 6, 8, 10]

// this 绑定问题解决
const obj = {
  name: "张三",
  traditional: function () {
    setTimeout(function () {
      console.log(this.name); // undefined
    }, 1000);
  },
  arrow: function () {
    setTimeout(() => {
      console.log(this.name); // "张三"
    }, 1000);
  },
};
```

**默认参数 - 参数默认值**

> **🎯 解决的问题**：解决了参数 undefined 检查的问题，让函数调用更加简洁。

```javascript
// 语法：function name(param = defaultValue) {}
// 参数：默认值
// 返回值：函数

function greet(name = "World") {
  return `Hello, ${name}!`;
}

console.log(greet()); // "Hello, World!"
console.log(greet("张三")); // "Hello, 张三!"

// 实际应用：配置对象
function createUser(name, options = {}) {
  return {
    name,
    age: options.age || 18,
    email: options.email || "",
    isActive: options.isActive !== undefined ? options.isActive : true,
  };
}
```

**剩余参数 - 收集参数**

> **🎯 解决的问题**：解决了 arguments 对象的问题，提供了更清晰的参数收集方式。

```javascript
// 语法：function name(...args) {}
// 参数：参数列表
// 返回值：函数

function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}

console.log(sum(1, 2, 3, 4, 5)); // 15

// 实际应用：函数组合
function compose(...fns) {
  return function (value) {
    return fns.reduceRight((acc, fn) => fn(acc), value);
  };
}

const addOne = (x) => x + 1;
const multiplyTwo = (x) => x * 2;
const composed = compose(addOne, multiplyTwo);
console.log(composed(5)); // 11
```

**解构参数 - 参数解构**

```javascript
// 语法：function name({param1, param2}) {}
// 参数：解构对象
// 返回值：函数

function createPerson({ name, age, city = "北京" }) {
  return { name, age, city };
}

const person = createPerson({
  name: "张三",
  age: 25,
});
console.log(person); // {name: "张三", age: 25, city: "北京"}

// 实际应用：API调用
function fetchUser({ id, includeProfile = false }) {
  const url = `/api/users/${id}${includeProfile ? "?include=profile" : ""}`;
  return fetch(url);
}
```

---

## ES2017 时代（2017 年）

> **🎯 解决的问题**：ES2017 引入了 async/await，解决了回调地狱和 Promise 链式调用的问题，让异步编程更加简洁。

### 📝 ES2017 函数特性总览

| 功能分类 | 特性  | 语法                  | 参数    | 返回值  | 用途         |
| -------- | ----- | --------------------- | ------- | ------- | ------------ |
| **异步** | async | `async function() {}` | 无      | Promise | 异步函数     |
| **异步** | await | `await promise`       | Promise | 任意    | 等待 Promise |

### 🔧 ES2017 详细方法说明

**async/await - 异步编程**

> **🎯 解决的问题**：解决了回调地狱和 Promise 链式调用的问题，让异步代码更加简洁易读。

```javascript
// 语法：async function name() { await promise }
// 参数：无
// 返回值：Promise

// 基础用法
async function fetchData() {
  try {
    const response = await fetch("/api/data");
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Error:", error);
  }
}

// 实际应用：顺序异步操作
async function processUserData(userId) {
  try {
    const user = await fetchUser(userId);
    const profile = await fetchProfile(user.id);
    const posts = await fetchPosts(user.id);

    return {
      user,
      profile,
      posts,
    };
  } catch (error) {
    console.error("Processing failed:", error);
  }
}

// 对比：Promise 链式调用
function processUserDataPromise(userId) {
  return fetchUser(userId)
    .then((user) => fetchProfile(user.id))
    .then((profile) => fetchPosts(profile.userId))
    .then((posts) => ({ user, profile, posts }))
    .catch((error) => console.error("Processing failed:", error));
}
```

---

## ES2019 时代（2019 年）

> **🎯 解决的问题**：ES2019 引入了可选的 catch 绑定，解决了 catch 块中必须使用 error 参数的问题。

### 📝 ES2019 函数特性总览

| 功能分类 | 特性       | 语法       | 参数 | 返回值 | 用途         |
| -------- | ---------- | ---------- | ---- | ------ | ------------ |
| **异常** | catch 绑定 | `catch {}` | 无   | 无     | 可选错误绑定 |

### 🔧 ES2019 详细方法说明

**可选的 catch 绑定**

> **🎯 解决的问题**：解决了 catch 块中必须使用 error 参数的问题，让错误处理更加灵活。

```javascript
// 语法：try { } catch { }
// 参数：无
// 返回值：无

// 基础用法
async function fetchData() {
  try {
    const response = await fetch("/api/data");
    return await response.json();
  } catch {
    // 不需要使用 error 参数
    return null;
  }
}

// 实际应用：资源清理
async function cleanup() {
  try {
    await closeDatabase();
    await clearCache();
  } catch {
    // 忽略清理错误，继续执行
  }
}
```

---

## 实际应用场景

### 1. 函数式编程场景

**高阶函数应用**

```javascript
// 函数组合
const pipe =
  (...fns) =>
  (value) =>
    fns.reduce((acc, fn) => fn(acc), value);

const addOne = (x) => x + 1;
const multiplyTwo = (x) => x * 2;
const square = (x) => x * x;

const transform = pipe(addOne, multiplyTwo, square);
console.log(transform(3)); // 64

// 实际应用：数据转换管道
const processUserData = pipe(
  (user) => ({ ...user, fullName: `${user.firstName} ${user.lastName}` }),
  (user) => ({ ...user, isAdult: user.age >= 18 }),
  (user) => ({ ...user, displayName: user.isAdult ? user.fullName : "Child" })
);
```

### 2. 异步编程场景

**并发控制**

```javascript
// 限制并发数量
async function limitConcurrency(tasks, limit = 3) {
  const results = [];
  const executing = [];

  for (const task of tasks) {
    const promise = task().then((result) => {
      executing.splice(executing.indexOf(promise), 1);
      return result;
    });

    results.push(promise);
    executing.push(promise);

    if (executing.length >= limit) {
      await Promise.race(executing);
    }
  }

  return Promise.all(results);
}

// 实际应用：批量API调用
async function fetchUsers(userIds) {
  const tasks = userIds.map((id) => () => fetchUser(id));
  return limitConcurrency(tasks, 5);
}
```

### 3. 事件处理场景

**防抖和节流**

```javascript
// 防抖函数
function debounce(func, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}

// 节流函数
function throttle(func, delay) {
  let lastCall = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      return func.apply(this, args);
    }
  };
}

// 实际应用：搜索输入
const searchInput = document.getElementById("search");
const debouncedSearch = debounce(async (query) => {
  const results = await searchAPI(query);
  displayResults(results);
}, 300);

searchInput.addEventListener("input", (e) => {
  debouncedSearch(e.target.value);
});
```

---

## 性能对比与最佳实践

### 1. 函数声明 vs 函数表达式

```javascript
// 性能测试
function performanceTest() {
  const iterations = 1000000;

  // 函数声明
  function declared() {
    return "declared";
  }

  // 函数表达式
  const expressed = function () {
    return "expressed";
  };

  // 箭头函数
  const arrow = () => "arrow";

  console.time("函数声明");
  for (let i = 0; i < iterations; i++) {
    declared();
  }
  console.timeEnd("函数声明");

  console.time("函数表达式");
  for (let i = 0; i < iterations; i++) {
    expressed();
  }
  console.timeEnd("函数表达式");

  console.time("箭头函数");
  for (let i = 0; i < iterations; i++) {
    arrow();
  }
  console.timeEnd("箭头函数");
}

// 典型结果：函数声明 > 函数表达式 > 箭头函数
```

### 2. 最佳实践建议

**函数设计最佳实践：**

```javascript
// ✅ 推荐：使用箭头函数处理 this 绑定
const obj = {
  name: "张三",
  methods: {
    traditional: function () {
      setTimeout(function () {
        console.log(this.name); // undefined
      }, 1000);
    },
    arrow: function () {
      setTimeout(() => {
        console.log(this.name); // "张三"
      }, 1000);
    },
  },
};

// ✅ 推荐：使用默认参数
function createUser(name, options = {}) {
  return {
    name,
    age: options.age || 18,
    email: options.email || "",
  };
}

// ✅ 推荐：使用剩余参数
function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}

// ✅ 推荐：使用 async/await
async function fetchData() {
  try {
    const response = await fetch("/api/data");
    return await response.json();
  } catch (error) {
    console.error("Error:", error);
  }
}

// ❌ 避免：使用 arguments 对象
function badSum() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}

// ✅ 好的做法
function goodSum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}
```

---

## 面试常考算法

### 1. 函数柯里化

```javascript
// 基础柯里化
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function (...nextArgs) {
        return curried.apply(this, args.concat(nextArgs));
      };
    }
  };
}

// 测试
const add = (a, b, c) => a + b + c;
const curriedAdd = curry(add);

console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6
```

### 2. 函数组合

```javascript
// 函数组合
function compose(...fns) {
  return function (value) {
    return fns.reduceRight((acc, fn) => fn(acc), value);
  };
}

// 管道函数
function pipe(...fns) {
  return function (value) {
    return fns.reduce((acc, fn) => fn(acc), value);
  };
}

// 测试
const addOne = (x) => x + 1;
const multiplyTwo = (x) => x * 2;
const square = (x) => x * x;

const composed = compose(square, multiplyTwo, addOne);
const piped = pipe(addOne, multiplyTwo, square);

console.log(composed(3)); // 64
console.log(piped(3)); // 64
```

### 3. 函数记忆化

```javascript
// 记忆化函数
function memoize(fn) {
  const cache = new Map();
  return function (...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn.apply(this, args);
    cache.set(key, result);
    return result;
  };
}

// 测试：斐波那契数列
const fibonacci = memoize(function (n) {
  if (n <= 1) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
});

console.log(fibonacci(40)); // 102334155 (快速计算)
```

### 4. 函数防抖和节流

```javascript
// 防抖函数
function debounce(func, delay) {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => func.apply(this, args), delay);
  };
}

// 节流函数
function throttle(func, delay) {
  let lastCall = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastCall >= delay) {
      lastCall = now;
      return func.apply(this, args);
    }
  };
}

// 测试
const debouncedLog = debounce(console.log, 300);
const throttledLog = throttle(console.log, 300);

// 快速调用
for (let i = 0; i < 10; i++) {
  debouncedLog("debounced", i);
  throttledLog("throttled", i);
}
```

---

## 📋 总结

### 记忆技巧

1. **分类记忆**：按功能分类（声明、调用、参数、异步）
2. **对比记忆**：传统函数 vs 箭头函数
3. **this 绑定记忆**：箭头函数不绑定 this
4. **参数记忆**：默认参数、剩余参数、解构参数
5. **异步记忆**：async/await 简化异步编程

### 使用建议

1. **优先使用箭头函数**：简洁、this 绑定清晰
2. **使用默认参数**：避免 undefined 检查
3. **使用剩余参数**：替代 arguments 对象
4. **使用 async/await**：简化异步编程
5. **注意性能差异**：选择合适的函数类型
